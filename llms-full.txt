=== PIXONUI CORE CONTEXT ===

# PixonUI - AI Context & Guidelines

This document provides a comprehensive overview of PixonUI for LLMs. Use this context to generate accurate, high-performance, and idiomatic code using the PixonUI library.

## 1. Core Philosophy: Native-First
PixonUI is built to be lightweight, stable, and performant by leveraging native browser APIs instead of heavy third-party libraries.

- **No Radix/Headless UI**: We build our own logic for accessibility and behavior.
- **Native Overlays**: We use the HTML5 `<dialog>` tag for Modals/Dialogs.
- **Native Validation**: We use the `ValidityState` API for forms.
- **Native Motion**: We use CSS Transitions, WAAPI, and View Transitions API.
- **Performance**: We use `content-visibility: auto` for large data displays like Tables.

## 2. Design System (Tailwind CSS)
- **Theme**: Dark mode by default.
- **Glassmorphism**: Use `bg-white/[0.03]`, `backdrop-blur`, and `border-white/10`.
- **Shapes**: Standard radius is `rounded-2xl`.
- **Animations**: Use `transition-all duration-200` and `animate-in` from `tailwindcss-animate`.

## 3. Key Components & Usage

### Layout
- `Surface`: The base container. `<Surface className="p-6">...</Surface>`
- `Card`: Glassmorphic card. Supports `glow` prop for mouse-follow effect.
- `Kanban`: Board with native DnD. Uses `columns` and `tasks` props.

### Chat System (Enterprise-Grade)
- **Architecture**: Uses `useSyncExternalStore` for O(1) state updates, decoupled from React's render cycle.
- **Scalability**: Optimized for 10,000+ conversations and 100,000+ messages using binary-search-based virtualization.
- **Baileys/WhatsApp Support**: Native support for JIDs, presence (composing, recording), message status (played, read), and ephemeral messages.
- `ChatLayout`: Main container for chat interfaces.
- `MessageList`: Virtualized list with dynamic height support and auto-scroll logic.
- `MessageBubble`: Rich media renderer (stickers, audio, location, contacts) with reactions, replies, and interactive message support.
- `InteractiveMessage`: WhatsApp-style interactive messages with buttons (reply, URL, call) and list menus.
- `CarouselMessage`: Horizontal scrolling cards for product showcases or multi-option selections.
- `ChatInput`: Advanced input with mentions, recording state, attachment menus, and reply preview.
- `ChatSidebar`: Virtualized conversation list with real-time presence and unread counters.
- `useChatStore`: Centralized, high-performance store for all chat data.
- `useSocket`: Robust Socket.io hook with room management and event buffering.
- `useBaileysSync`: Specialized hook for mapping Baileys events to the UI state.

### Kanban System (Mega Expansion)
- `KanbanBoard`: Professional board with WIP limits, swimlanes, and multiple views.
- `KanbanTaskModal`: Rich task editor with subtasks, checklists, and activity feeds.
- `KanbanHeader`: Advanced header with view switching (Board, List, Timeline, Table).
- `KanbanFilterBar`: Multi-criteria filtering with saved filters support.
- `KanbanQuickAdd`: Inline task creation for rapid workflow.

### Overlays (Native-First)
- `Dialog`: Uses `<dialog>`. Props: `isOpen`, `onClose`.
- `DropdownMenu`: Positioned via `useFloating`.
- `Popover`: Lightweight overlay for settings/info.
- `Tooltip`: Portal-based, high-performance tooltips.

### Motion
- `Reveal`: Mask-based entry animation. `<Reveal direction="up">...</Reveal>`
- `Magnetic`: Cursor attraction. `<Magnetic strength={0.5}><Button>...</Button></Magnetic>`
- `NumberTicker`: Animated counter. `<NumberTicker value={100} />`
- `ScrollProgress`: Page reading indicator.

## 4. Native Hooks
- `useChatStore(selector)`: High-performance state access for chat data.
- `useConversations()`: Returns sorted, virtualized-ready conversation list.
- `useMessages(chatId)`: Returns messages for a specific chat with O(1) lookup.
- `useSocket(url, options)`: Enterprise-grade Socket.io integration.
- `useBaileysSync(socket)`: Automatic synchronization for WhatsApp/Baileys events.
- `useVirtualList(options)`: Core performance primitive for 120fps scrolling.
- `useVoiceRecorder()`: Native `MediaRecorder` wrapper.
- `useReadReceipts(messages, onRead)`: Visibility-based tracking.
- `useChatSearchWorker(messages)`: Off-thread high-performance local search.
- `useKanbanFilters(tasks)`: Complex task filtering and searching.
- `useKanbanUndo(tasks)`: History management with Undo/Redo support.
- `useKanbanKeyboard()`: Global keyboard shortcuts for Kanban.
- `useKanbanSync(boardId)`: Real-time synchronization logic.
- `useFloating(triggerRef, contentRef, options)`: For custom overlays.
- `useForm({ initialValues, onSubmit })`: Returns `register`, `handleSubmit`, `errors`.
- `useScroll()`: Returns `scrollProgressY` (0 to 1).
- `useResponsive()`: Includes `useBreakpoint` and `useContainerQuery`.
- `useIntersection(ref)`: For lazy-loading and scroll animations.

## 5. Implementation Rules for AI
1. **Always use `cn()`** for merging Tailwind classes.
2. **Prefer `fixed` positioning** for portals (Dropdowns, Tooltips).
3. **Use `asChild` pattern** (via Radix Slot if available, or custom implementation) when nesting interactive elements.
4. **Strict TypeScript**: Never use `any`. Define interfaces for all props.
5. **Accessibility**: Always include `aria-*` attributes and ensure keyboard navigation works (native in `<dialog>`).

## 6. Example: Modern Form with Native Validation
```tsx
import { useForm, TextInput, Button, Surface } from '@pixonui/react';

export function ContactForm() {
  const { register, handleSubmit, errors } = useForm({
    initialValues: { email: '', message: '' },
    onSubmit: (values) => console.log(values),
  });

  return (
    <Surface className="p-6 max-w-md">
      <form onSubmit={handleSubmit} className="space-y-4">
        <TextInput 
          label="Email"
          required
          type="email"
          {...register('email')}
        />
        <TextInput 
          label="Message"
          required
          minLength={10}
          {...register('message')}
        />
        <Button type="submit" variant="primary">Send</Button>
      </form>
    </Surface>
  );
}
```




=== FILE: packages\ui\src\components\ai\AIPromptInput.tsx ===

import React, { useState, useRef, useEffect } from 'react';
import { cva, type VariantProps } from 'class-variance-authority';
import { cn } from '../../utils/cn';
import { Sparkles, Paperclip, ArrowUp, Square, Mic, X, File } from 'lucide-react';
import { Button } from '../button/Button';

const aiPromptInputVariants = cva(
  "relative flex w-full flex-col rounded-2xl border transition-all duration-200 focus-within:ring-4",
  {
    variants: {
      variant: {
        default: "bg-white border-gray-200 shadow-sm focus-within:border-purple-500/50 focus-within:ring-purple-500/10 dark:bg-white/[0.03] dark:border-white/10 dark:shadow-none",
        ghost: "bg-transparent border-transparent shadow-none focus-within:bg-white/50 dark:focus-within:bg-white/5",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
);

export interface Attachment {
  id: string;
  name: string;
  type?: string;
  url?: string;
}

export interface AIPromptInputProps 
  extends Omit<React.TextareaHTMLAttributes<HTMLTextAreaElement>, 'onSubmit'>,
    VariantProps<typeof aiPromptInputVariants> {
  /** Callback fired when the user submits the prompt (Enter or Click) */
  onSubmit?: (value: string) => void;
  /** Whether the AI is currently generating a response */
  isGenerating?: boolean;
  /** Callback fired when the attach button is clicked. If onFilesSelected is provided, this is ignored. */
  onAttach?: () => void;
  /** Callback fired when files are selected via the built-in file picker */
  onFilesSelected?: (files: FileList) => void;
  /** Callback fired when the stop button is clicked */
  onStop?: () => void;
  /** Callback fired when the microphone button is clicked */
  onMic?: () => void;
  /** Maximum number of characters allowed */
  maxLength?: number;
  /** Custom footer content to render below the input */
  footer?: React.ReactNode;
  /** List of attached files to display */
  attachments?: Attachment[];
  /** Callback fired when an attachment is removed */
  onRemoveAttachment?: (attachmentId: string) => void;
  /** Accepted file types for the built-in file picker */
  accept?: string;
  /** Whether to allow multiple files in the built-in file picker */
  multiple?: boolean;
}

/**
 * A specialized input component for AI prompts with support for attachments, 
 * voice input, and generation control.
 */
export const AIPromptInput = React.forwardRef<HTMLTextAreaElement, AIPromptInputProps>(
  ({ 
    className, 
    variant,
    onSubmit, 
    isGenerating, 
    onAttach, 
    onFilesSelected,
    onStop,
    onMic,
    maxLength,
    footer,
    attachments,
    onRemoveAttachment,
    accept,
    multiple,
    placeholder = "Ask AI anything...", 
    value: controlledValue,
    onChange,
    ...props 
  }, ref) => {
    const [internalValue, setInternalValue] = useState('');
    const isControlled = controlledValue !== undefined;
    const value = isControlled ? (controlledValue as string) : internalValue;
    
    const textareaRef = useRef<HTMLTextAreaElement | null>(null);
    const fileInputRef = useRef<HTMLInputElement | null>(null);

    const adjustHeight = () => {
      if (textareaRef.current) {
        textareaRef.current.style.height = 'auto';
        textareaRef.current.style.height = `${textareaRef.current.scrollHeight}px`;
      }
    };

    useEffect(() => {
      adjustHeight();
    }, [value]);

    const handleInput = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
      const newValue = e.target.value;
      if (maxLength && newValue.length > maxLength) return;
      
      if (!isControlled) {
        setInternalValue(newValue);
      }
      onChange?.(e);
    };

    const handleKeyDown = (e: React.KeyboardEvent<HTMLTextAreaElement>) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        if (value.trim() && !isGenerating) {
          onSubmit?.(value);
          if (!isControlled) setInternalValue('');
        }
      }
      props.onKeyDown?.(e);
    };

    const handleSubmit = () => {
      if (isGenerating && onStop) {
        onStop();
      } else if (value.trim()) {
        onSubmit?.(value);
        if (!isControlled) setInternalValue('');
      }
    };

    const handleAttachClick = () => {
      if (onFilesSelected && fileInputRef.current) {
        fileInputRef.current.click();
      } else {
        onAttach?.();
      }
    };

    const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
      if (e.target.files && e.target.files.length > 0) {
        onFilesSelected?.(e.target.files);
      }
      // Reset value to allow selecting the same file again
      if (fileInputRef.current) {
        fileInputRef.current.value = '';
      }
    };

    return (
      <div className={cn(aiPromptInputVariants({ variant, className }))}>
        {/* Hidden File Input */}
        <input
          type="file"
          ref={fileInputRef}
          className="hidden"
          onChange={handleFileChange}
          accept={accept}
          multiple={multiple}
        />

        {/* Attachments Area */}
        {attachments && attachments.length > 0 && (
          <div className="flex flex-wrap gap-2 px-4 pt-4">
            {attachments.map((att) => (
              <div 
                key={att.id} 
                className="group relative flex items-center gap-2 rounded-xl border border-gray-200 bg-gray-50 px-3 py-1.5 text-sm transition-colors hover:bg-gray-100 dark:border-white/10 dark:bg-white/[0.03] dark:hover:bg-white/[0.06]"
              >
                <div className="flex h-5 w-5 items-center justify-center rounded-lg bg-white dark:bg-white/[0.06]">
                  <File className="h-3 w-3 text-purple-500" />
                </div>
                <span className="max-w-[120px] truncate text-gray-700 dark:text-gray-300">
                  {att.name}
                </span>
                <button 
                  onClick={() => onRemoveAttachment?.(att.id)}
                  className="ml-1 rounded-full p-0.5 text-gray-400 opacity-0 transition-all hover:bg-gray-200 hover:text-gray-600 group-hover:opacity-100 dark:hover:bg-white/[0.06] dark:hover:text-white"
                  type="button"
                >
                  <X className="h-3 w-3" />
                </button>
              </div>
            ))}
          </div>
        )}

        <textarea
          ref={(node) => {
            textareaRef.current = node;
            if (typeof ref === 'function') ref(node);
            else if (ref) (ref as React.MutableRefObject<HTMLTextAreaElement | null>).current = node;
          }}
          value={value}
          onChange={handleInput}
          onKeyDown={handleKeyDown}
          placeholder={placeholder}
          rows={1}
          className={cn(
            "w-full resize-none bg-transparent px-4 py-4 text-base outline-none max-h-[200px]",
            "text-gray-900 placeholder:text-gray-400",
            "dark:text-white dark:placeholder:text-white/40"
          )}
          disabled={isGenerating && !onStop}
          {...props}
        />
        
        <div className="flex items-center justify-between px-2 pb-2">
          <div className="flex items-center gap-1">
            <Button 
              variant="ghost" 
              size="icon" 
              className="text-gray-400 hover:text-gray-600 dark:text-white/40 dark:hover:text-white"
              onClick={handleAttachClick}
              type="button"
              title="Attach file"
            >
              <Paperclip className="h-5 w-5" />
            </Button>
            
            {onMic && (
              <Button 
                variant="ghost" 
                size="icon" 
                className="text-gray-400 hover:text-gray-600 dark:text-white/40 dark:hover:text-white"
                onClick={onMic}
                type="button"
                title="Use microphone"
              >
                <Mic className="h-5 w-5" />
              </Button>
            )}
          </div>

          <div className="flex items-center gap-3">
            {maxLength && (
              <span className="text-xs text-gray-400 dark:text-white/30">
                {value.length}/{maxLength}
              </span>
            )}

            <Button
              size="icon"
              disabled={(!value.trim() && !isGenerating) || (isGenerating && !onStop)}
              onClick={handleSubmit}
              className={cn(
                "h-8 w-8 rounded-full transition-all duration-200",
                (value.trim() || isGenerating)
                  ? "bg-purple-600 text-white hover:bg-purple-500 shadow-lg shadow-purple-500/25" 
                  : "bg-gray-100 text-gray-400 dark:bg-white/[0.06] dark:text-white/20"
              )}
            >
              {isGenerating ? (
                onStop ? (
                  <Square className="h-3 w-3 fill-current" />
                ) : (
                  <Sparkles className="h-4 w-4 animate-pulse" />
                )
              ) : (
                <ArrowUp className="h-4 w-4" />
              )}
            </Button>
          </div>
        </div>
        
        {footer && (
          <div className="border-t border-gray-100 px-4 py-2 text-xs text-gray-400 dark:border-white/5 dark:text-white/30">
            {footer}
          </div>
        )}
      </div>
    );
  }
);

AIPromptInput.displayName = 'AIPromptInput';



=== FILE: packages\ui\src\components\ai\AIResponse.tsx ===

import React from 'react';
import { cva, type VariantProps } from 'class-variance-authority';
import { cn } from '../../utils/cn';
import { Copy, RefreshCw, ThumbsUp, ThumbsDown, Sparkles, Share, Edit, ExternalLink } from 'lucide-react';
import { Button } from '../button/Button';

const aiResponseVariants = cva(
  "group relative overflow-hidden rounded-2xl border transition-all duration-200",
  {
    variants: {
      variant: {
        default: "bg-gray-50 border-gray-200 dark:bg-white/[0.02] dark:border-white/10",
        ghost: "bg-transparent border-transparent",
        outline: "bg-transparent border-gray-200 dark:border-white/10",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
);

export interface AIResponseSource {
  title: string;
  url: string;
}

export interface AIResponseProps 
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof aiResponseVariants> {
  /** The content of the response */
  children: React.ReactNode;
  /** Callback fired when the copy button is clicked */
  onCopy?: () => void;
  /** Callback fired when the regenerate button is clicked */
  onRegenerate?: () => void;
  /** Callback fired when feedback buttons are clicked */
  onFeedback?: (type: 'up' | 'down') => void;
  /** Callback fired when the share button is clicked */
  onShare?: () => void;
  /** Callback fired when the edit button is clicked */
  onEdit?: () => void;
  /** Timestamp string to display (e.g., "Just now", "2 mins ago") */
  timestamp?: string;
  /** List of sources/citations to display */
  sources?: AIResponseSource[];
  /** Name of the model used (e.g., "GPT-4") */
  model?: string;
  /** Usage information (e.g., "245 tokens") */
  usage?: string | number;
}

/**
 * A container component for displaying AI-generated responses with 
 * built-in actions for copying, regenerating, and providing feedback.
 */
export const AIResponse = React.forwardRef<HTMLDivElement, AIResponseProps>(
  ({ 
    className, 
    variant,
    children, 
    onCopy, 
    onRegenerate, 
    onFeedback, 
    onShare, 
    onEdit,
    timestamp,
    sources,
    model,
    usage,
    ...props 
  }, ref) => {
    return (
      <div 
        ref={ref}
        className={cn(aiResponseVariants({ variant, className }))}
        {...props}
      >
        {/* Header / Icon */}
        <div className="absolute left-4 top-4 flex items-center gap-3">
          <div className="flex h-6 w-6 items-center justify-center rounded-full bg-gradient-to-br from-purple-500 to-blue-500 shadow-lg shadow-purple-500/20">
            <Sparkles className="h-3.5 w-3.5 text-white" />
          </div>
          {timestamp && (
            <span className="text-xs font-medium text-gray-400 dark:text-white/30">
              {timestamp}
            </span>
          )}
        </div>

        {/* Content */}
        <div className="pl-14 pr-4 py-4">
          <div className="prose prose-sm dark:prose-invert max-w-none text-gray-700 dark:text-gray-300">
            {children}
          </div>

          {/* Sources */}
          {sources && sources.length > 0 && (
            <div className="mt-4 flex flex-wrap gap-2">
              {sources.map((source, index) => (
                <a
                  key={index}
                  href={source.url}
                  target="_blank"
                  rel="noopener noreferrer"
                  className={cn(
                    "flex items-center gap-1.5 rounded-full border px-3 py-1 text-xs transition-colors",
                    "border-gray-200 bg-white text-gray-600 hover:bg-gray-50",
                    "dark:border-white/10 dark:bg-white/[0.03] dark:text-white/60 dark:hover:bg-white/[0.06]"
                  )}
                >
                  <span className="max-w-[150px] truncate">{source.title}</span>
                  <ExternalLink className="h-3 w-3 opacity-50" />
                </a>
              ))}
            </div>
          )}
        </div>

        {/* Actions Footer */}
        <div className="flex items-center justify-between border-t border-gray-200 bg-white/50 px-2 py-1.5 backdrop-blur dark:border-white/5 dark:bg-white/[0.02]">
          
          {/* Meta Info (Model/Usage) */}
          <div className="flex items-center gap-3 px-2 text-[10px] font-medium text-gray-400 dark:text-white/20">
            {model && <span>{model}</span>}
            {usage && <span>{usage}</span>}
          </div>

          {/* Action Buttons */}
          <div className="flex items-center gap-1">
            <Button 
              variant="ghost" 
              size="sm" 
              className="h-7 px-2 text-xs text-gray-500 hover:text-gray-900 dark:text-white/40 dark:hover:text-white"
              onClick={onCopy}
            >
              <Copy className="mr-1.5 h-3.5 w-3.5" />
              Copy
            </Button>

            {onShare && (
              <Button 
                variant="ghost" 
                size="icon" 
                className="h-7 w-7 text-gray-500 hover:text-gray-900 dark:text-white/40 dark:hover:text-white"
                onClick={onShare}
                title="Share"
              >
                <Share className="h-3.5 w-3.5" />
              </Button>
            )}

            {onEdit && (
              <Button 
                variant="ghost" 
                size="icon" 
                className="h-7 w-7 text-gray-500 hover:text-gray-900 dark:text-white/40 dark:hover:text-white"
                onClick={onEdit}
                title="Edit"
              >
                <Edit className="h-3.5 w-3.5" />
              </Button>
            )}
            
            <div className="mx-1 h-3 w-px bg-gray-200 dark:bg-white/10" />
            
            <Button 
              variant="ghost" 
              size="icon" 
              className="h-7 w-7 text-gray-500 hover:text-gray-900 dark:text-white/40 dark:hover:text-white"
              onClick={onRegenerate}
              title="Regenerate"
            >
              <RefreshCw className="h-3.5 w-3.5" />
            </Button>
            
            <Button 
              variant="ghost" 
              size="icon" 
              className="h-7 w-7 text-gray-500 hover:text-gray-900 dark:text-white/40 dark:hover:text-white"
              onClick={() => onFeedback?.('up')}
              title="Helpful"
            >
              <ThumbsUp className="h-3.5 w-3.5" />
            </Button>
            
            <Button 
              variant="ghost" 
              size="icon" 
              className="h-7 w-7 text-gray-500 hover:text-gray-900 dark:text-white/40 dark:hover:text-white"
              onClick={() => onFeedback?.('down')}
              title="Not helpful"
            >
              <ThumbsDown className="h-3.5 w-3.5" />
            </Button>
          </div>
        </div>
      </div>
    );
  }
);

AIResponse.displayName = 'AIResponse';



=== FILE: packages\ui\src\components\ai\AISummaryCard.tsx ===

import React from 'react';
import { cn } from '../../utils/cn';
import { Sparkles, ListChecks, ArrowRight, RefreshCw } from 'lucide-react';

interface AISummaryCardProps extends React.HTMLAttributes<HTMLDivElement> {
  summary: string;
  onRegenerate?: () => void;
  isLoading?: boolean;
}

export function AISummaryCard({ summary, onRegenerate, isLoading, className, ...props }: AISummaryCardProps) {
  return (
    <div 
      className={cn(
        "relative overflow-hidden rounded-2xl border border-white/10 bg-white/[0.03] backdrop-blur-xl p-5 group",
        className
      )} 
      {...props}
    >
      {/* Glow Effect */}
      <div className="absolute -top-24 -right-24 w-48 h-48 bg-purple-500/20 rounded-full blur-[80px] pointer-events-none group-hover:bg-purple-500/30 transition-all duration-700" />
      <div className="absolute -bottom-24 -left-24 w-48 h-48 bg-blue-500/20 rounded-full blur-[80px] pointer-events-none group-hover:bg-blue-500/30 transition-all duration-700" />

      <div className="relative space-y-4">
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-2">
            <div className="flex h-8 w-8 items-center justify-center rounded-lg bg-gradient-to-br from-purple-500 to-blue-500 shadow-lg shadow-purple-500/20">
              <Sparkles className="h-4 w-4 text-white" />
            </div>
            <h3 className="text-sm font-bold text-white tracking-tight">Resumo Inteligente</h3>
          </div>
          
          {onRegenerate && (
            <button 
              onClick={onRegenerate}
              disabled={isLoading}
              className="p-2 rounded-lg hover:bg-white/5 text-white/40 hover:text-white transition-all active:scale-95 disabled:opacity-50"
            >
              <RefreshCw className={cn("h-4 w-4", isLoading && "animate-spin")} />
            </button>
          )}
        </div>

        <div className="space-y-3">
          <p className="text-sm text-white/70 leading-relaxed font-medium">
            {summary}
          </p>
          
          <div className="flex flex-wrap gap-2 pt-2">
             <div className="flex items-center gap-1.5 px-3 py-1 rounded-full bg-white/5 border border-white/5 text-[10px] font-bold text-white/40 uppercase tracking-widest">
               <ListChecks size={12} />
               Key Points Extracted
             </div>
          </div>
        </div>

        <div className="pt-2">
          <button className="flex items-center gap-2 text-[11px] font-bold text-blue-400 hover:text-blue-300 transition-colors uppercase tracking-wider group/btn">
            Ver detalhes da an√°lise
            <ArrowRight size={14} className="group-hover/btn:translate-x-1 transition-transform" />
          </button>
        </div>
      </div>
    </div>
  );
}



=== FILE: packages\ui\src\components\ai\SmartReplySuggestions.tsx ===

import React from 'react';
import { cn } from '../../utils/cn';
import { Sparkles, Send } from 'lucide-react';
import { motion } from 'framer-motion';

interface SmartReplySuggestionsProps {
  replies: string[];
  onSelect: (reply: string) => void;
  isLoading?: boolean;
}

export function SmartReplySuggestions({ replies, onSelect, isLoading }: SmartReplySuggestionsProps) {
  if (isLoading) {
    return (
      <div className="flex gap-2 p-2 px-4 animate-pulse">
        {[1, 2, 3].map((i) => (
          <div key={i} className="h-8 w-32 bg-white/5 rounded-full border border-white/5" />
        ))}
      </div>
    );
  }

  return (
    <div className="flex gap-2 p-2 px-4 overflow-x-auto no-scrollbar scroll-smooth">
      <div className="flex items-center shrink-0 pr-2 border-r border-white/10 mr-1">
        <Sparkles size={14} className="text-purple-400 mr-2" />
        <span className="text-[10px] font-bold text-purple-400/50 uppercase tracking-widest select-none">IA Sugere</span>
      </div>
      
      {replies.map((reply, index) => (
        <motion.button
          key={index}
          initial={{ opacity: 0, y: 10 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ delay: index * 0.1 }}
          onClick={() => onSelect(reply)}
          className={cn(
            "shrink-0 flex items-center gap-2 px-4 py-2 rounded-full",
            "bg-white/[0.03] border border-white/10 text-white/70 text-xs font-medium",
            "hover:bg-white/10 hover:border-white/20 hover:text-white transition-all active:scale-95 group"
          )}
        >
          {reply}
          <Send size={10} className="opacity-0 group-hover:opacity-100 group-hover:translate-x-0.5 transition-all" />
        </motion.button>
      ))}
    </div>
  );
}



=== FILE: packages\ui\src\components\button\Button.tsx ===

import React from 'react';
import { cva, type VariantProps } from 'class-variance-authority';
import { Slot } from '../../utils/Slot';
import { cn } from '../../utils/cn';

const buttonVariants = cva(
  "group relative inline-flex items-center justify-center font-semibold tracking-tight transition-all duration-300 focus:outline-none focus:ring-2 focus:ring-purple-400/40 disabled:opacity-50 disabled:cursor-not-allowed disabled:hover:scale-100 disabled:active:scale-100 hover:scale-[1.02] active:scale-[0.98]",
  {
    variants: {
      variant: {
        primary: "bg-gradient-to-r from-blue-600 via-purple-600 to-blue-600 text-white border-transparent",
        secondary: "bg-zinc-100 text-zinc-900 border border-zinc-200 hover:bg-zinc-200 dark:bg-white/[0.05] dark:text-white dark:border-white/10 dark:hover:bg-white/[0.10] dark:hover:border-white/20",
        outline: "bg-transparent text-zinc-900 border border-zinc-300 hover:bg-zinc-100 dark:text-white dark:border-white/20 dark:hover:bg-white/[0.05] dark:hover:border-white/30",
        ghost: "bg-transparent text-zinc-600 hover:text-zinc-900 hover:bg-zinc-100 dark:text-white/80 dark:hover:text-white dark:hover:bg-white/[0.05] border-transparent",
        danger: "bg-rose-500/10 text-rose-600 border border-rose-500/20 hover:bg-rose-500/20 hover:border-rose-500/30 hover:text-rose-700 dark:text-rose-400 dark:hover:text-rose-300",
        success: "bg-emerald-500/10 text-emerald-600 border border-emerald-500/20 hover:bg-emerald-500/20 hover:border-emerald-500/30 hover:text-emerald-700 dark:text-emerald-400 dark:hover:text-emerald-300",
        alert: "bg-amber-500/10 text-amber-600 border border-amber-500/20 hover:bg-amber-500/20 hover:border-amber-500/30 hover:text-amber-700 dark:text-amber-400 dark:hover:text-amber-300",
      },
      size: {
        sm: "h-9 px-3 text-xs gap-1.5",
        md: "h-11 px-5 text-sm gap-2",
        lg: "h-14 px-8 text-base gap-3",
        icon: "h-10 w-10 p-0 flex items-center justify-center",
      },
      shape: {
        default: "rounded-2xl",
        pill: "rounded-full",
        square: "rounded-lg",
      },
      shadow: {
        true: "",
        false: "",
      },
    },
    compoundVariants: [
      {
        variant: "primary",
        shadow: true,
        class: "shadow-[0_12px_40px_rgba(99,102,241,.45)] hover:shadow-[0_18px_60px_rgba(99,102,241,.6)]",
      },
      {
        variant: "secondary",
        shadow: true,
        class: "shadow-sm",
      }
    ],
    defaultVariants: {
      variant: "primary",
      size: "md",
      shape: "default",
      shadow: true,
    },
  }
);

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  /** Whether the button should be rendered as a child component using Slot */
  asChild?: boolean;
  /** Icon to display on the left side of the button text */
  leftIcon?: React.ReactNode;
  /** Icon to display on the right side of the button text */
  rightIcon?: React.ReactNode;
  /** Whether the button is in a loading state, showing a spinner and disabling interaction */
  isLoading?: boolean;
}

/**
 * A versatile button component with multiple variants, sizes, and states.
 * Supports glassmorphism, gradients, and icons.
 */
export const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ 
    className, 
    variant, 
    size, 
    shape,
    shadow,
    asChild = false,
    leftIcon, 
    rightIcon, 
    isLoading,
    children,
    disabled,
    ...props 
  }, ref) => {
    const Comp = asChild ? Slot : "button";
    
    return (
      <Comp
        ref={ref}
        disabled={disabled || isLoading}
        className={cn(buttonVariants({ variant, size, shape, shadow, className }))}
        {...props}
      >
        {variant === 'primary' && !asChild && (
          <span className="pointer-events-none absolute inset-0 rounded-[inherit] bg-gradient-to-r from-white/18 via-white/5 to-white/18 opacity-0 blur-lg transition-opacity duration-300 group-hover:opacity-100" />
        )}
        
        <span className="relative inline-flex items-center justify-center">
          {isLoading && (
            <svg className="animate-spin -ml-1 mr-2 h-4 w-4 text-current" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
              <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
              <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
            </svg>
          )}
          {!isLoading && leftIcon && <span className={cn("mr-2", size === 'sm' && "mr-1.5")}>{leftIcon}</span>}
          {children}
          {!isLoading && rightIcon && <span className={cn("ml-2", size === 'sm' && "ml-1.5")}>{rightIcon}</span>}
        </span>
      </Comp>
    );
  }
);

Button.displayName = 'Button';



=== FILE: packages\ui\src\components\button\GlowButton.tsx ===

import React, { useRef } from 'react';
import { cn } from '../../utils/cn';

export interface GlowButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  children: React.ReactNode;
  leftIcon?: React.ReactNode;
  rightIcon?: React.ReactNode;
}

export const GlowButton = React.forwardRef<HTMLButtonElement, GlowButtonProps>(
  ({ children, className, leftIcon, rightIcon, ...props }, ref) => {
    const localRef = useRef<HTMLButtonElement>(null);

    const handleMove = (e: React.MouseEvent<HTMLButtonElement>) => {
      const el = localRef.current;
      if (!el) return;
      const rect = el.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      el.style.setProperty('--mouse-x', `${x}px`);
      el.style.setProperty('--mouse-y', `${y}px`);
    };

    // Merge refs
    React.useImperativeHandle(ref, () => localRef.current as HTMLButtonElement);

    return (
      <button
        ref={localRef}
        onMouseMove={handleMove}
        type={props.type ?? 'button'}
        className={cn(
          'group relative inline-flex items-center justify-center gap-2 rounded-2xl px-6 py-3',
          'bg-zinc-100 border border-zinc-200 text-zinc-900',
          'dark:bg-white/[0.03] dark:border-white/10 dark:text-white',
          'font-semibold tracking-tight overflow-hidden',
          'transition-all duration-300',
          'hover:bg-zinc-200 dark:hover:bg-white/[0.05] hover:scale-[1.02]',
          'active:scale-[0.98]',
          'focus:outline-none focus:ring-2 focus:ring-purple-400/40',
          className
        )}
        {...props}
      >
        {/* Mouse follow glow */}
        <div 
          className="pointer-events-none absolute -inset-px opacity-0 transition-opacity duration-300 group-hover:opacity-100"
          style={{
            background: 'radial-gradient(600px circle at var(--mouse-x) var(--mouse-y), rgba(255,255,255,0.4), transparent 40%)'
          }}
        />
        
        {/* Border glow */}
        <div 
          className="pointer-events-none absolute -inset-px rounded-2xl opacity-0 transition-opacity duration-300 group-hover:opacity-100"
          style={{
            background: 'radial-gradient(300px circle at var(--mouse-x) var(--mouse-y), rgba(255,255,255,0.6), transparent 40%)',
            maskImage: 'linear-gradient(#fff, #fff), linear-gradient(#fff, #fff)',
            maskClip: 'content-box, border-box',
            maskComposite: 'exclude',
            WebkitMaskComposite: 'xor',
            padding: '1px'
          }}
        />

        <span className="relative inline-flex items-center gap-2 z-10">
          {leftIcon}
          {children}
          {rightIcon}
        </span>
      </button>
    );
  }
);

GlowButton.displayName = 'GlowButton';



=== FILE: packages\ui\src\components\button\PrimaryButton.tsx ===

import React from 'react';
import { cn } from '../../utils/cn';

interface PrimaryButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  children: React.ReactNode;
  leftIcon?: React.ReactNode;
  rightIcon?: React.ReactNode;
}

export const PrimaryButton = React.forwardRef<HTMLButtonElement, PrimaryButtonProps>(
  ({ children, className, leftIcon, rightIcon, ...props }, ref) => {
    return (
      <button
        ref={ref}
        type={props.type ?? 'button'}
        className={cn(
          'group relative inline-flex items-center justify-center gap-2 rounded-2xl px-5 py-3',
          'bg-gradient-to-r from-blue-600 via-purple-600 to-blue-600',
          'text-white font-semibold tracking-tight',
          'shadow-[0_12px_40px_rgba(99,102,241,.45)]',
          'transition-all duration-300',
          'hover:scale-[1.03] hover:shadow-[0_18px_60px_rgba(99,102,241,.6)]',
          'active:scale-[0.98]',
          'disabled:opacity-50 disabled:cursor-not-allowed',
          'focus:outline-none focus:ring-2 focus:ring-purple-400/40',
          className
        )}
        {...props}
      >
        <span className="pointer-events-none absolute inset-0 rounded-2xl bg-gradient-to-r from-white/18 via-white/5 to-white/18 opacity-0 blur-lg transition-opacity duration-300 group-hover:opacity-100" />
        <span className="relative inline-flex items-center gap-2">
          {leftIcon}
          {children}
          {rightIcon}
        </span>
      </button>
    );
  }
);

PrimaryButton.displayName = 'PrimaryButton';


=== FILE: packages\ui\src\components\card\Card.tsx ===

import React from 'react';
import { cn } from '../../utils/cn';
import { Surface } from '../../primitives/Surface';

export const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <Surface
    ref={ref}
    className={className}
    {...props}
  />
));
Card.displayName = "Card";

export const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-1.5 p-6", className)}
    {...props}
  />
));
CardHeader.displayName = "CardHeader";

export const CardTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h3
    ref={ref}
    className={cn(
      "text-2xl font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
));
CardTitle.displayName = "CardTitle";

export const CardDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <p
    ref={ref}
    className={cn("text-sm text-gray-500 dark:text-white/50", className)}
    {...props}
  />
));
CardDescription.displayName = "CardDescription";

export const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
));
CardContent.displayName = "CardContent";

export const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center p-6 pt-0", className)}
    {...props}
  />
));
CardFooter.displayName = "CardFooter";



=== FILE: packages\ui\src\components\card\MetricCard.tsx ===

import React, { useRef } from 'react';
import { cn } from '../../utils/cn';

// Internal components for MetricCard
function TokenBadge({
  accent = 'teal',
  children,
}: {
  accent?: 'teal' | 'amber' | 'violet' | 'blue' | 'rose' | 'emerald' | 'indigo';
  children: React.ReactNode;
}) {
  const map: Record<string, string> = {
    teal: 'bg-teal-500/90',
    amber: 'bg-amber-400/95',
    violet: 'bg-violet-500/90',
    blue: 'bg-blue-500/90',
    rose: 'bg-rose-500/90',
    emerald: 'bg-emerald-500/90',
    indigo: 'bg-indigo-500/90',
  };

  return (
    <div className={cn('flex h-11 w-11 items-center justify-center rounded-2xl', map[accent] ?? map.teal)}>
      {children}
    </div>
  );
}

function AccentGlow({ accent = 'teal' }: { accent?: 'teal' | 'amber' | 'violet' | 'blue' | 'rose' | 'emerald' | 'indigo' }) {
  const map: Record<string, string> = {
    teal: 'from-teal-400/25 via-teal-400/10 to-transparent',
    amber: 'from-amber-300/25 via-amber-300/10 to-transparent',
    violet: 'from-violet-400/25 via-violet-400/10 to-transparent',
    blue: 'from-blue-400/25 via-blue-400/10 to-transparent',
    rose: 'from-rose-400/25 via-rose-400/10 to-transparent',
    emerald: 'from-emerald-400/25 via-emerald-400/10 to-transparent',
    indigo: 'from-indigo-400/25 via-indigo-400/10 to-transparent',
  };

  return (
    <div
      className={cn(
        'pointer-events-none absolute -right-12 top-1/2 h-40 w-48 -translate-y-1/2 rotate-12',
        'bg-gradient-to-l blur-2xl',
        map[accent] ?? map.teal
      )}
    />
  );
}

function SparkWave({ color = 'currentColor' }: { color?: string }) {
  return (
    <svg
      viewBox="0 0 120 40"
      className="h-6 w-16"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      aria-hidden="true"
    >
      <path
        d="M2 22c10 0 10-10 20-10s10 10 20 10 10-10 20-10 10 10 20 10 10-10 20-10"
        stroke={color}
        strokeWidth="4"
        strokeLinecap="round"
        strokeLinejoin="round"
        opacity="0.95"
      />
    </svg>
  );
}

export interface MetricCardProps extends Omit<React.HTMLAttributes<HTMLDivElement>, 'title'> {
  accent?: 'teal' | 'amber' | 'violet' | 'blue' | 'rose' | 'emerald' | 'indigo';
  icon: React.ReactNode;
  title?: React.ReactNode;
  value: React.ReactNode;
  subtext?: React.ReactNode;
  showWave?: boolean;
  onClick?: () => void;
}

export const MetricCard = React.forwardRef<HTMLDivElement, MetricCardProps>(
  ({ accent = 'teal', icon, title, value, subtext, showWave = false, onClick, className, ...props }, ref) => {
    const localRef = useRef<HTMLDivElement | null>(null);

    const setCenter = () => {
      const el = localRef.current;
      if (!el) return;
      const r = el.getBoundingClientRect();
      el.style.setProperty('--x', `${Math.round(r.width / 2)}px`);
      el.style.setProperty('--y', `${Math.round(r.height / 2)}px`);
    };

    const handleMove = (e: React.MouseEvent) => {
      const el = localRef.current;
      if (!el) return;
      const r = el.getBoundingClientRect();
      el.style.setProperty('--x', `${e.clientX - r.left}px`);
      el.style.setProperty('--y', `${e.clientY - r.top}px`);
    };

    const waveColors: Record<string, string> = {
      teal: 'rgba(45,212,191,.95)',
      amber: 'rgba(251,191,36,.95)',
      violet: 'rgba(167,139,250,.95)',
      blue: 'rgba(96,165,250,.95)',
      rose: 'rgba(251,113,133,.95)',
      emerald: 'rgba(52,211,153,.95)',
      indigo: 'rgba(129,140,248,.95)',
    };

    const waveColor = waveColors[accent] ?? waveColors.teal;

    return (
      <div
        ref={(node) => {
            localRef.current = node;
            if (typeof ref === 'function') ref(node);
            else if (ref) (ref as React.MutableRefObject<HTMLDivElement | null>).current = node;
        }}
        onMouseEnter={setCenter}
        onMouseMove={handleMove}
        onClick={onClick}
        className={cn(
          'group relative overflow-hidden rounded-2xl',
          'bg-white border border-gray-200 shadow-sm',
          'dark:bg-transparent dark:bg-gradient-to-b dark:from-white/[0.06] dark:to-white/[0.03]',
          'dark:border-white/[0.10]',
          'dark:shadow-[0_18px_55px_rgba(0,0,0,.55)]',
          'transition-transform duration-300 hover:scale-[1.015]',
          onClick && 'cursor-pointer',
          className
        )}
        {...props}
      >
        <div
          className="pointer-events-none absolute inset-0 opacity-0 transition-opacity duration-300 group-hover:opacity-100"
          style={{
            background:
              'radial-gradient(180px at var(--x, 50%) var(--y, 50%), rgba(255,255,255,.16), transparent 60%)',
          }}
        />
        <div className="pointer-events-none absolute inset-0 bg-[radial-gradient(220px_140px_at_18%_18%,rgba(255,255,255,.08),transparent_60%)]" />
        <AccentGlow accent={accent} />

        <div className="relative p-5">
          <div className="flex items-start justify-between gap-4">
            <TokenBadge accent={accent}>{icon}</TokenBadge>
            {title && (
              <div className="text-xs font-bold uppercase tracking-widest text-gray-500 dark:text-white/40">
                {title}
              </div>
            )}
          </div>

          <div className="mt-4 flex items-end justify-between gap-4">
            <div className="min-w-0">
              <div className="truncate text-2xl font-semibold tracking-tight text-gray-900 dark:text-white">{value}</div>
              {subtext ? <div className="mt-1 text-sm text-gray-500 dark:text-white/45">{subtext}</div> : null}
            </div>
            {showWave ? <SparkWave color={waveColor} /> : null}
          </div>
        </div>
      </div>
    );
  }
);

MetricCard.displayName = 'MetricCard';


=== FILE: packages\ui\src\components\chat\AudioPlayer.tsx ===

import React, { useState, useRef, useEffect } from 'react';
import { cn } from '../../utils/cn';
import { Play, Pause, Volume2, VolumeX } from 'lucide-react';

interface AudioPlayerProps extends React.HTMLAttributes<HTMLDivElement> {
  src: string;
  duration?: number;
  isMe?: boolean;
}

export function AudioPlayer({ src, duration, isMe, className, ...props }: AudioPlayerProps) {
  const [isPlaying, setIsPlaying] = useState(false);
  const [currentTime, setCurrentTime] = useState(0);
  const [isMuted, setIsMuted] = useState(false);
  const audioRef = useRef<HTMLAudioElement>(null);

  const togglePlay = () => {
    if (audioRef.current) {
      if (isPlaying) {
        audioRef.current.pause();
      } else {
        audioRef.current.play();
      }
      setIsPlaying(!isPlaying);
    }
  };

  const handleTimeUpdate = () => {
    if (audioRef.current) {
      setCurrentTime(audioRef.current.currentTime);
    }
  };

  const handleEnded = () => {
    setIsPlaying(false);
    setCurrentTime(0);
  };

  const formatTime = (time: number) => {
    const minutes = Math.floor(time / 60);
    const seconds = Math.floor(time % 60);
    return `${minutes}:${seconds.toString().padStart(2, '0')}`;
  };

  const progress = duration ? (currentTime / duration) * 100 : 0;

  return (
    <div 
      className={cn(
        "flex items-center gap-3 p-2 rounded-2xl min-w-[200px]",
        isMe ? "bg-white/10" : "bg-gray-100 dark:bg-white/[0.03]",
        className
      )} 
      {...props}
    >
      <audio 
        ref={audioRef} 
        src={src} 
        onTimeUpdate={handleTimeUpdate} 
        onEnded={handleEnded}
      />
      
      <button 
        onClick={togglePlay}
        className={cn(
          "w-10 h-10 rounded-full flex items-center justify-center transition-all",
          isMe ? "bg-white text-blue-600" : "bg-blue-500 text-white"
        )}
      >
        {isPlaying ? <Pause className="h-5 w-5 fill-current" /> : <Play className="h-5 w-5 fill-current ml-0.5" />}
      </button>

      <div className="flex-1 space-y-1">
        <div className="h-1.5 w-full bg-gray-300 dark:bg-white/10 rounded-full overflow-hidden">
          <div 
            className={cn("h-full transition-all duration-100", isMe ? "bg-white" : "bg-blue-500")} 
            style={{ width: `${progress}%` }} 
          />
        </div>
        <div className="flex justify-between text-[10px] font-medium opacity-60">
          <span>{formatTime(currentTime)}</span>
          <span>{duration ? formatTime(duration) : '--:--'}</span>
        </div>
      </div>

      <button 
        onClick={() => setIsMuted(!isMuted)}
        className="p-1.5 rounded-full hover:bg-black/5 dark:hover:bg-white/5 opacity-60"
      >
        {isMuted ? <VolumeX className="h-4 w-4" /> : <Volume2 className="h-4 w-4" />}
      </button>
    </div>
  );
}



=== FILE: packages\ui\src\components\chat\CarouselMessage.tsx ===

import React from 'react';
import { cn } from '../../utils/cn';
import type { InteractiveCard, InteractiveButton } from './types';
import { ExternalLink, Phone, Reply, ChevronLeft, ChevronRight, Copy } from 'lucide-react';

interface CarouselMessageProps {
  cards: InteractiveCard[];
  isOwn: boolean;
  onAction?: (button: InteractiveButton) => void;
}

export function CarouselMessage({ cards, isOwn, onAction }: CarouselMessageProps) {
  const scrollRef = React.useRef<HTMLDivElement>(null);

  const scroll = (direction: 'left' | 'right') => {
    if (scrollRef.current) {
      const amount = 240;
      scrollRef.current.scrollBy({
        left: direction === 'left' ? -amount : amount,
        behavior: 'smooth'
      });
    }
  };

  return (
    <div className="relative group/carousel max-w-[300px] sm:max-w-[400px]">
      <div 
        ref={scrollRef}
        className="flex gap-3 overflow-x-auto scrollbar-hide snap-x snap-mandatory pb-2"
      >
        {cards.map((card, idx) => (
          <div 
            key={idx}
            className="flex-shrink-0 w-[240px] snap-start rounded-2xl bg-white/5 dark:bg-white/[0.03] border border-white/10 overflow-hidden flex flex-col"
          >
            {card.header?.attachment && (
              <div className="aspect-video w-full overflow-hidden">
                <img 
                  src={card.header.attachment.url} 
                  alt="Card" 
                  className="w-full h-full object-cover"
                />
              </div>
            )}
            <div className="p-3 flex-1 flex flex-col">
              <p className="text-sm leading-relaxed mb-1">{card.body}</p>
              {card.footer && <p className="text-[10px] opacity-50 italic mb-3">{card.footer}</p>}
              
              <div className="mt-auto flex flex-col gap-1">
                {card.buttons?.map((btn) => (
                  <button
                    key={btn.id}
                    onClick={() => onAction?.(btn)}
                    className={cn(
                      "flex items-center justify-center gap-2 p-2 rounded-lg text-xs font-medium transition-all",
                      "bg-white/10 hover:bg-white/20 border border-white/10",
                      isOwn ? "text-white" : "text-blue-500 dark:text-blue-400"
                    )}
                  >
                    {btn.type === 'url' && <ExternalLink className="h-3 w-3" />}
                    {btn.type === 'call' && <Phone className="h-3 w-3" />}
                    {btn.type === 'reply' && <Reply className="h-3 w-3" />}
                    {btn.text}
                  </button>
                ))}
                {card.nativeFlow?.buttons.map((btn, idx) => {
                  let params: any = {};
                  try {
                    params = typeof btn.buttonParamsJson === 'string' ? JSON.parse(btn.buttonParamsJson) : btn.buttonParamsJson;
                  } catch (e) {}
                  return (
                    <button
                      key={idx}
                      onClick={() => onAction?.({ id: params.id || btn.name, text: params.display_text || btn.name, type: 'reply', params })}
                      className={cn(
                        "flex items-center justify-center gap-2 p-2 rounded-lg text-xs font-medium transition-all",
                        "bg-white/10 hover:bg-white/20 border border-white/10",
                        isOwn ? "text-white" : "text-blue-500 dark:text-blue-400"
                      )}
                    >
                      {btn.name === 'cta_copy' && <Copy className="h-3 w-3" />}
                      {btn.name === 'cta_url' && <ExternalLink className="h-3 w-3" />}
                      {btn.name === 'cta_call' && <Phone className="h-3 w-3" />}
                      {params.display_text || btn.name}
                    </button>
                  );
                })}
              </div>
            </div>
          </div>
        ))}
      </div>

      {cards.length > 1 && (
        <>
          <button 
            onClick={() => scroll('left')}
            className="absolute left-[-12px] top-1/2 -translate-y-1/2 p-1.5 rounded-full bg-white dark:bg-gray-800 shadow-lg border border-white/10 opacity-0 group-hover/carousel:opacity-100 transition-opacity z-10"
          >
            <ChevronLeft className="h-4 w-4" />
          </button>
          <button 
            onClick={() => scroll('right')}
            className="absolute right-[-12px] top-1/2 -translate-y-1/2 p-1.5 rounded-full bg-white dark:bg-gray-800 shadow-lg border border-white/10 opacity-0 group-hover/carousel:opacity-100 transition-opacity z-10"
          >
            <ChevronRight className="h-4 w-4" />
          </button>
        </>
      )}
    </div>
  );
}



=== FILE: packages\ui\src\components\chat\ChatBanner.tsx ===

import React from 'react';
import { cn } from '../../utils/cn';
import { Info, AlertCircle, X, CheckCircle2 } from 'lucide-react';

interface ChatBannerProps extends React.HTMLAttributes<HTMLDivElement> {
  type?: 'info' | 'warning' | 'error' | 'success';
  message: string;
  action?: {
    label: string;
    onClick: () => void;
  };
  onClose?: () => void;
}

export function ChatBanner({ 
  type = 'info', 
  message, 
  action, 
  onClose, 
  className, 
  ...props 
}: ChatBannerProps) {
  const icons = {
    info: Info,
    warning: AlertCircle,
    error: AlertCircle,
    success: CheckCircle2
  };

  const colors = {
    info: "bg-blue-500/10 text-blue-600 dark:text-blue-400 border-blue-500/20",
    warning: "bg-amber-500/10 text-amber-600 dark:text-amber-400 border-amber-500/20",
    error: "bg-red-500/10 text-red-600 dark:text-red-400 border-red-500/20",
    success: "bg-green-500/10 text-green-600 dark:text-green-400 border-green-500/20"
  };

  const Icon = icons[type];

  return (
    <div 
      className={cn(
        "flex items-center gap-3 px-4 py-2 border-b text-sm animate-in slide-in-from-top duration-300",
        colors[type],
        className
      )} 
      {...props}
    >
      <Icon className="h-4 w-4 shrink-0" />
      <p className="flex-1 font-medium">{message}</p>
      
      {action && (
        <button 
          onClick={action.onClick}
          className="text-xs font-bold uppercase tracking-wider hover:underline"
        >
          {action.label}
        </button>
      )}

      {onClose && (
        <button 
          onClick={onClose}
          className="p-1 rounded-full hover:bg-black/5 dark:hover:bg-white/5 transition-colors"
        >
          <X className="h-4 w-4" />
        </button>
      )}
    </div>
  );
}



=== FILE: packages\ui\src\components\chat\ChatHeader.tsx ===

import React from 'react';
import { cn } from '../../utils/cn';
import type { User } from './types';
import { Avatar } from '../data-display/Avatar';
import { Phone, Video, MoreVertical, ArrowLeft, Search, BellOff } from 'lucide-react';

interface ChatHeaderProps extends React.HTMLAttributes<HTMLDivElement> {
  user: User;
  onBack?: () => void;
  onInfo?: () => void;
  onAvatarClick?: () => void;
  onCall?: () => void;
  onVideoCall?: () => void;
  onSearch?: () => void;
  onMute?: () => void;
  isTyping?: boolean;
  isMuted?: boolean;
  actions?: React.ReactNode;
}

export function ChatHeader({ 
  user, 
  onBack, 
  onInfo, 
  onAvatarClick,
  onCall,
  onVideoCall,
  onSearch,
  onMute,
  isTyping,
  isMuted,
  actions,
  className, 
  ...props 
}: ChatHeaderProps) {
  return (
    <div 
      className={cn(
        "flex h-16 items-center justify-between border-b border-gray-200 dark:border-white/10 bg-white/80 dark:bg-black/40 backdrop-blur px-4 sticky top-0 z-10",
        className
      )} 
      {...props}
    >
      <div className="flex items-center gap-3">
        {onBack && (
          <button onClick={onBack} className="md:hidden p-2 -ml-2 rounded-full hover:bg-gray-100 dark:hover:bg-white/[0.06]">
            <ArrowLeft className="h-5 w-5 text-gray-600 dark:text-white/70" />
          </button>
        )}
        
        <div className="relative cursor-pointer" onClick={onAvatarClick || onInfo}>
          <Avatar src={user.avatar} alt={user.name} fallback={user.name[0]} />
          {user.status === 'online' && (
            <span className="absolute bottom-0 right-0 h-3 w-3 rounded-full bg-green-500 border-2 border-white dark:border-black" />
          )}
        </div>
        
        <div className="cursor-pointer" onClick={onInfo}>
          <div className="flex items-center gap-2">
            <h3 className="font-semibold text-gray-900 dark:text-white leading-none">{user.name}</h3>
            {isMuted && <BellOff className="h-3 w-3 text-gray-400" />}
            {user.tags && user.tags.length > 0 && (
              <div className="flex gap-1">
                {user.tags.slice(0, 2).map((tag, i) => (
                  <span key={i} className="text-[9px] px-1.5 py-0.5 rounded-full bg-primary/10 text-primary border border-primary/20 font-medium">
                    {tag}
                  </span>
                ))}
                {user.tags.length > 2 && (
                  <span className="text-[9px] text-gray-400">+{user.tags.length - 2}</span>
                )}
              </div>
            )}
          </div>
          <p className={cn(
            "text-xs mt-1 transition-colors",
            isTyping ? "text-blue-500 font-medium animate-pulse" : "text-gray-500 dark:text-white/50"
          )}>
            {isTyping ? 'typing...' : user.status === 'online' ? 'Online' : `Last seen ${user.lastSeen?.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}`}
          </p>
        </div>
      </div>

      <div className="flex items-center gap-1">
        {onSearch && (
          <button 
            onClick={onSearch}
            className="p-2 rounded-full hover:bg-gray-100 dark:hover:bg-white/[0.06] text-gray-600 dark:text-white/60 transition-colors"
          >
            <Search className="h-5 w-5" />
          </button>
        )}
        {onCall && (
          <button 
            onClick={onCall}
            className="p-2 rounded-full hover:bg-gray-100 dark:hover:bg-white/[0.06] text-gray-600 dark:text-white/60 transition-colors"
          >
            <Phone className="h-5 w-5" />
          </button>
        )}
        {onVideoCall && (
          <button 
            onClick={onVideoCall}
            className="p-2 rounded-full hover:bg-gray-100 dark:hover:bg-white/[0.06] text-gray-600 dark:text-white/60 transition-colors"
          >
            <Video className="h-5 w-5" />
          </button>
        )}
        
        {actions}

        <button 
          onClick={onInfo}
          className="p-2 rounded-full hover:bg-gray-100 dark:hover:bg-white/[0.06] text-gray-600 dark:text-white/60 transition-colors"
        >
          <MoreVertical className="h-5 w-5" />
        </button>
      </div>
    </div>
  );
}



=== FILE: packages\ui\src\components\chat\ChatInput.tsx ===

import React, { useState, useRef, useEffect, useMemo } from 'react';
import { cn } from '../../utils/cn';
import { Send, Paperclip, Smile, Mic, Image as ImageIcon, AtSign, X, MapPin, Gift, List, Layout } from 'lucide-react';
import { Button } from '../button/Button';
import type { User, Message } from './types';
import { Surface } from '../../primitives/Surface';
import { Avatar } from '../data-display/Avatar';
import { VoiceRecorder } from './VoiceRecorder';
import { 
  DropdownMenu, 
  DropdownMenuTrigger, 
  DropdownMenuContent, 
  DropdownMenuItem 
} from '../overlay/DropdownMenu';

interface ChatInputProps extends Omit<React.HTMLAttributes<HTMLDivElement>, 'onSelect' | 'onChange'> {
  value?: string;
  onValueChange?: (value: string) => void;
  onSend?: (content: string) => void;
  onChange?: (content: string) => void;
  onAttach?: () => void;
  onMic?: () => void;
  onVoiceEnd?: (blob: Blob, duration: number) => void;
  onEmoji?: () => void;
  onGif?: () => void;
  onLocation?: () => void;
  onContact?: () => void;
  onPoll?: () => void;
  onPix?: () => void;
  onCarousel?: () => void;
  onButtons?: () => void;
  onList?: () => void;
  onCancelReply?: () => void;
  placeholder?: string;
  users?: User[];
  replyingTo?: Message;
  isRecording?: boolean;
  maxLength?: number;
  disabled?: boolean;
}

export function ChatInput({ 
  value,
  onValueChange,
  onSend, 
  onChange,
  onAttach, 
  onMic,
  onVoiceEnd,
  onEmoji,
  onGif,
  onLocation,
  onContact,
  onPoll,
  onPix,
  onCarousel,
  onButtons,
  onList,
  onCancelReply,
  placeholder = "Type a message...", 
  users = [],
  replyingTo,
  isRecording,
  maxLength,
  disabled,
  className, 
  ...props 
}: ChatInputProps) {
  const [internalContent, setInternalContent] = useState("");
  const content = value !== undefined ? value : internalContent;
  const setContent = (val: string) => {
    if (onValueChange) onValueChange(val);
    else setInternalContent(val);
  };

  const [isUploading, setIsUploading] = useState(false);
  const [mentionSearch, setMentionSearch] = useState<string | null>(null);
  const [mentionIndex, setMentionIndex] = useState(0);
  const textareaRef = useRef<HTMLTextAreaElement>(null);

  const filteredUsers = useMemo(() => {
    if (mentionSearch === null) return [];
    return users.filter(u => 
      u.name.toLowerCase().includes(mentionSearch.toLowerCase())
    ).slice(0, 5);
  }, [users, mentionSearch]);

  const handleInput = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    if (disabled) return;
    const value = e.target.value;
    if (maxLength && value.length > maxLength) return;
    
    setContent(value);
    onChange?.(value);
    
    // Mention logic
    const lastChar = value[e.target.selectionStart - 1];
    const textBeforeCursor = value.slice(0, e.target.selectionStart);
    const mentionMatch = textBeforeCursor.match(/@(\w*)$/);

    if (mentionMatch) {
      setMentionSearch(mentionMatch[1] || "");
      setMentionIndex(0);
    } else {
      setMentionSearch(null);
    }

    // Auto-resize
    if (textareaRef.current) {
      textareaRef.current.style.height = 'auto';
      textareaRef.current.style.height = `${Math.min(textareaRef.current.scrollHeight, 120)}px`;
    }
  };

  const insertMention = (user: User) => {
    if (!textareaRef.current) return;
    const start = textareaRef.current.selectionStart;
    const textBefore = content.slice(0, start).replace(/@\w*$/, `@${user.name} `);
    const textAfter = content.slice(start);
    setContent(textBefore + textAfter);
    setMentionSearch(null);
    textareaRef.current.focus();
  };

  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (disabled) return;
    if (mentionSearch !== null && filteredUsers.length > 0) {
      if (e.key === 'ArrowDown') {
        e.preventDefault();
        setMentionIndex(prev => (prev + 1) % filteredUsers.length);
      } else if (e.key === 'ArrowUp') {
        e.preventDefault();
        setMentionIndex(prev => (prev - 1 + filteredUsers.length) % filteredUsers.length);
      } else if (e.key === 'Enter' || e.key === 'Tab') {
        e.preventDefault();
        insertMention(filteredUsers[mentionIndex]!);
      } else if (e.key === 'Escape') {
        setMentionSearch(null);
      }
      return;
    }

    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      handleSend();
    }
  };

  const handleSend = () => {
    if (disabled || (!content.trim() && !isRecording)) return;
    onSend?.(content);
    setContent("");
    if (textareaRef.current) {
      textareaRef.current.style.height = 'auto';
    }
  };

  return (
    <div className={cn("p-4 bg-white/80 dark:bg-black/40 backdrop-blur border-t border-gray-200 dark:border-white/10 relative", className)} {...props}>
      {mentionSearch !== null && filteredUsers.length > 0 && (
        <div className="absolute bottom-full left-4 mb-2 w-64 bg-white dark:bg-gray-900 border border-gray-200 dark:border-white/10 rounded-2xl shadow-2xl overflow-hidden animate-in slide-in-from-bottom-4">
          {filteredUsers.map((user, i) => (
            <button
              key={user.id}
              onClick={() => insertMention(user)}
              className={cn(
                "w-full flex items-center gap-3 p-3 text-left transition-colors",
                i === mentionIndex ? "bg-blue-500/10 dark:bg-white/10" : "hover:bg-gray-50 dark:hover:bg-white/5"
              )}
            >
              <Avatar src={user.avatar} alt={user.name} className="w-8 h-8" />
              <div>
                <p className="text-sm font-bold dark:text-white">{user.name}</p>
                <p className="text-xs text-gray-500 dark:text-white/40">@{user.name.toLowerCase().replace(/\s/g, '')}</p>
              </div>
            </button>
          ))}
        </div>
      )}

      {replyingTo && (
        <div className="mb-3 flex items-center justify-between p-3 rounded-2xl bg-blue-500/5 border-l-4 border-blue-500 animate-in slide-in-from-bottom-2">
          <div className="flex-1 min-w-0">
            <p className="text-xs font-bold text-blue-500">Replying to</p>
            <p className="text-sm text-gray-600 dark:text-white/60 truncate">{replyingTo.content}</p>
          </div>
          <button 
            onClick={onCancelReply}
            className="p-1.5 rounded-full hover:bg-gray-200 dark:hover:bg-white/10 text-gray-400"
          >
            <X className="h-4 w-4" />
          </button>
        </div>
      )}

      <div className="flex items-end gap-2">
        <div className="flex items-center gap-1 mb-1">
          <DropdownMenu>
            <DropdownMenuTrigger 
              disabled={disabled}
              className="p-2 rounded-full hover:bg-gray-100 dark:hover:bg-white/[0.06] text-gray-500 dark:text-white/50 transition-colors disabled:opacity-50"
            >
              <Paperclip className="h-5 w-5" />
            </DropdownMenuTrigger>
            <DropdownMenuContent align="start" side="top">
              <DropdownMenuItem onClick={onAttach}>
                <ImageIcon className="h-4 w-4 mr-2" /> Image & Video
              </DropdownMenuItem>
              <DropdownMenuItem onClick={onAttach}>
                <Paperclip className="h-4 w-4 mr-2" /> Document
              </DropdownMenuItem>
              <DropdownMenuItem onClick={onLocation}>
                <MapPin className="h-4 w-4 mr-2" /> Location
              </DropdownMenuItem>
              <DropdownMenuItem onClick={onContact}>
                <AtSign className="h-4 w-4 mr-2" /> Contact
              </DropdownMenuItem>
              <DropdownMenuItem onClick={onPoll}>
                <AtSign className="h-4 w-4 mr-2" /> Poll
              </DropdownMenuItem>
              <DropdownMenuItem onClick={onPix}>
                <AtSign className="h-4 w-4 mr-2" /> PIX
              </DropdownMenuItem>
              <DropdownMenuItem onClick={onCarousel}>
                <Layout className="h-4 w-4 mr-2" /> Carousel
              </DropdownMenuItem>
              <DropdownMenuItem onClick={onButtons}>
                <Layout className="h-4 w-4 mr-2" /> Buttons
              </DropdownMenuItem>
              <DropdownMenuItem onClick={onList}>
                <List className="h-4 w-4 mr-2" /> List Menu
              </DropdownMenuItem>
              <DropdownMenuItem onClick={onGif}>
                <Gift className="h-4 w-4 mr-2" /> GIF
              </DropdownMenuItem>
            </DropdownMenuContent>
          </DropdownMenu>
          
          <button 
            onClick={onEmoji}
            disabled={disabled}
            className="p-2 rounded-full hover:bg-gray-100 dark:hover:bg-white/[0.06] text-gray-500 dark:text-white/50 transition-colors disabled:opacity-50"
          >
            <Smile className="h-5 w-5" />
          </button>
        </div>

        <div className="flex-1 relative">
          {isRecording ? (
            <VoiceRecorder 
              onSend={(blob, duration) => onVoiceEnd?.(blob, duration)}
              onCancel={() => onCancelReply?.()}
            />
          ) : (
            <textarea
              ref={textareaRef}
              value={content}
              onChange={handleInput}
              onKeyDown={handleKeyDown}
              placeholder={placeholder}
              disabled={disabled}
              rows={1}
              className="w-full p-2.5 max-h-[120px] rounded-2xl bg-gray-100 dark:bg-white/[0.03] border border-transparent focus:border-blue-500/50 focus:bg-white dark:focus:bg-white/[0.06] text-sm resize-none transition-all outline-none dark:text-white placeholder:text-gray-400"
            />
          )}
        </div>

        <div className="flex items-center gap-1 mb-1">
          {content.trim() || isRecording ? (
            <button 
              onClick={handleSend}
              disabled={disabled}
              className="p-2.5 rounded-full bg-blue-500 text-white hover:bg-blue-600 shadow-lg shadow-blue-500/20 transition-all active:scale-90"
            >
              <Send className="h-5 w-5" />
            </button>
          ) : (
            <button 
              onClick={onMic}
              disabled={disabled}
              className="p-2.5 rounded-full hover:bg-gray-100 dark:hover:bg-white/[0.06] text-gray-500 dark:text-white/50 transition-colors disabled:opacity-50"
            >
              <Mic className="h-5 w-5" />
            </button>
          )}
        </div>
      </div>
    </div>
  );
}



=== FILE: packages\ui\src\components\chat\ChatLayout.tsx ===

import React from 'react';
import { cn } from '../../utils/cn';

interface ChatLayoutProps extends React.HTMLAttributes<HTMLDivElement> {
  children: React.ReactNode;
}

export function ChatLayout({ children, className, ...props }: ChatLayoutProps) {
  return (
    <div 
      className={cn(
        "flex h-[800px] w-full overflow-hidden rounded-3xl border border-gray-200 dark:border-white/10 bg-white dark:bg-black/40 backdrop-blur-xl shadow-2xl",
        className
      )} 
      {...props}
    >
      {children}
    </div>
  );
}



=== FILE: packages\ui\src\components\chat\ChatProfile.tsx ===

import React from 'react';
import { cn } from '../../utils/cn';
import type { User } from './types';
import { Avatar } from '../data-display/Avatar';
import { Bell, Ban, Trash2, Image, FileText, Link as LinkIcon, X } from 'lucide-react';
import { ScrollArea } from '../data-display/ScrollArea';
import { Separator } from '../data-display/Separator';
import { Switch } from '../form/Switch';

interface ChatProfileProps extends React.HTMLAttributes<HTMLDivElement> {
  user: User;
  onClose?: () => void;
}

export function ChatProfile({ user, onClose, className, ...props }: ChatProfileProps) {
  return (
    <div className={cn("w-80 border-l border-gray-200 dark:border-white/10 bg-white dark:bg-black/20 flex flex-col", className)} {...props}>
      <div className="h-16 flex items-center px-4 border-b border-gray-200 dark:border-white/10">
        <button onClick={onClose} className="p-2 -ml-2 rounded-full hover:bg-gray-100 dark:hover:bg-white/[0.06]">
          <X className="h-5 w-5 text-gray-500" />
        </button>
        <span className="ml-2 font-semibold text-gray-900 dark:text-white">Contact Info</span>
      </div>

      <ScrollArea className="flex-1">
        <div className="p-6 flex flex-col items-center text-center">
          <Avatar src={user.avatar} alt={user.name} fallback={user.name[0]} className="h-24 w-24 mb-4 text-2xl" />
          <h2 className="text-xl font-bold text-gray-900 dark:text-white">{user.name}</h2>
          <p className="text-sm text-gray-500 dark:text-white/50 mt-1">{user.phone || '+1 (555) 000-0000'}</p>
          
          <div className="mt-6 w-full">
            <p className="text-sm text-gray-500 dark:text-white/50 mb-1 text-left">About</p>
            <p className="text-sm text-gray-900 dark:text-white text-left">{user.bio || "Hey there! I am using Pixon Chat."}</p>
          </div>
        </div>

        <Separator />

        <div className="p-4 space-y-4">
          <h3 className="text-xs font-semibold text-gray-500 dark:text-white/40 uppercase tracking-wider">Media & Docs</h3>
          <div className="grid grid-cols-3 gap-2">
            {[1, 2, 3, 4, 5, 6].map((i) => (
              <div key={i} className="aspect-square rounded-2xl bg-gray-100 dark:bg-white/[0.03] overflow-hidden relative group cursor-pointer">
                <div className="absolute inset-0 flex items-center justify-center text-gray-400">
                  <Image className="h-6 w-6" />
                </div>
                <div className="absolute inset-0 bg-black/50 opacity-0 group-hover:opacity-100 transition-opacity" />
              </div>
            ))}
          </div>
        </div>

        <Separator />

        <div className="p-4 space-y-4">
          <div className="flex items-center justify-between">
            <div className="flex items-center gap-3 text-gray-700 dark:text-white/80">
              <Bell className="h-5 w-5" />
              <span className="text-sm font-medium">Mute Notifications</span>
            </div>
            <Switch />
          </div>
        </div>

        <Separator />

        <div className="p-4 space-y-2">
          <button className="w-full flex items-center gap-3 p-3 rounded-2xl hover:bg-red-50 dark:hover:bg-red-500/10 text-red-600 dark:text-red-400 transition-colors text-sm font-medium">
            <Ban className="h-5 w-5" />
            Block {user.name}
          </button>
          <button className="w-full flex items-center gap-3 p-3 rounded-2xl hover:bg-red-50 dark:hover:bg-red-500/10 text-red-600 dark:text-red-400 transition-colors text-sm font-medium">
            <Trash2 className="h-5 w-5" />
            Delete Chat
          </button>
        </div>
      </ScrollArea>
    </div>
  );
}



=== FILE: packages\ui\src\components\chat\ChatSidebar.tsx ===

Ôªøimport React, { useState, useMemo } from 'react';
import { cn } from '../../utils/cn';
import { Search, Plus, Archive, Pin, BellOff, Trash2, Filter, MoreVertical, MessageSquare } from 'lucide-react';
import type { Conversation } from './types';
import { Avatar } from '../data-display/Avatar';
import { 
  DropdownMenu, 
  DropdownMenuTrigger, 
  DropdownMenuContent, 
  DropdownMenuItem 
} from '../overlay/DropdownMenu';

interface ChatSidebarProps extends Omit<React.HTMLAttributes<HTMLDivElement>, 'onSelect'> {
  conversations: Conversation[];
  activeId?: string;
  onSelect?: (id: string) => void;
  onNewChat?: () => void;
  onSearch?: (query: string) => void;
  onArchive?: (id: string) => void;
  onPin?: (id: string) => void;
  onMute?: (id: string) => void;
  onDelete?: (id: string) => void;
  onMarkUnread?: (id: string) => void;
  filter?: 'all' | 'unread' | 'groups';
  sortBy?: 'recent' | 'unread' | 'name';
  hideHeader?: boolean;
}

export function ChatSidebar({ 
  conversations, 
  activeId, 
  onSelect, 
  onNewChat,
  onSearch,
  onArchive,
  onPin,
  onMute,
  onDelete,
  onMarkUnread,
  filter = 'all',
  sortBy = 'recent',
  hideHeader = false,
  className,
  ...props 
}: ChatSidebarProps) {
  const [searchQuery, setSearchQuery] = useState("");

  const filteredConversations = useMemo(() => {
    return conversations.filter(c => {
      const name = c.user?.name || c.group?.name || "";
      return name.toLowerCase().includes(searchQuery.toLowerCase());
    });
  }, [conversations, searchQuery]);

  const handleSearch = (e: React.ChangeEvent<HTMLInputElement>) => {
    const query = e.target.value;
    setSearchQuery(query);
    onSearch?.(query);
  };

  return (
    <div className={cn("flex flex-col border-r border-gray-200 dark:border-white/10 bg-gray-50/50 dark:bg-white/[0.02]", !className?.includes('w-') && "w-80", className)} {...props}>
      {!hideHeader && (
        <div className="p-4 space-y-4">
          <div className="flex items-center justify-between">
            <h2 className="text-xl font-bold text-gray-900 dark:text-white">Messages</h2>
            <div className="flex items-center gap-1">
              <button 
                className="p-2 rounded-full hover:bg-gray-200 dark:hover:bg-white/[0.06] text-gray-600 dark:text-white/60 transition-colors"
                title="Filter"
              >
                <Filter className="h-4 w-4" />
              </button>
              <button 
                onClick={onNewChat}
                className="p-2 rounded-full hover:bg-gray-200 dark:hover:bg-white/[0.06] text-gray-600 dark:text-white/60 transition-colors"
                title="New Chat"
              >
                <Plus className="h-5 w-5" />
              </button>
            </div>
          </div>
          
          <div className="relative">
            <Search className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-gray-400" />
            <input 
              type="text" 
              value={searchQuery}
              onChange={handleSearch}
              placeholder="Search messages..." 
              className="w-full h-10 pl-9 pr-4 rounded-2xl bg-white dark:bg-white/[0.03] border border-gray-200 dark:border-white/10 text-sm focus:outline-none focus:ring-2 focus:ring-blue-500/50 transition-all placeholder:text-gray-400 dark:text-white"
            />
          </div>
        </div>
      )}

      <div 
        className="flex-1 overflow-y-auto [&::-webkit-scrollbar]:w-1.5 [&::-webkit-scrollbar-thumb]:bg-white/10 [&::-webkit-scrollbar-thumb]:rounded-full hover:[&::-webkit-scrollbar-thumb]:bg-white/20 [&::-webkit-scrollbar-track]:bg-transparent"
      >
        <div className="flex flex-col">
          {filteredConversations.map((chat) => {
            const displayName = chat.user?.name || chat.group?.name || "Unknown";
            const displayAvatar = chat.user?.avatar || chat.group?.avatar;
            const isOnline = chat.user?.status === 'online';
            const isActive = activeId === chat.id;

            return (
              <div 
                key={chat.id} 
                className="p-2"
              >
                <div
                  onClick={() => onSelect?.(chat.id)}
                  className={cn(
                    "w-full h-16 flex items-center gap-3 p-3 rounded-2xl transition-all text-left group cursor-pointer",
                    isActive 
                      ? "bg-blue-500/10 dark:bg-white/[0.06] shadow-[0_0_15px_rgba(59,130,246,0.1)] dark:shadow-[0_0_15px_rgba(255,255,255,0.05)]" 
                      : "hover:bg-gray-100 dark:hover:bg-white/[0.03]"
                  )}
                >
                  <div className="relative flex-shrink-0">
                    <Avatar src={displayAvatar} alt={displayName} fallback={displayName[0]} />
                    {isOnline && (
                      <div className="absolute -bottom-0.5 -right-0.5 w-3.5 h-3.5 bg-green-500 border-2 border-white dark:border-[#0a0a0a] rounded-full" />
                    )}
                  </div>

                  <div className="flex-1 min-w-0">
                    <div className="flex items-center justify-between mb-0.5">
                      <span className={cn(
                        "font-semibold truncate",
                        isActive ? "text-blue-600 dark:text-white" : "text-gray-900 dark:text-white/90"
                      )}>
                        {displayName}
                      </span>
                      {chat.lastMessage && (
                        <span className="text-[10px] text-gray-400 dark:text-white/30 whitespace-nowrap">
                          {new Date(chat.lastMessage.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}
                        </span>
                      )}
                    </div>
                    <div className="flex items-center justify-between gap-2">
                      <p className="text-xs text-gray-500 dark:text-white/40 truncate">
                        {chat.isTyping ? (
                          <span className="text-blue-500 animate-pulse">typing...</span>
                        ) : (
                          chat.lastMessage?.content || "No messages yet"
                        )}
                      </p>
                      {chat.unreadCount > 0 && (
                        <span className="flex-shrink-0 min-w-[18px] h-[18px] flex items-center justify-center bg-blue-500 text-white text-[10px] font-bold rounded-full px-1">
                          {chat.unreadCount}
                        </span>
                      )}
                    </div>
                  </div>

                  <div className="opacity-0 group-hover:opacity-100 transition-opacity" onClick={(e) => e.stopPropagation()}>
                    <DropdownMenu>
                      <DropdownMenuTrigger className="p-1 rounded-lg hover:bg-gray-200 dark:hover:bg-white/10 text-gray-400">
                        <MoreVertical className="h-4 w-4" />
                      </DropdownMenuTrigger>
                      <DropdownMenuContent align="end">
                        <DropdownMenuItem onClick={() => onPin?.(chat.id)}>
                          <Pin className="h-4 w-4 mr-2" /> Pin
                        </DropdownMenuItem>
                        <DropdownMenuItem onClick={() => onArchive?.(chat.id)}>
                          <Archive className="h-4 w-4 mr-2" /> Archive
                        </DropdownMenuItem>
                        <DropdownMenuItem onClick={() => onMute?.(chat.id)}>
                          <BellOff className="h-4 w-4 mr-2" /> Mute
                        </DropdownMenuItem>
                        <DropdownMenuItem onClick={() => onMarkUnread?.(chat.id)}>
                          <MessageSquare className="h-4 w-4 mr-2" /> Mark as Unread
                        </DropdownMenuItem>
                        <DropdownMenuItem className="text-red-500" onClick={() => onDelete?.(chat.id)}>
                          <Trash2 className="h-4 w-4 mr-2" /> Delete
                        </DropdownMenuItem>
                      </DropdownMenuContent>
                    </DropdownMenu>
                  </div>
                </div>
              </div>
            );
          })}
        </div>
      </div>
    </div>
  );
}



=== FILE: packages\ui\src\components\chat\DateSeparator.tsx ===

import React from 'react';
import { cn } from '../../utils/cn';
import { Calendar } from 'lucide-react';

interface DateSeparatorProps extends React.HTMLAttributes<HTMLDivElement> {
  date: string;
}

export function DateSeparator({ date, className, ...props }: DateSeparatorProps) {
  return (
    <div className={cn("flex justify-center sticky top-0 z-10 py-4", className)} {...props}>
      <div className="flex items-center gap-2 px-3 py-1 rounded-full bg-gray-100/80 dark:bg-white/5 backdrop-blur text-[10px] font-bold uppercase tracking-wider text-gray-500 dark:text-white/40 border border-gray-200 dark:border-white/10 shadow-sm">
        <Calendar className="h-3 w-3" />
        {date}
      </div>
    </div>
  );
}



=== FILE: packages\ui\src\components\chat\EmojiPicker.tsx ===

import React, { useState } from 'react';
import { cn } from '../../utils/cn';
import { Surface } from '../../primitives/Surface';
import { Search } from 'lucide-react';

interface EmojiPickerProps extends Omit<React.HTMLAttributes<HTMLDivElement>, 'onSelect'> {
  onSelect: (emoji: string) => void;
}

const EMOJI_CATEGORIES = [
  { name: 'Smileys', emojis: ['üòÄ', 'üòÉ', 'üòÑ', 'üòÅ', 'üòÜ', 'üòÖ', 'üòÇ', 'ü§£', 'üòä', 'üòá', 'üôÇ', 'üôÉ', 'üòâ', 'üòå', 'üòç', 'ü•∞', 'üòò', 'üòó', 'üòô', 'üòö', 'üòã', 'üòõ', 'üòù', 'üòú', 'ü§™', 'ü§®', 'üßê', 'ü§ì', 'üòé', 'ü§©', 'ü•≥', 'üòè', 'üòí', 'üòû', 'üòî', 'üòü', 'üòï', 'üôÅ', '‚òπÔ∏è', 'üò£', 'üòñ', 'üò´', 'üò©', 'ü•∫', 'üò¢', 'üò≠', 'üò§', 'üò†', 'üò°', 'ü§¨', 'ü§Ø', 'üò≥', 'ü•µ', 'ü•∂', 'üò±', 'üò®', 'üò∞', 'üò•', 'üòì', 'ü§ó', 'ü§î', 'ü§≠', 'ü§´', 'ü§•', 'üò∂', 'üòê', 'üòë', 'üò¨', 'üôÑ', 'üòØ', 'üò¶', 'üòß', 'üòÆ', 'üò≤', 'ü•±', 'üò¥', 'ü§§', 'üò™', 'üòµ', 'ü§ê', 'ü•¥', 'ü§¢', 'ü§Æ', 'ü§ß', 'üò∑', 'ü§í', 'ü§ï'] },
  { name: 'Hearts', emojis: ['‚ù§Ô∏è', 'üß°', 'üíõ', 'üíö', 'üíô', 'üíú', 'üñ§', 'ü§ç', 'ü§é', 'üíî', '‚ù£Ô∏è', 'üíï', 'üíû', 'üíì', 'üíó', 'üíñ', 'üíò', 'üíù', 'üíü'] },
  { name: 'Gestures', emojis: ['üëç', 'üëé', 'üëå', 'ü§å', 'ü§è', '‚úåÔ∏è', 'ü§û', 'ü§ü', 'ü§ò', 'ü§ô', 'üëà', 'üëâ', 'üëÜ', 'üñï', 'üëá', '‚òùÔ∏è', '‚úä', 'üëä', 'ü§õ', 'ü§ú', 'üëè', 'üôå', 'üëê', 'ü§≤', 'ü§ù', 'üôè', '‚úçÔ∏è', 'üíÖ', 'ü§≥', 'üí™', 'ü¶æ', 'ü¶µ', 'ü¶ø', 'ü¶∂', 'üë£', 'üëÇ', 'ü¶ª', 'üëÉ', 'üß†', 'ü´Ä', 'ü´Å', 'ü¶∑', 'ü¶¥', 'üëÄ', 'üëÅÔ∏è', 'üëÖ', 'üëÑ'] },
  { name: 'Activities', emojis: ['‚öΩ', 'üèÄ', 'üèà', '‚öæ', 'ü•é', 'üéæ', 'üèê', 'üèâ', 'ü•è', 'üé±', 'ü™Ä', 'üèì', 'üè∏', 'üèí', 'üèë', 'ü•ç', 'üèè', 'ü™É', 'ü•Ö', '‚õ≥', 'ü™Å', 'üèπ', 'üé£', 'ü§ø', 'ü•ä', 'ü•ã', 'üéΩ', 'üõπ', 'üõº', 'üõ∑', '‚õ∏Ô∏è', 'üéø', '‚õ∑Ô∏è', 'üèÇ', 'ü™Ç', 'üèãÔ∏è', 'ü§º', 'ü§∏', '‚õπÔ∏è', 'ü§∫', 'ü§æ', 'üèåÔ∏è', 'üèá', 'üßò', 'üèÑ', 'üèä', 'ü§Ω', 'üö£', 'üßó', 'üöµ', 'üö¥'] },
  { name: 'Nature', emojis: ['üê∂', 'üê±', 'üê≠', 'üêπ', 'üê∞', 'ü¶ä', 'üêª', 'üêº', 'üêª‚Äç‚ùÑÔ∏è', 'üê®', 'üêØ', 'ü¶Å', 'üêÆ', 'üê∑', 'üêΩ', 'üê∏', 'üêµ', 'üôà', 'üôâ', 'üôä', 'üêí', 'üêî', 'üêß', 'üê¶', 'üê§', 'üê£', 'üê•', 'ü¶Ü', 'ü¶Ö', 'ü¶â', 'ü¶á', 'üê∫', 'üêó', 'üê¥', 'ü¶Ñ', 'üêù', 'ü™±', 'üêõ', 'ü¶ã', 'üêå', 'üêû', 'üêú', 'ü¶ü', 'ü™∞', 'ü™≤', 'ü™≥', 'ü¶ó', 'üï∑Ô∏è', 'üï∏Ô∏è', 'ü¶Ç', 'üê¢', 'üêç', 'ü¶é', 'ü¶ñ', 'ü¶ï', 'üêô', 'ü¶ë', 'ü¶ê', 'ü¶û', 'ü¶Ä', 'üê°', 'üê†', 'üêü', 'üê¨', 'üê≥', 'üêã', 'ü¶à', 'üêä', 'üêÖ', 'üêÜ', 'ü¶ì', 'ü¶ç', 'ü¶ß', 'ü¶£', 'üêò', 'ü¶õ', 'ü¶è', 'üê™', 'üê´', 'ü¶í', 'ü¶ò', 'ü¶¨', 'üêÉ', 'üêÇ', 'üêÑ', 'üêé', 'üêñ', 'üêè', 'üêë', 'üêê', 'ü¶å', 'üêï', 'üê©', 'ü¶Æ', 'üêï‚Äçü¶∫', 'üêà', 'üêà‚Äç‚¨õ', 'üêì', 'ü¶É', 'ü¶ö', 'ü¶ú', 'ü¶¢', 'ü¶©', 'üïäÔ∏è', 'üêá', 'ü¶ù', 'ü¶®', 'ü¶°', 'ü¶´', 'ü¶¶', 'ü¶•', 'üêÅ', 'üêÄ', 'üêøÔ∏è', 'ü¶î', 'üêæ', 'üêâ', 'üê≤', 'üåµ', 'üéÑ', 'üå≤', 'üå≥', 'üå¥', 'ü™µ', 'üå±', 'üåø', '‚òòÔ∏è', 'üçÄ', 'üéç', 'ü™¥', 'üéã', 'üçÉ', 'üçÇ', 'üçÅ', 'üçÑ', 'üêö', 'ü™®', 'üåæ', 'üíê', 'üå∑', 'üåπ', 'ü•Ä', 'üå∫', 'üå∏', 'üåº', 'üåª', 'üåû', 'üåù', 'üåõ', 'üåú', 'üåö', 'üåï', 'üåñ', 'üåó', 'üåò', 'üåë', 'üåí', 'üåì', 'üåî', 'üåô', 'üåé', 'üåç', 'üåè', 'ü™ê', 'üí´', '‚≠êÔ∏è', 'üåü', '‚ú®', '‚ö°Ô∏è', '‚òÑÔ∏è', 'üí•', 'üî•', 'üå™Ô∏è', 'üåà', '‚òÄÔ∏è', 'üå§Ô∏è', '‚õÖÔ∏è', 'üå•Ô∏è', '‚òÅÔ∏è', 'üå¶Ô∏è', 'üåßÔ∏è', '‚õàÔ∏è', 'üå©Ô∏è', 'üå®Ô∏è', '‚ùÑÔ∏è', '‚òÉÔ∏è', '‚õÑÔ∏è', 'üå¨Ô∏è', 'üí®', 'üíß', 'üí¶', '‚òîÔ∏è', '‚òÇÔ∏è', 'üåä', 'üå´Ô∏è'] }
];

export function EmojiPicker({ onSelect, className, ...props }: EmojiPickerProps) {
  const [search, setSearch] = useState("");

  const filteredCategories = EMOJI_CATEGORIES.map(cat => ({
    ...cat,
    emojis: cat.emojis.filter(e => search === "" || e.includes(search)) // Simple search, usually emojis have names
  })).filter(cat => cat.emojis.length > 0);

  return (
    <Surface className={cn("w-72 h-96 flex flex-col overflow-hidden shadow-2xl", className)} {...props}>
      <div className="p-3 border-b border-gray-200 dark:border-white/10">
        <div className="relative">
          <Search className="absolute left-2.5 top-1/2 -translate-y-1/2 h-3.5 w-3.5 text-gray-400" />
          <input 
            type="text" 
            value={search}
            onChange={(e) => setSearch(e.target.value)}
            placeholder="Search emoji..." 
            className="w-full h-8 pl-8 pr-3 rounded-lg bg-gray-100 dark:bg-white/5 text-xs focus:outline-none focus:ring-2 focus:ring-blue-500/50 transition-all"
          />
        </div>
      </div>
      
      <div className="flex-1 overflow-y-auto p-2 custom-scrollbar">
        {filteredCategories.map(cat => (
          <div key={cat.name} className="mb-4">
            <h4 className="text-[10px] font-bold uppercase tracking-wider text-gray-400 px-2 mb-2">{cat.name}</h4>
            <div className="grid grid-cols-8 gap-1">
              {cat.emojis.map(emoji => (
                <button
                  key={emoji}
                  onClick={() => onSelect(emoji)}
                  className="h-8 w-8 flex items-center justify-center rounded-lg hover:bg-gray-100 dark:hover:bg-white/10 text-lg transition-colors"
                >
                  {emoji}
                </button>
              ))}
            </div>
          </div>
        ))}
      </div>
    </Surface>
  );
}



=== FILE: packages\ui\src\components\chat\GroupHeader.tsx ===

import React from 'react';
import { cn } from '../../utils/cn';
import type { GroupInfo } from './types';
import { Avatar } from '../data-display/Avatar';
import { Phone, Video, MoreVertical, ArrowLeft, Users } from 'lucide-react';

interface GroupHeaderProps extends React.HTMLAttributes<HTMLDivElement> {
  group: GroupInfo;
  onBack?: () => void;
  onInfo?: () => void;
  isTyping?: boolean;
  typingUsers?: string[];
}

export function GroupHeader({ 
  group, 
  onBack, 
  onInfo, 
  isTyping,
  typingUsers = [],
  className, 
  ...props 
}: GroupHeaderProps) {
  const typingText = typingUsers.length > 0 
    ? `${typingUsers.join(', ')} ${typingUsers.length === 1 ? 'is' : 'are'} typing...`
    : 'typing...';

  return (
    <div 
      className={cn(
        "flex h-16 items-center justify-between border-b border-gray-200 dark:border-white/10 bg-white/80 dark:bg-black/40 backdrop-blur px-4 sticky top-0 z-10",
        className
      )} 
      {...props}
    >
      <div className="flex items-center gap-3">
        {onBack && (
          <button onClick={onBack} className="md:hidden p-2 -ml-2 rounded-full hover:bg-gray-100 dark:hover:bg-white/[0.06]">
            <ArrowLeft className="h-5 w-5 text-gray-600 dark:text-white/70" />
          </button>
        )}
        
        <div className="relative cursor-pointer" onClick={onInfo}>
          <div className="flex -space-x-3">
            {group.members.slice(0, 2).map((member, i) => (
              <Avatar 
                key={member.id} 
                src={member.avatar} 
                alt={member.name} 
                fallback={member.name[0]} 
                className={cn("border-2 border-white dark:border-black", i === 0 ? "z-10" : "z-0")}
              />
            ))}
            {group.members.length > 2 && (
              <div className="w-10 h-10 rounded-full bg-gray-200 dark:bg-white/10 border-2 border-white dark:border-black flex items-center justify-center text-[10px] font-bold text-gray-600 dark:text-white/60 z-0">
                +{group.members.length - 2}
              </div>
            )}
          </div>
        </div>
        
        <div className="cursor-pointer min-w-0" onClick={onInfo}>
          <h3 className="font-semibold text-gray-900 dark:text-white leading-none truncate">{group.name}</h3>
          <p className={cn(
            "text-xs mt-1 truncate transition-colors",
            isTyping ? "text-blue-500 font-medium animate-pulse" : "text-gray-500 dark:text-white/50"
          )}>
            {isTyping ? typingText : `${group.members.length} members`}
          </p>
        </div>
      </div>

      <div className="flex items-center gap-1">
        <button className="p-2 rounded-full hover:bg-gray-100 dark:hover:bg-white/[0.06] text-gray-600 dark:text-white/60 transition-colors">
          <Phone className="h-5 w-5" />
        </button>
        <button className="p-2 rounded-full hover:bg-gray-100 dark:hover:bg-white/[0.06] text-gray-600 dark:text-white/60 transition-colors">
          <Video className="h-5 w-5" />
        </button>
        <button 
          onClick={onInfo}
          className="p-2 rounded-full hover:bg-gray-100 dark:hover:bg-white/[0.06] text-gray-600 dark:text-white/60 transition-colors"
        >
          <MoreVertical className="h-5 w-5" />
        </button>
      </div>
    </div>
  );
}



=== FILE: packages\ui\src\components\chat\InteractiveMessage.tsx ===

import React from 'react';
import { cn } from '../../utils/cn';
import type { InteractiveContent, InteractiveButton, InteractiveListSection } from './types';
import { ExternalLink, Phone, Reply, Copy } from 'lucide-react';

interface InteractiveMessageProps {
  data: InteractiveContent;
  isOwn: boolean;
  onAction?: (button: InteractiveButton) => void;
}

export function InteractiveMessage({ data, isOwn, onAction }: InteractiveMessageProps) {
  const renderHeader = () => {
    if (!data.header) return null;
    
    switch (data.header.type) {
      case 'text':
        return <h4 className="font-bold mb-1 text-sm">{data.header.text}</h4>;
      case 'image':
        return (
          <div className="mb-2 rounded-lg overflow-hidden border border-white/10">
            <img src={data.header.attachment?.url} alt="Header" className="w-full h-auto object-cover" />
          </div>
        );
      default:
        return null;
    }
  };

  return (
    <div className="space-y-2 max-w-sm">
      {renderHeader()}
      <p className="text-sm leading-relaxed">{data.body}</p>
      {data.footer && <p className="text-[10px] opacity-50 italic">{data.footer}</p>}
      
      {data.type === 'button' && data.buttons && (
        <div className="flex flex-col gap-1 mt-3">
          {data.buttons.map((btn: InteractiveButton) => (
            <button
              key={btn.id}
              onClick={() => onAction?.(btn)}
              className={cn(
                "flex items-center justify-center gap-2 p-2.5 rounded-xl text-sm font-medium transition-all",
                "bg-white/10 hover:bg-white/20 border border-white/10 active:scale-[0.98]",
                isOwn ? "text-white" : "text-blue-500 dark:text-blue-400"
              )}
            >
              {btn.type === 'url' && <ExternalLink className="h-3.5 w-3.5" />}
              {btn.type === 'call' && <Phone className="h-3.5 w-3.5" />}
              {btn.type === 'reply' && <Reply className="h-3.5 w-3.5" />}
              {btn.text}
            </button>
          ))}
        </div>
      )}

      {data.type === 'list' && data.sections && (
        <div className="mt-3 space-y-3">
          {data.sections.map((section: InteractiveListSection, idx: number) => (
            <div key={idx} className="space-y-1">
              {section.title && (
                <p className="text-[10px] uppercase tracking-wider opacity-40 font-bold px-1">
                  {section.title}
                </p>
              )}
              <div className="flex flex-col gap-1">
                {section.rows.map((row: any) => (
                  <button
                    key={row.id}
                    onClick={() => onAction?.({ id: row.id, text: row.title, type: 'reply' })}
                    className="flex flex-col items-start p-3 rounded-xl bg-white/5 hover:bg-white/10 border border-white/5 transition-colors text-left"
                  >
                    <span className="text-sm font-medium">{row.title}</span>
                    {row.description && (
                      <span className="text-xs opacity-50 line-clamp-1">{row.description}</span>
                    )}
                  </button>
                ))}
              </div>
            </div>
          ))}
        </div>
      )}

      {data.nativeFlow && (
        <div className="flex flex-col gap-1 mt-3">
          {data.nativeFlow.buttons.map((btn, idx) => {
            let params: any = {};
            try {
              params = typeof btn.buttonParamsJson === 'string' ? JSON.parse(btn.buttonParamsJson) : btn.buttonParamsJson;
            } catch (e) {}
            
            return (
              <button
                key={idx}
                onClick={() => onAction?.({ id: params.id || btn.name, text: params.display_text || btn.name, type: 'reply', params })}
                className={cn(
                  "flex items-center justify-center gap-2 p-2.5 rounded-xl text-sm font-medium transition-all",
                  "bg-white/10 hover:bg-white/20 border border-white/10 active:scale-[0.98]",
                  isOwn ? "text-white" : "text-blue-500 dark:text-blue-400"
                )}
              >
                {btn.name === 'cta_copy' && <Copy className="h-3.5 w-3.5" />}
                {btn.name === 'cta_url' && <ExternalLink className="h-3.5 w-3.5" />}
                {btn.name === 'cta_call' && <Phone className="h-3.5 w-3.5" />}
                {btn.name === 'single_select' && <Reply className="h-3.5 w-3.5" />}
                {params.display_text || params.title || btn.name}
              </button>
            );
          })}
        </div>
      )}
    </div>
  );
}



=== FILE: packages\ui\src\components\chat\LinkPreview.tsx ===

import React from 'react';
import { cn } from '../../utils/cn';
import { ExternalLink } from 'lucide-react';

interface LinkPreviewProps extends React.HTMLAttributes<HTMLAnchorElement> {
  url: string;
  title?: string;
  description?: string;
  image?: string;
  siteName?: string;
}

export function LinkPreview({ url, title, description, image, siteName, className, ...props }: LinkPreviewProps) {
  return (
    <a 
      href={url} 
      target="_blank" 
      rel="noopener noreferrer"
      className={cn(
        "block overflow-hidden rounded-xl border border-gray-200 dark:border-white/10 bg-white dark:bg-white/[0.03] hover:bg-gray-50 dark:hover:bg-white/[0.05] transition-all group",
        className
      )} 
      {...props}
    >
      {image && (
        <div className="aspect-video w-full overflow-hidden border-b border-gray-200 dark:border-white/10">
          <img src={image} alt={title} className="w-full h-full object-cover group-hover:scale-105 transition-transform duration-500" />
        </div>
      )}
      <div className="p-3 space-y-1">
        {siteName && <p className="text-[10px] font-bold uppercase tracking-wider text-blue-500">{siteName}</p>}
        <h4 className="text-sm font-semibold text-gray-900 dark:text-white line-clamp-1">{title || url}</h4>
        {description && <p className="text-xs text-gray-500 dark:text-white/50 line-clamp-2">{description}</p>}
        <div className="flex items-center gap-1 text-[10px] text-gray-400 pt-1">
          <ExternalLink className="h-3 w-3" />
          <span className="truncate">{new URL(url).hostname}</span>
        </div>
      </div>
    </a>
  );
}



=== FILE: packages\ui\src\components\chat\MediaLightbox.tsx ===

import React, { useState, useEffect } from 'react';
import { cn } from '../../utils/cn';
import { X, ZoomIn, ZoomOut, Download, Maximize2, RotateCw } from 'lucide-react';
import { motion, AnimatePresence } from 'framer-motion';

interface MediaLightboxProps {
  isOpen: boolean;
  onClose: () => void;
  url: string;
  type?: 'image' | 'video';
  fileName?: string;
  caption?: string;
}

export function MediaLightbox({ isOpen, onClose, url, type = 'image', fileName, caption }: MediaLightboxProps) {
  const [scale, setScale] = useState(1);
  const [rotation, setRotation] = useState(0);

  useEffect(() => {
    if (isOpen) {
      document.body.style.overflow = 'hidden';
    } else {
      document.body.style.overflow = 'auto';
      setScale(1);
      setRotation(0);
    }
    return () => {
      document.body.style.overflow = 'auto';
    };
  }, [isOpen]);

  const handleZoomIn = () => setScale(prev => Math.min(prev + 0.5, 3));
  const handleZoomOut = () => setScale(prev => Math.max(prev - 0.5, 0.5));
  const handleRotate = () => setRotation(prev => (prev + 90) % 360);

  if (!isOpen) return null;

  return (
    <AnimatePresence>
      <div 
        className="fixed inset-0 z-[9999] flex flex-col bg-black/95 backdrop-blur-2xl overflow-hidden"
        onKeyDown={(e) => e.key === 'Escape' && onClose()}
        tabIndex={0}
      >
        {/* Toolbar */}
        <div className="flex items-center justify-between p-4 bg-gradient-to-b from-black/50 to-transparent shrink-0">
          <div className="flex items-center gap-3">
            <div className="text-white">
              <p className="text-sm font-bold truncate max-w-[200px]">{fileName || 'Arquivo de M√≠dia'}</p>
              <p className="text-[10px] text-white/50">WhatsApp Media Viewer</p>
            </div>
          </div>
          
          <div className="flex items-center gap-2">
            <button onClick={handleZoomOut} className="p-2.5 rounded-full hover:bg-white/10 text-white transition-all"><ZoomOut size={20} /></button>
            <button onClick={handleZoomIn} className="p-2.5 rounded-full hover:bg-white/10 text-white transition-all"><ZoomIn size={20} /></button>
            <button onClick={handleRotate} className="p-2.5 rounded-full hover:bg-white/10 text-white transition-all"><RotateCw size={20} /></button>
            <div className="w-px h-6 bg-white/10 mx-1" />
            <button onClick={onClose} className="p-2.5 rounded-full bg-white/10 hover:bg-rose-500 text-white transition-all shadow-xl"><X size={20} /></button>
          </div>
        </div>

        {/* Content Viewport */}
        <div className="flex-1 relative flex items-center justify-center p-4 sm:p-12 overflow-hidden">
          <motion.div 
            drag
            dragConstraints={{ left: 0, right: 0, top: 0, bottom: 0 }}
            className="relative max-w-full max-h-full cursor-grab active:cursor-grabbing"
            style={{ scale, rotate: rotation }}
          >
            {type === 'image' ? (
              <img 
                src={url} 
                alt={caption || 'Media'} 
                className="max-w-full max-h-[80vh] object-contain rounded-lg shadow-[0_0_100px_rgba(0,0,0,0.5)] select-none pointer-events-none" 
              />
            ) : (
              <video 
                src={url} 
                controls 
                autoPlay
                className="max-w-full max-h-[80vh] rounded-lg shadow-2xl" 
              />
            )}
          </motion.div>
        </div>

        {/* Footer / Caption */}
        {caption && (
          <div className="p-8 text-center bg-gradient-to-t from-black/50 to-transparent">
            <p className="text-white text-base font-medium max-w-2xl mx-auto drop-shadow-md">
              {caption}
            </p>
          </div>
        )}
      </div>
    </AnimatePresence>
  );
}



=== FILE: packages\ui\src\components\chat\MentionList.tsx ===

import React from 'react';
import { cn } from '../../utils/cn';
import type { User } from './types';
import { Avatar } from '../data-display/Avatar';
import { Surface } from '../../primitives/Surface';

interface MentionListProps extends Omit<React.HTMLAttributes<HTMLDivElement>, 'onSelect'> {
  users: User[];
  selectedIndex: number;
  onSelect: (user: User) => void;
}

export function MentionList({ users, selectedIndex, onSelect, className, ...props }: MentionListProps) {
  if (users.length === 0) return null;

  return (
    <Surface 
      className={cn(
        "w-64 overflow-hidden shadow-xl animate-in fade-in slide-in-from-bottom-2",
        className
      )} 
      {...props}
    >
      <div className="p-1">
        <div className="px-3 py-2 text-[10px] font-bold uppercase tracking-wider text-gray-400 border-b border-gray-200 dark:border-white/5 mb-1">
          Mention someone
        </div>
        {users.map((user, i) => (
          <button
            key={user.id}
            onClick={() => onSelect(user)}
            className={cn(
              "w-full flex items-center gap-2 p-2 rounded-xl text-left transition-colors",
              i === selectedIndex ? "bg-blue-500 text-white" : "hover:bg-gray-100 dark:hover:bg-white/[0.06]"
            )}
          >
            <Avatar src={user.avatar} alt={user.name} fallback={user.name[0]} size="sm" />
            <div className="flex-1 min-w-0">
              <p className="text-sm font-medium truncate">{user.name}</p>
              {user.status && <p className={cn("text-[10px]", i === selectedIndex ? "text-white/70" : "text-gray-500")}>{user.status}</p>}
            </div>
          </button>
        ))}
      </div>
    </Surface>
  );
}



=== FILE: packages\ui\src\components\chat\MessageBubble.tsx ===

import React from 'react';
import { cn } from '../../utils/cn';
import type { Message } from './types';
import { Check, CheckCheck, MoreHorizontal, Reply, Trash2, Copy, Smile, Forward, Pin, Star, Edit2, MapPin, User as UserIcon, FileText, Volume2, Lock } from 'lucide-react';
import { Motion } from '../feedback/Motion';
import { 
  DropdownMenu, 
  DropdownMenuTrigger, 
  DropdownMenuContent, 
  DropdownMenuItem 
} from '../overlay/DropdownMenu';
import { Image } from '../data-display/Image';
import { AudioPlayer } from './AudioPlayer';
import { WaveformAudio } from './WaveformAudio';
import { ReadReceipt } from './ReadReceipt';
import { LinkPreview } from './LinkPreview';
import { Avatar } from '../data-display/Avatar';
import { InteractiveMessage } from './InteractiveMessage';
import { CarouselMessage } from './CarouselMessage';

interface MessageBubbleProps {
  message: Message;
  isOwn: boolean;
  showAvatar?: boolean;
  showStatus?: boolean;
  className?: string;
  onReply?: () => void;
  onReact?: (emoji: string) => void;
  onDelete?: () => void;
  onEdit?: () => void;
  onForward?: () => void;
  onCopy?: () => void;
  onPin?: () => void;
  onStar?: (starred: boolean) => void;
  onSelect?: () => void;
  onAction?: (action: any) => void;
  onImageClick?: (url: string) => void;
  onTTS?: () => void;
  isSelected?: boolean;
}

export function MessageBubble({ 
  message, 
  isOwn, 
  showAvatar, 
  showStatus = true, 
  className,
  onReply,
  onReact,
  onDelete,
  onEdit,
  onForward,
  onCopy,
  onPin,
  onStar,
  onSelect,
  onAction,
  onTTS,
  onImageClick,
  isSelected
}: MessageBubbleProps) {
  const renderStatus = () => {
    if (!isOwn || !showStatus) return null;
    return <ReadReceipt status={message.status || 'sent'} className="ml-1" />;
  };

  const renderContent = () => {
    if (message.type === 'revoked') {
      return (
        <p className="text-sm italic opacity-50 flex items-center gap-2">
          <Trash2 className="h-3 w-3" /> This message was deleted
        </p>
      );
    }

    switch (message.type) {
      case 'audio':
        return (
          <WaveformAudio 
            src={message.attachments?.[0]?.url || ""} 
            duration={message.attachments?.[0]?.duration} 
            isMe={isOwn} 
          />
        );
      case 'location':
        return (
          <div className="space-y-2">
            <div className="flex items-center gap-2">
              <MapPin className="h-4 w-4" />
              <span className="text-sm font-medium">{message.location?.address || "Shared Location"}</span>
            </div>
            <div className="aspect-video rounded-xl bg-gray-200 dark:bg-white/10 flex items-center justify-center overflow-hidden relative group/map">
              <MapPin className="h-8 w-8 opacity-20 group-hover/map:scale-110 transition-transform" />
              <div className="absolute inset-0 bg-blue-500/5 group-hover/map:bg-blue-500/10 transition-colors" />
            </div>
          </div>
        );
      case 'contact':
        return (
          <div className="flex items-center gap-3 p-2 rounded-xl bg-black/5 dark:bg-white/10 border border-white/5">
            <div className="w-10 h-10 rounded-full bg-blue-500 flex items-center justify-center text-white shadow-lg shadow-blue-500/20">
              <UserIcon className="h-5 w-5" />
            </div>
            <div className="flex-1 min-w-0">
              <p className="text-sm font-bold truncate">{message.contact?.name}</p>
              <p className="text-xs opacity-60 truncate">{message.contact?.phone}</p>
            </div>
          </div>
        );
      case 'file':
        return (
          <div className="flex items-center gap-3 p-3 rounded-xl bg-black/5 dark:bg-white/10 border border-white/5 hover:bg-black/10 dark:hover:bg-white/20 transition-colors cursor-pointer">
            <div className="w-10 h-10 rounded-xl bg-blue-500/20 flex items-center justify-center text-blue-500">
              <FileText className="h-6 w-6" />
            </div>
            <div className="flex-1 min-w-0">
              <p className="text-sm font-medium truncate">{message.attachments?.[0]?.name || "File"}</p>
              <p className="text-[10px] opacity-60 uppercase">{message.attachments?.[0]?.size || "Unknown size"}</p>
            </div>
          </div>
        );
      case 'sticker':
        return (
          <div className="relative group/sticker">
            <img 
              src={message.attachments?.[0]?.url} 
              alt="Sticker" 
              className="w-32 h-32 object-contain"
            />
          </div>
        );
      case 'image':
        return (
          <div className="space-y-2">
            <div 
              className="relative rounded-2xl overflow-hidden border border-white/5 group/image cursor-pointer"
              onClick={() => onImageClick?.(message.attachments?.[0]?.url || "")}
            >
              <Image 
                src={message.attachments?.[0]?.url || ""} 
                alt={message.content || "Image"}
                className="max-h-[300px] w-auto object-contain bg-black/20 transition-transform duration-300 group-hover/image:scale-105"
              />
            </div>
            {message.content && (
              <p className="text-sm leading-relaxed whitespace-pre-wrap break-words px-1">{message.content}</p>
            )}
          </div>
        );
      case 'video':
        return (
          <div className="space-y-2">
            <div className="relative rounded-2xl overflow-hidden border border-white/5 bg-black/20 aspect-video flex items-center justify-center group/video">
              <video 
                src={message.attachments?.[0]?.url} 
                controls 
                className="max-h-[300px] w-full"
              />
            </div>
            {message.content && (
              <p className="text-sm leading-relaxed whitespace-pre-wrap break-words px-1">{message.content}</p>
            )}
          </div>
        );
      case 'interactive':
        if (message.interactive?.type === 'carousel' && message.interactive.cards) {
          return <CarouselMessage cards={message.interactive.cards} isOwn={isOwn} onAction={onAction} />;
        }
        if (message.interactive) {
          return <InteractiveMessage data={message.interactive} isOwn={isOwn} onAction={onAction} />;
        }
        return null;
      default:
        const urlRegex = /(https?:\/\/[^\s]+)/g;
        const urls = message.content.match(urlRegex);
        
        return (
          <div className="space-y-2">
            {message.replyTo && (
              <div className="mb-2 p-2 rounded-lg bg-black/5 dark:bg-white/5 border-l-4 border-blue-500 text-xs">
                <p className="font-bold text-blue-500 truncate">
                  {message.replyTo.senderId === message.senderId ? 'You' : 'Other'}
                </p>
                <p className="opacity-60 truncate">{message.replyTo.content}</p>
              </div>
            )}
            <p className="text-sm leading-relaxed whitespace-pre-wrap break-words">{message.content}</p>
            {urls && urls.map(url => <LinkPreview key={url} url={url} />)}
          </div>
        );
    }
  };

  return (
    <div className={cn(
      "flex w-full mb-4 group/bubble",
      isOwn ? "justify-end" : "justify-start",
      className
    )}>
      {!isOwn && showAvatar && (
        <div className="mr-2 mt-auto">
          <Avatar 
            src={message.contact?.avatar} 
            alt={message.contact?.name || "User"} 
            className="w-8 h-8"
            fallback={(message.contact?.name || message.senderId || "?").charAt(0).toUpperCase()}
          />
        </div>
      )}
      
      <div className={cn(
        "relative max-w-[75%] sm:max-w-[60%] transition-all duration-300",
        isSelected && "scale-95 opacity-80"
      )}>
        {message.agentName && (
          <div className={cn(
            "flex items-center gap-1.5 mb-1 px-2 opacity-50",
            isOwn ? "justify-end" : "justify-start"
          )}>
            <div className="flex h-4 w-4 items-center justify-center rounded-full bg-white/10">
              <UserIcon size={10} className="text-blue-400" />
            </div>
            <span className="text-[10px] font-bold tracking-wider uppercase">Agente: {message.agentName}</span>
          </div>
        )}

        <Motion preset="spring">
          <div className={cn(
            "relative p-3 rounded-2xl shadow-sm backdrop-blur-md border",
            message.isInternalNote
              ? "bg-amber-500/10 border-amber-500/20 text-amber-100 italic"
              : (isOwn 
                  ? "bg-blue-600/90 dark:bg-blue-500/20 text-white border-blue-500/20 rounded-tr-none" 
                  : "bg-white/80 dark:bg-white/[0.05] text-gray-900 dark:text-white border-white/10 rounded-tl-none"),
            "hover:shadow-lg hover:shadow-blue-500/5 transition-shadow"
          )}>
            {message.isInternalNote && (
              <div className="flex items-center gap-1.5 mb-1.5 px-1.5 py-0.5 rounded-md bg-amber-500/20 border border-amber-500/30 w-fit">
                <Lock size={10} className="text-amber-500" />
                <span className="text-[10px] font-bold text-amber-500 uppercase tracking-widest">Nota Interna</span>
              </div>
            )}
            {!isOwn && message.remoteJid?.endsWith('@g.us') && message.contact?.name && (
              <p className="text-[11px] font-bold text-blue-500 dark:text-blue-400 mb-1 truncate">
                {message.contact.name}
              </p>
            )}
            {renderContent()}
            
            <div className="flex items-center justify-end gap-1 mt-1 opacity-60 text-[10px]">
              <span>{new Date(message.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}</span>
              {renderStatus()}
            </div>

            {/* Reactions */}
            {message.reactions && Object.keys(message.reactions).length > 0 && (
              <div className="absolute -bottom-3 right-2 flex -space-x-1">
                {Object.entries(message.reactions).map(([emoji, users]) => (
                  <div 
                    key={emoji}
                    className="bg-white dark:bg-gray-800 border border-gray-200 dark:border-white/10 rounded-full px-1.5 py-0.5 text-xs shadow-sm animate-in zoom-in-50"
                    title={users.join(', ')}
                  >
                    {emoji}
                  </div>
                ))}
              </div>
            )}
          </div>
        </Motion>

        {/* Actions Menu */}
        <div className={cn(
          "absolute top-0 opacity-0 group-hover/bubble:opacity-100 transition-opacity flex items-center gap-1",
          isOwn ? "right-full mr-2" : "left-full ml-2"
        )}>
          <DropdownMenu>
            <DropdownMenuTrigger className="p-1.5 rounded-full hover:bg-gray-100 dark:hover:bg-white/10 text-gray-400 transition-colors">
              <Smile className="h-4 w-4" />
            </DropdownMenuTrigger>
            <DropdownMenuContent side="top" className="flex gap-1 p-1">
              {['üëç', '‚ù§Ô∏è', 'üòÇ', 'üòÆ', 'üò¢', 'üôè'].map(emoji => (
                <button 
                  key={emoji}
                  onClick={() => onReact?.(emoji)}
                  className="p-1.5 hover:bg-gray-100 dark:hover:bg-white/10 rounded-lg transition-transform hover:scale-125"
                >
                  {emoji}
                </button>
              ))}
            </DropdownMenuContent>
          </DropdownMenu>

          <DropdownMenu>
            <DropdownMenuTrigger className="p-1.5 rounded-full hover:bg-gray-100 dark:hover:bg-white/10 text-gray-400 transition-colors">
              <MoreHorizontal className="h-4 w-4" />
            </DropdownMenuTrigger>
            <DropdownMenuContent align={isOwn ? "end" : "start"}>
              <DropdownMenuItem onClick={onReply}>
                <Reply className="h-4 w-4 mr-2" /> Reply
              </DropdownMenuItem>
              <DropdownMenuItem onClick={onCopy}>
                <Copy className="h-4 w-4 mr-2" /> Copy
              </DropdownMenuItem>
              <DropdownMenuItem onClick={onForward}>
                <Forward className="h-4 w-4 mr-2" /> Forward
              </DropdownMenuItem>
              <DropdownMenuItem onClick={onPin}>
                <Pin className="h-4 w-4 mr-2" /> Pin
              </DropdownMenuItem>
              <DropdownMenuItem onClick={() => onStar?.(true)}>
                <Star className="h-4 w-4 mr-2" /> Star
              </DropdownMenuItem>
              {onTTS && message.type === 'text' && (
                <DropdownMenuItem onClick={onTTS}>
                  <Volume2 className="h-4 w-4 mr-2" /> Listen (TTS)
                </DropdownMenuItem>
              )}
              {isOwn && (
                <>
                  <DropdownMenuItem onClick={onEdit}>
                    <Edit2 className="h-4 w-4 mr-2" /> Edit
                  </DropdownMenuItem>
                  <DropdownMenuItem className="text-red-500" onClick={onDelete}>
                    <Trash2 className="h-4 w-4 mr-2" /> Delete
                  </DropdownMenuItem>
                </>
              )}
            </DropdownMenuContent>
          </DropdownMenu>
        </div>
      </div>
    </div>
  );
}



=== FILE: packages\ui\src\components\chat\MessageList.tsx ===

import React, { useRef, useEffect, useState, useMemo, useCallback, useLayoutEffect } from 'react';
import { cn } from '../../utils/cn';
import type { Message } from './types';
import { MessageBubble } from './MessageBubble';
import { StickyDateHeader } from './StickyDateHeader';
import { MessageSquare, Calendar, ArrowDown } from 'lucide-react';

interface MessageListProps extends Omit<React.HTMLAttributes<HTMLDivElement>, 'onCopy' | 'onSelect'> {
  messages: Message[];
  currentUserId: string;
  onReply?: (message: Message) => void;
  onReact?: (message: Message, emoji: string) => void;
  onDelete?: (message: Message) => void;
  onEdit?: (message: Message) => void;
  onForward?: (message: Message) => void;
  onCopy?: (message: Message) => void;
  onPin?: (message: Message) => void;
  onStar?: (message: Message, starred: boolean) => void;
  onSelect?: (message: Message) => void;
  onAction?: (message: Message, action: any) => void;
  onImageClick?: (url: string) => void;
  onTTS?: (message: Message) => void;
  onLoadMore?: () => void;
  hasMore?: boolean;
  isLoadingMore?: boolean;
  selectedMessages?: string[];
  dateFormat?: string;
  groupByDate?: boolean;
}

export function MessageList({ 
  messages, 
  currentUserId, 
  className, 
  onReply,
  onReact,
  onDelete,
  onEdit,
  onForward,
  onCopy,
  onPin,
  onStar,
  onSelect,
  onAction,
  onImageClick,
  onTTS,
  onLoadMore,
  hasMore,
  isLoadingMore,
  selectedMessages = [],
  dateFormat = 'MMMM d, yyyy',
  groupByDate = true,
  ...props 
}: MessageListProps) {
  const [shouldAutoScroll, setShouldAutoScroll] = useState(true);
  const containerRef = useRef<HTMLDivElement>(null);
  const messagesEndRef = useRef<HTMLDivElement>(null);

  const scrollToBottom = useCallback((behavior: ScrollBehavior = 'auto') => {
    messagesEndRef.current?.scrollIntoView({ behavior });
  }, []);

  useEffect(() => {
    if (shouldAutoScroll) {
      scrollToBottom('smooth');
    }
  }, [messages.length, shouldAutoScroll, scrollToBottom]);

  const handleScroll = (e: React.UIEvent<HTMLDivElement>) => {
    const target = e.currentTarget;
    const isAtBottom = Math.abs(target.scrollHeight - target.clientHeight - target.scrollTop) < 100;
    setShouldAutoScroll(isAtBottom);

    if (target.scrollTop === 0 && hasMore && !isLoadingMore && onLoadMore) {
      onLoadMore();
    }
  };

  if (messages.length === 0 && !isLoadingMore) {
    return (
      <div className={cn("flex-1 flex items-center justify-center p-8 text-center text-gray-500 dark:text-white/40", className)} {...props}>
        <div className="max-w-sm space-y-4">
          <div className="w-24 h-24 bg-blue-500/10 dark:bg-white/[0.03] rounded-full flex items-center justify-center mx-auto mb-6 animate-pulse">
            <MessageSquare className="h-12 w-12 text-blue-500" />
          </div>
          <h3 className="text-xl font-medium text-gray-900 dark:text-white">No messages yet</h3>
          <p>Start the conversation by sending a message below.</p>
        </div>
      </div>
    );
  }

  return (
    <div className={cn("flex-1 relative overflow-hidden", className)} {...props}>
      <div 
        ref={containerRef}
        onScroll={handleScroll}
        className="h-full overflow-y-auto p-4 [&::-webkit-scrollbar]:w-1.5 [&::-webkit-scrollbar-thumb]:bg-white/10 [&::-webkit-scrollbar-thumb]:rounded-full hover:[&::-webkit-scrollbar-thumb]:bg-white/20 [&::-webkit-scrollbar-track]:bg-transparent"
      >
        <div className="flex flex-col gap-4">
          {messages.map((message, index) => {
            const isOwn = message.senderId === currentUserId;
            const prevMessage = index > 0 ? messages[index - 1] : null;

            // Date processing
            const msgDate = new Date(message.timestamp);
            const prevMsgDate = prevMessage ? new Date(prevMessage.timestamp) : null;
            const showDate = groupByDate && (!prevMsgDate || msgDate.toDateString() !== prevMsgDate.toDateString());

            const showAvatar = !isOwn && (!prevMessage || prevMessage.senderId !== message.senderId || showDate);

            return (
              <React.Fragment key={message.id}>
                {showDate && (
                  <div className="my-4">
                    <StickyDateHeader date={message.timestamp} />
                  </div>
                )}
                <MessageBubble
                  message={message}
                  isOwn={isOwn}
                  showAvatar={showAvatar}
                  onReply={() => onReply?.(message)}
                  onReact={(emoji) => onReact?.(message, emoji)}
                  onDelete={() => onDelete?.(message)}
                  onEdit={() => onEdit?.(message)}
                  onForward={() => onForward?.(message)}
                  onCopy={() => onCopy?.(message)}
                  onPin={() => onPin?.(message)}
                  onStar={(starred) => onStar?.(message, starred)}
                  onSelect={() => onSelect?.(message)}
                  onAction={(action) => onAction?.(message, action)}
                  onImageClick={onImageClick}
                  onTTS={onTTS ? () => onTTS(message) : undefined}
                  isSelected={selectedMessages.includes(message.id)}
                />
              </React.Fragment>
            );
          })}
          <div ref={messagesEndRef} />
        </div>
      </div>

      {!shouldAutoScroll && (
        <button 
          onClick={() => scrollToBottom('smooth')}
          className="absolute bottom-6 right-6 p-3 rounded-full bg-white dark:bg-white/10 backdrop-blur border border-gray-200 dark:border-white/10 shadow-lg text-gray-600 dark:text-white hover:scale-110 transition-all z-10"
        >
          <ArrowDown className="h-5 w-5" />
        </button>
      )}
    </div>
  );
}



=== FILE: packages\ui\src\components\chat\MessageSearch.tsx ===

import React, { useState } from 'react';
import { cn } from '../../utils/cn';
import { Search, X, ChevronUp, ChevronDown } from 'lucide-react';
import type { Message } from './types';

interface MessageSearchProps extends Omit<React.HTMLAttributes<HTMLDivElement>, 'onSearch' | 'results'> {
  onSearch: (query: string) => void;
  results: Message[];
  onResultClick: (message: Message) => void;
  onClose: () => void;
}

export function MessageSearch({ 
  onSearch, 
  results, 
  onResultClick, 
  onClose, 
  className, 
  ...props 
}: MessageSearchProps) {
  const [query, setQuery] = useState("");

  const handleSearch = (e: React.ChangeEvent<HTMLInputElement>) => {
    const val = e.target.value;
    setQuery(val);
    onSearch(val);
  };

  return (
    <div 
      className={cn(
        "flex flex-col h-full bg-white dark:bg-gray-900 border-l border-gray-200 dark:border-white/10 animate-in slide-in-from-right duration-300",
        className
      )} 
      {...props}
    >
      <div className="p-4 border-b border-gray-200 dark:border-white/10 flex items-center justify-between">
        <h3 className="font-bold text-gray-900 dark:text-white">Search Messages</h3>
        <button onClick={onClose} className="p-1 rounded-full hover:bg-gray-100 dark:hover:bg-white/10">
          <X className="h-5 w-5 text-gray-500" />
        </button>
      </div>

      <div className="p-4">
        <div className="relative">
          <Search className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-gray-400" />
          <input 
            type="text" 
            value={query}
            onChange={handleSearch}
            placeholder="Search in conversation..." 
            className="w-full h-10 pl-10 pr-4 rounded-xl bg-gray-100 dark:bg-white/5 border-none text-sm focus:ring-2 focus:ring-blue-500/50 transition-all"
            autoFocus
          />
        </div>
      </div>

      <div className="flex-1 overflow-y-auto p-2">
        {query && results.length === 0 ? (
          <div className="p-8 text-center text-gray-500 dark:text-white/30">
            <p className="text-sm">No messages found for "{query}"</p>
          </div>
        ) : (
          <div className="space-y-1">
            {results.map(msg => (
              <button
                key={msg.id}
                onClick={() => onResultClick(msg)}
                className="w-full p-3 rounded-xl hover:bg-gray-100 dark:hover:bg-white/5 text-left transition-all group"
              >
                <div className="flex justify-between mb-1">
                  <span className="text-[10px] font-bold text-blue-500 uppercase">
                    {msg.timestamp.toLocaleDateString()}
                  </span>
                  <span className="text-[10px] text-gray-400">
                    {msg.timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}
                  </span>
                </div>
                <p className="text-sm text-gray-700 dark:text-white/70 line-clamp-2 group-hover:text-gray-900 dark:group-hover:text-white">
                  {msg.content}
                </p>
              </button>
            ))}
          </div>
        )}
      </div>
    </div>
  );
}



=== FILE: packages\ui\src\components\chat\OnlineIndicator.tsx ===

import React from 'react';
import { cn } from '../../utils/cn';

interface OnlineIndicatorProps extends React.HTMLAttributes<HTMLSpanElement> {
  status?: 'online' | 'offline' | 'away' | 'busy';
  size?: 'sm' | 'md' | 'lg';
}

export function OnlineIndicator({ status = 'offline', size = 'md', className, ...props }: OnlineIndicatorProps) {
  const colors = {
    online: "bg-green-500",
    offline: "bg-gray-400",
    away: "bg-amber-500",
    busy: "bg-red-500"
  };

  const sizes = {
    sm: "h-2 w-2",
    md: "h-3 w-3",
    lg: "h-4 w-4"
  };

  return (
    <span 
      className={cn(
        "rounded-full border-2 border-white dark:border-black shrink-0",
        colors[status],
        sizes[size],
        status === 'online' && "animate-pulse",
        className
      )} 
      {...props}
    />
  );
}



=== FILE: packages\ui\src\components\chat\ReadReceipt.tsx ===

import React from 'react';
import { cn } from '../../utils/cn';
import { Check, CheckCheck } from 'lucide-react';
import type { MessageStatus } from './types';

interface ReadReceiptProps extends React.HTMLAttributes<HTMLDivElement> {
  status: MessageStatus;
}

export function ReadReceipt({ status, className, ...props }: ReadReceiptProps) {
  if (status === 'sending') {
    return (
      <div className={cn("w-3 h-3 border border-current border-t-transparent rounded-full animate-spin opacity-50", className)} {...props} />
    );
  }

  if (status === 'failed') {
    return (
      <span className={cn("text-red-500 text-[10px] font-bold", className)} {...props}>!</span>
    );
  }

  return (
    <div className={cn("flex items-center", className)} {...props}>
      {status === 'sent' && <Check className="h-3 w-3 opacity-50" />}
      {status === 'delivered' && <CheckCheck className="h-3 w-3 opacity-50" />}
      {status === 'read' && <CheckCheck className="h-3 w-3 text-blue-500" />}
    </div>
  );
}



=== FILE: packages\ui\src\components\chat\ReplyPreview.tsx ===

import React from 'react';
import { cn } from '../../utils/cn';
import { X, Reply } from 'lucide-react';
import type { Message } from './types';

interface ReplyPreviewProps extends React.HTMLAttributes<HTMLDivElement> {
  message: Message;
  onCancel?: () => void;
}

export function ReplyPreview({ message, onCancel, className, ...props }: ReplyPreviewProps) {
  return (
    <div 
      className={cn(
        "flex items-center gap-3 p-2 rounded-xl bg-blue-500/5 border-l-4 border-blue-500 animate-in slide-in-from-bottom-2",
        className
      )} 
      {...props}
    >
      <div className="p-1.5 rounded-lg bg-blue-500/10 text-blue-500">
        <Reply className="h-4 w-4" />
      </div>
      <div className="flex-1 min-w-0">
        <p className="text-xs font-bold text-blue-500">Replying to</p>
        <p className="text-sm text-gray-600 dark:text-white/60 truncate">{message.content}</p>
      </div>
      {onCancel && (
        <button 
          onClick={onCancel}
          className="p-1 rounded-full hover:bg-gray-200 dark:hover:bg-white/10 text-gray-400 transition-colors"
        >
          <X className="h-4 w-4" />
        </button>
      )}
    </div>
  );
}



=== FILE: packages\ui\src\components\chat\StickyDateHeader.tsx ===

import React from 'react';
import { cn } from '../../utils/cn';
import { Calendar } from 'lucide-react';

interface StickyDateHeaderProps extends React.HTMLAttributes<HTMLDivElement> {
  date: string | Date;
  sticky?: boolean;
}

export function StickyDateHeader({ date, sticky = true, className, ...props }: StickyDateHeaderProps) {
  const formattedDate = typeof date === 'string' ? date : date.toLocaleDateString('pt-BR', { 
    day: 'numeric', 
    month: 'long', 
    year: 'numeric' 
  });

  return (
    <div 
      className={cn(
        "flex justify-center my-6 z-20",
        sticky && "sticky top-4",
        className
      )}
      {...props}
    >
      <div className="flex items-center gap-2 px-4 py-1.5 rounded-full bg-white/[0.05] border border-white/10 backdrop-blur-md shadow-lg">
        <Calendar size={12} className="text-white/40" />
        <span className="text-[11px] font-bold text-white/60 tracking-wider uppercase">
          {formattedDate}
        </span>
      </div>
    </div>
  );
}



=== FILE: packages\ui\src\components\chat\SystemMessage.tsx ===

import React from 'react';
import { cn } from '../../utils/cn';

interface SystemMessageProps extends React.HTMLAttributes<HTMLDivElement> {
  content: string;
}

export function SystemMessage({ content, className, ...props }: SystemMessageProps) {
  return (
    <div className={cn("flex justify-center py-2", className)} {...props}>
      <div className="px-4 py-1 rounded-lg bg-gray-100/50 dark:bg-white/[0.02] text-[11px] font-medium text-gray-500 dark:text-white/30 border border-gray-200/50 dark:border-white/5">
        {content}
      </div>
    </div>
  );
}



=== FILE: packages\ui\src\components\chat\types.ts ===

export type UserStatus = 'online' | 'offline' | 'away' | 'busy';
export type PresenceStatus = 'unavailable' | 'available' | 'composing' | 'recording' | 'paused';

export interface User {
  id: string;
  name: string;
  avatar?: string;
  status?: UserStatus;
  presence?: PresenceStatus;
  lastSeen?: Date;
  bio?: string;
  phone?: string;
  isOnline?: boolean;
  verified?: boolean;
  tags?: string[];
}

export type MessageType = 
  | 'text' 
  | 'image' 
  | 'file' 
  | 'system' 
  | 'audio' 
  | 'video' 
  | 'location' 
  | 'contact' 
  | 'poll' 
  | 'sticker'
  | 'template'
  | 'interactive'
  | 'reaction'
  | 'revoked';

export type MessageStatus = 'sending' | 'sent' | 'delivered' | 'read' | 'failed' | 'played';

export interface ChatAttachment {
  id: string;
  type: 'image' | 'file' | 'audio' | 'video' | 'sticker';
  url: string;
  name?: string;
  size?: string;
  duration?: number;
  thumbnail?: string;
  mimetype?: string;
  caption?: string;
  blurhash?: string;
}

export interface PollOption {
  id: string;
  text: string;
  votes: string[];
}

export interface InteractiveButton {
  id: string;
  text: string;
  type: 'reply' | 'url' | 'call';
  payload?: string;
  params?: any;
}

export interface InteractiveListSection {
  title?: string;
  rows: {
    id: string;
    title: string;
    description?: string;
  }[];
}

export interface InteractiveCard {
  header?: {
    type: 'image' | 'video';
    attachment: ChatAttachment;
  };
  body: string;
  footer?: string;
  buttons?: InteractiveButton[];
  nativeFlow?: {
    buttons: {
      name: string;
      buttonParamsJson: string;
    }[];
  };
}

export interface InteractiveContent {
  type: 'button' | 'list' | 'carousel';
  header?: {
    type: 'text' | 'image' | 'video' | 'document';
    text?: string;
    attachment?: ChatAttachment;
  };
  body: string;
  footer?: string;
  buttons?: InteractiveButton[];
  sections?: InteractiveListSection[];
  cards?: InteractiveCard[];
  nativeFlow?: {
    buttons: {
      name: string;
      buttonParamsJson: string;
    }[];
  };
}

export interface Message {
  id: string;
  remoteJid: string;
  content: string;
  senderId: string;
  timestamp: Date;
  status?: MessageStatus;
  type?: MessageType;
  attachments?: ChatAttachment[];
  replyToId?: string;
  replyTo?: Message;
  reactions?: Record<string, string[]>;
  location?: {
    latitude: number;
    longitude: number;
    address?: string;
    name?: string;
  };
  contact?: {
    name: string;
    phone: string;
    avatar?: string;
    vcard?: string;
  };
  poll?: {
    question: string;
    options: PollOption[];
    multipleChoice?: boolean;
    expiresAt?: Date;
  };
  interactive?: InteractiveContent;
  ephemeralExpiration?: number;
  isEdited?: boolean;
  isPinned?: boolean;
  isForwarded?: boolean;
  forwardingScore?: number;
  broadcast?: boolean;
  starred?: boolean;
  
  // CRM / AI Evolution
  agentName?: string;
  isInternalNote?: boolean;
}

export interface Conversation {
  id: string;
  user?: User;
  group?: GroupInfo;
  lastMessage?: Message;
  unreadCount: number;
  isTyping?: boolean;
  presence?: Record<string, PresenceStatus>;
  isMuted?: boolean;
  muteExpiration?: number;
  isPinned?: boolean;
  isArchived?: boolean;
  isReadOnly?: boolean;
  ephemeralExpiration?: number;
  labels?: string[];
  wallpaper?: string;
}

export interface GroupInfo {
  id: string;
  name: string;
  avatar?: string;
  description?: string;
  members: GroupMember[];
  admins: string[];
  createdBy: string;
  createdAt: Date;
  inviteCode?: string;
  restrict?: boolean;
  announce?: boolean;
}

export interface GroupMember extends User {
  role: 'admin' | 'member' | 'superadmin';
}

export interface ChatLabel {
  id: string;
  name: string;
  color: string;
  count?: number;
}



=== FILE: packages\ui\src\components\chat\TypingIndicator.tsx ===

import React from 'react';
import { cn } from '../../utils/cn';

interface TypingIndicatorProps extends React.HTMLAttributes<HTMLDivElement> {
  users?: string[];
  variant?: 'default' | 'bubble';
}

export function TypingIndicator({ users = [], variant = 'default', className, ...props }: TypingIndicatorProps) {
  const text = users.length === 0 
    ? 'Someone is typing' 
    : users.length === 1 
      ? `${users[0]} is typing` 
      : users.length === 2 
        ? `${users[0]} and ${users[1]} are typing`
        : `${users[0]} and ${users.length - 1} others are typing`;

  if (variant === 'bubble') {
    return (
      <div className={cn("flex items-center gap-1 px-3 py-2 rounded-2xl bg-gray-100 dark:bg-white/[0.03] w-fit", className)} {...props}>
        <div className="flex gap-1">
          <span className="w-1.5 h-1.5 rounded-full bg-gray-400 animate-bounce [animation-delay:-0.3s]" />
          <span className="w-1.5 h-1.5 rounded-full bg-gray-400 animate-bounce [animation-delay:-0.15s]" />
          <span className="w-1.5 h-1.5 rounded-full bg-gray-400 animate-bounce" />
        </div>
      </div>
    );
  }

  return (
    <div className={cn("flex items-center gap-2 text-xs text-gray-500 dark:text-white/40 italic", className)} {...props}>
      <div className="flex gap-0.5">
        <span className="w-1 h-1 rounded-full bg-current animate-bounce [animation-delay:-0.3s]" />
        <span className="w-1 h-1 rounded-full bg-current animate-bounce [animation-delay:-0.15s]" />
        <span className="w-1 h-1 rounded-full bg-current animate-bounce" />
      </div>
      {text}
    </div>
  );
}



=== FILE: packages\ui\src\components\chat\VirtualizedMessageList.tsx ===

import React, { useRef, useMemo } from 'react';
import { cn } from '../../utils/cn';
import type { Message } from './types';
import { MessageBubble } from './MessageBubble';
import { useVirtualList } from '../../hooks/useVirtualList';
import { StickyDateHeader } from './StickyDateHeader';

interface VirtualizedMessageListProps {
  messages: Message[];
  currentUserId: string;
  onReply?: (message: Message) => void;
  onImageClick?: (url: string) => void;
  className?: string;
  itemHeight?: number; // Estimated height
}

export function VirtualizedMessageList({ 
  messages, 
  currentUserId, 
  onReply,
  onImageClick,
  className,
  itemHeight = 80
}: VirtualizedMessageListProps) {
  const { 
    containerRef, 
    visibleItems, 
    totalHeight, 
    onScroll 
  } = useVirtualList({
    itemCount: messages.length,
    itemHeight: itemHeight,
    startAtBottom: true,
    overscan: 10
  });

  return (
    <div 
      ref={containerRef}
      onScroll={onScroll}
      className={cn("flex-1 overflow-y-auto relative no-scrollbar", className)}
    >
      <div 
        className="w-full relative"
        style={{ height: `${totalHeight}px` }}
      >
        {visibleItems.map(({ index, offsetTop, height }) => {
          const message = messages[index];
          if (!message) return null;

          // Check if we should show a date header
          const prevMessage = index > 0 ? messages[index - 1] : null;
          const showDate = !prevMessage || 
            new Date(prevMessage.timestamp).toDateString() !== new Date(message.timestamp).toDateString();

          return (
            <div 
              key={message.id}
              className="absolute left-0 w-full px-4"
              style={{ top: `${offsetTop}px`, height: `${height}px` }}
            >
              {showDate && (
                <StickyDateHeader 
                  date={message.timestamp} 
                  sticky={false} // In virtualized list, we handle sticky differently if needed
                />
              )}
              <MessageBubble 
                message={message}
                isOwn={message.senderId === currentUserId}
                onReply={() => onReply?.(message)}
                onImageClick={onImageClick}
              />
            </div>
          );
        })}
      </div>
    </div>
  );
}



=== FILE: packages\ui\src\components\chat\VoiceRecorder.tsx ===

import React, { useEffect } from 'react';
import { cn } from '../../utils/cn';
import { Mic, Square, Trash2, Send, X } from 'lucide-react';
import { useVoiceRecorder } from '../../hooks/useVoiceRecorder';
import { Button } from '../button/Button';

interface VoiceRecorderProps extends React.HTMLAttributes<HTMLDivElement> {
  onSend: (blob: Blob, duration: number) => void;
  onCancel: () => void;
}

export function VoiceRecorder({ onSend, onCancel, className, ...props }: VoiceRecorderProps) {
  const { 
    isRecording, 
    duration, 
    audioBlob, 
    startRecording, 
    stopRecording, 
    cancelRecording 
  } = useVoiceRecorder();

  useEffect(() => {
    startRecording();
    return () => cancelRecording();
  }, []);

  const formatTime = (s: number) => {
    const mins = Math.floor(s / 60);
    const secs = s % 60;
    return `${mins}:${secs.toString().padStart(2, '0')}`;
  };

  return (
    <div 
      className={cn(
        "flex items-center gap-3 p-2 rounded-2xl bg-gray-100 dark:bg-white/[0.03] border border-gray-200 dark:border-white/10 animate-in slide-in-from-bottom-2",
        className
      )} 
      {...props}
    >
      <div className="flex items-center gap-2 px-3 py-1.5 rounded-xl bg-red-500/10 text-red-500">
        <div className="w-2 h-2 rounded-full bg-red-500 animate-pulse" />
        <span className="text-sm font-mono font-bold">{formatTime(duration)}</span>
      </div>

      <div className="flex-1 h-8 flex items-center gap-0.5 px-2">
        {/* Simple Waveform Animation */}
        {[...Array(20)].map((_, i) => (
          <div 
            key={i} 
            className="w-1 bg-red-500/40 rounded-full transition-all duration-150"
            style={{ 
              height: isRecording ? `${20 + Math.random() * 80}%` : '20%',
              animationDelay: `${i * 0.05}s`
            }}
          />
        ))}
      </div>

      <div className="flex items-center gap-1">
        <button 
          onClick={() => { cancelRecording(); onCancel(); }}
          className="p-2 rounded-full hover:bg-gray-200 dark:hover:bg-white/10 text-gray-500 transition-colors"
        >
          <Trash2 className="h-5 w-5" />
        </button>
        
        {isRecording ? (
          <Button 
            size="icon" 
            variant="ghost"
            onClick={stopRecording}
            className="rounded-full bg-red-500 text-white hover:bg-red-600"
          >
            <Square className="h-4 w-4 fill-current" />
          </Button>
        ) : (
          <Button 
            size="icon" 
            onClick={() => audioBlob && onSend(audioBlob, duration)}
            className="rounded-full bg-blue-500 text-white hover:bg-blue-600"
          >
            <Send className="h-4 w-4" />
          </Button>
        )}
      </div>
    </div>
  );
}



=== FILE: packages\ui\src\components\chat\WaveformAudio.tsx ===

import React, { useState, useRef, useEffect, useMemo } from 'react';
import { cn } from '../../utils/cn';
import { Play, Pause, Smartphone } from 'lucide-react';

interface WaveformAudioProps extends React.HTMLAttributes<HTMLDivElement> {
  src: string;
  duration?: number;
  isMe?: boolean;
  bars?: number;
}

export function WaveformAudio({ src, duration, isMe, bars = 35, className, ...props }: WaveformAudioProps) {
  const [isPlaying, setIsPlaying] = useState(false);
  const [currentTime, setCurrentTime] = useState(0);
  const audioRef = useRef<HTMLAudioElement>(null);

  // Generate deterministic bar heights for a given src to maintain visual consistency
  const barHeights = useMemo(() => {
    const heights = [];
    const seed = src.length;
    for (let i = 0; i < bars; i++) {
      // Deterministic random between 20% and 100%
      const h = ((Math.sin(seed + i * 1.5) + 1) / 2) * 80 + 20;
      heights.push(Math.round(h));
    }
    return heights;
  }, [src, bars]);

  const togglePlay = () => {
    if (audioRef.current) {
      if (isPlaying) {
        audioRef.current.pause();
      } else {
        audioRef.current.play();
      }
      setIsPlaying(!isPlaying);
    }
  };

  const handleTimeUpdate = () => {
    if (audioRef.current) {
      setCurrentTime(audioRef.current.currentTime);
    }
  };

  const handleEnded = () => {
    setIsPlaying(false);
    setCurrentTime(0);
  };

  const formatTime = (time: number) => {
    const minutes = Math.floor(time / 60);
    const seconds = Math.floor(time % 60);
    return `${minutes}:${seconds.toString().padStart(2, '0')}`;
  };

  const progressPercentage = duration ? (currentTime / duration) : 0;
  const activeBars = Math.floor(progressPercentage * bars);

  return (
    <div 
      className={cn(
        "flex items-center gap-4 py-2 px-3 rounded-2xl min-w-[280px]",
        isMe ? "bg-white/10 text-white" : "bg-white/[0.03] text-white/90 border border-white/10",
        className
      )} 
      {...props}
    >
      <audio 
        ref={audioRef} 
        src={src} 
        onTimeUpdate={handleTimeUpdate} 
        onEnded={handleEnded}
      />
      
      <div className="relative shrink-0">
        <button 
          onClick={togglePlay}
          className={cn(
            "w-12 h-12 rounded-full flex items-center justify-center transition-all group active:scale-95",
            isMe ? "bg-white text-blue-600" : "bg-blue-500 text-white shadow-lg shadow-blue-500/20"
          )}
        >
          {isPlaying ? (
            <Pause className="h-6 w-6 fill-current" />
          ) : (
            <Play className="h-6 w-6 fill-current ml-1" />
          )}
        </button>
        {/* Playback rate indicator if needed could go here */}
      </div>

      <div className="flex-1 flex flex-col gap-1">
        <div className="flex items-end gap-[2px] h-8 w-full group cursor-pointer" 
             onClick={(e) => {
               if (!audioRef.current || !duration) return;
               const rect = e.currentTarget.getBoundingClientRect();
               const x = e.clientX - rect.left;
               const newTime = (x / rect.width) * duration;
               audioRef.current.currentTime = newTime;
               setCurrentTime(newTime);
             }}>
          {barHeights.map((h, i) => (
            <div 
              key={i}
              className={cn(
                "flex-1 rounded-full transition-all duration-300",
                i <= activeBars 
                  ? (isMe ? "bg-white" : "bg-blue-500") 
                  : (isMe ? "bg-white/30" : "bg-white/10")
              )}
              style={{ height: `${h}%` }}
            />
          ))}
        </div>
        
        <div className="flex justify-between items-center px-0.5">
          <span className="text-[10px] tabular-nums font-semibold opacity-60">
            {formatTime(currentTime)}
          </span>
          <div className="flex items-center gap-1.5 grayscale opacity-40">
            <span className="text-[10px] font-semibold">
              {duration ? formatTime(duration) : '--:--'}
            </span>
            <Smartphone size={10} />
          </div>
        </div>
      </div>
    </div>
  );
}



=== FILE: packages\ui\src\components\data-display\Accordion.tsx ===

import React, { createContext, useContext, useState } from 'react';
import { cn } from '../../utils/cn';
import { ChevronDown } from 'lucide-react';

interface AccordionContextValue {
  value: string | string[];
  onValueChange: (value: string) => void;
  type: 'single' | 'multiple';
}

const AccordionContext = createContext<AccordionContextValue | undefined>(undefined);

export interface AccordionProps extends React.HTMLAttributes<HTMLDivElement> {
  type?: 'single' | 'multiple';
  defaultValue?: string | string[];
  value?: string | string[];
  onValueChange?: (value: string | string[]) => void;
  children: React.ReactNode;
}

export function Accordion({
  type = 'single',
  defaultValue,
  value,
  onValueChange,
  className,
  children,
  ...props
}: AccordionProps) {
  const [internalValue, setInternalValue] = useState<string | string[]>(
    defaultValue || (type === 'multiple' ? [] : '')
  );

  const currentValue = value !== undefined ? value : internalValue;

  const handleValueChange = (itemValue: string) => {
    let newValue: string | string[];

    if (type === 'multiple') {
      const arrayValue = Array.isArray(currentValue) ? currentValue : [];
      if (arrayValue.includes(itemValue)) {
        newValue = arrayValue.filter((v) => v !== itemValue);
      } else {
        newValue = [...arrayValue, itemValue];
      }
    } else {
      newValue = currentValue === itemValue ? '' : itemValue;
    }

    if (value === undefined) {
      setInternalValue(newValue);
    }
    
    onValueChange?.(newValue as any);
  };

  return (
    <AccordionContext.Provider
      value={{ value: currentValue, onValueChange: handleValueChange, type }}
    >
      <div className={cn("space-y-2", className)} {...props}>
        {children}
      </div>
    </AccordionContext.Provider>
  );
}

// Helper context for Item
const AccordionItemContext = createContext<{ value: string; isOpen: boolean }>({ value: '', isOpen: false });

export interface AccordionItemProps extends React.HTMLAttributes<HTMLDivElement> {
  value: string;
  children: React.ReactNode;
}

export function AccordionItem({ className, value, children, ...props }: AccordionItemProps) {
  const context = useContext(AccordionContext);
  const isOpen = Array.isArray(context?.value)
    ? context?.value.includes(value)
    : context?.value === value;

  return (
    <AccordionItemContext.Provider value={{ value, isOpen: !!isOpen }}>
      <div
        className={cn(
          "overflow-hidden rounded-2xl border border-gray-200 dark:border-white/5 bg-gray-50 dark:bg-white/[0.03] transition-all duration-200",
          isOpen && "bg-white dark:bg-white/[0.04] border-gray-300 dark:border-white/10",
          className
        )}
        {...props}
      >
        {children}
      </div>
    </AccordionItemContext.Provider>
  );
}

export interface AccordionTriggerProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  children: React.ReactNode;
}

export function AccordionTrigger({ className, children, ...props }: AccordionTriggerProps) {
  const context = useContext(AccordionContext);
  const { value, isOpen } = useContext(AccordionItemContext);
  
  return (
    <button
      type="button"
      onClick={() => context?.onValueChange(value)}
      aria-expanded={isOpen}
      aria-controls={`accordion-content-${value}`}
      id={`accordion-trigger-${value}`}
      className={cn(
        "flex w-full items-center justify-between px-4 py-3 text-sm font-medium text-gray-900 dark:text-white transition-all hover:text-gray-700 dark:hover:text-white/90 focus:outline-none",
        className
      )}
      {...props}
    >
      {children}
      <ChevronDown
        className={cn(
          "h-4 w-4 shrink-0 text-gray-400 dark:text-white/50 transition-transform duration-200",
          isOpen && "rotate-180 text-gray-900 dark:text-white"
        )}
      />
    </button>
  );
}

export interface AccordionContentProps extends React.HTMLAttributes<HTMLDivElement> {
  children: React.ReactNode;
}

export function AccordionContent({ className, children, ...props }: AccordionContentProps) {
  const { isOpen, value } = useContext(AccordionItemContext);

  if (!isOpen) return null;

  return (
    <div
      id={`accordion-content-${value}`}
      role="region"
      aria-labelledby={`accordion-trigger-${value}`}
      className={cn(
        "px-4 pb-3 pt-0 text-sm text-gray-600 dark:text-white/70 animate-in slide-in-from-top-1 fade-in duration-200",
        className
      )}
      {...props}
    >
      {children}
    </div>
  );
}



=== FILE: packages\ui\src\components\data-display\Avatar.tsx ===

import React, { useState, useEffect } from 'react';
import { cn } from '../../utils/cn';

interface AvatarProps extends React.HTMLAttributes<HTMLDivElement> {
  src?: string;
  alt?: string;
  fallback?: React.ReactNode;
  size?: 'sm' | 'md' | 'lg' | 'xl';
}

const sizeClasses = {
  sm: 'h-8 w-8 text-xs',
  md: 'h-10 w-10 text-sm',
  lg: 'h-14 w-14 text-base',
  xl: 'h-20 w-20 text-xl',
};

export const Avatar = React.forwardRef<HTMLDivElement, AvatarProps>(
  ({ className, src, alt, fallback, size = 'md', ...props }, ref) => {
    const [imageError, setImageError] = useState(false);

    useEffect(() => {
      setImageError(false);
    }, [src]);

    return (
      <div
        ref={ref}
        className={cn(
          "relative flex shrink-0 overflow-hidden rounded-full bg-gray-200 dark:bg-white/[0.06]",
          sizeClasses[size],
          className
        )}
        {...props}
      >
        {src && !imageError ? (
          <img
            src={src}
            alt={alt}
            className="aspect-square h-full w-full object-cover"
            onError={() => setImageError(true)}
          />
        ) : (
          <div className="flex h-full w-full items-center justify-center bg-gray-100 dark:bg-white/5 text-gray-600 dark:text-white/70 font-medium">
            {fallback || (alt ? alt.charAt(0).toUpperCase() : '?')}
          </div>
        )}
      </div>
    );
  }
);

Avatar.displayName = 'Avatar';



=== FILE: packages\ui\src\components\data-display\Calendar.tsx ===

import React, { useState } from 'react';
import { cn } from '../../utils/cn';
import { ChevronLeft, ChevronRight } from 'lucide-react';

export interface CalendarProps {
  className?: string;
  value?: Date;
  onChange?: (date: Date) => void;
  minDate?: Date;
  maxDate?: Date;
}

const DAYS = ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'];
const MONTHS = [
  'January', 'February', 'March', 'April', 'May', 'June',
  'July', 'August', 'September', 'October', 'November', 'December'
];

export function Calendar({ className, value, onChange, minDate, maxDate }: CalendarProps) {
  const [currentDate, setCurrentDate] = useState(value || new Date());
  const [viewDate, setViewDate] = useState(value || new Date());

  const getDaysInMonth = (year: number, month: number) => {
    return new Date(year, month + 1, 0).getDate();
  };

  const getFirstDayOfMonth = (year: number, month: number) => {
    return new Date(year, month, 1).getDay();
  };

  const handlePrevMonth = () => {
    setViewDate(new Date(viewDate.getFullYear(), viewDate.getMonth() - 1, 1));
  };

  const handleNextMonth = () => {
    setViewDate(new Date(viewDate.getFullYear(), viewDate.getMonth() + 1, 1));
  };

  const handleDateClick = (day: number) => {
    const newDate = new Date(viewDate.getFullYear(), viewDate.getMonth(), day);
    if (onChange) {
      onChange(newDate);
    }
    setCurrentDate(newDate);
  };

  const isSelected = (day: number) => {
    return value && 
      value.getDate() === day &&
      value.getMonth() === viewDate.getMonth() &&
      value.getFullYear() === viewDate.getFullYear();
  };

  const isToday = (day: number) => {
    const today = new Date();
    return today.getDate() === day &&
      today.getMonth() === viewDate.getMonth() &&
      today.getFullYear() === viewDate.getFullYear();
  };

  const renderDays = () => {
    const daysInMonth = getDaysInMonth(viewDate.getFullYear(), viewDate.getMonth());
    const firstDay = getFirstDayOfMonth(viewDate.getFullYear(), viewDate.getMonth());
    const days = [];

    // Empty cells for previous month
    for (let i = 0; i < firstDay; i++) {
      days.push(<div key={`empty-${i}`} className="h-9 w-9" />);
    }

    // Days of current month
    for (let day = 1; day <= daysInMonth; day++) {
      const selected = isSelected(day);
      const today = isToday(day);
      
      days.push(
        <button
          key={day}
          onClick={() => handleDateClick(day)}
          type="button"
          className={cn(
            "h-9 w-9 rounded-2xl text-sm font-medium transition-all duration-200",
            "hover:bg-gray-100 dark:hover:bg-white/[0.06] focus:outline-none focus:ring-2 focus:ring-gray-400 dark:focus:ring-white/20",
            selected && "bg-gray-900 text-white dark:bg-white dark:text-black shadow-md dark:shadow-[0_0_15px_rgba(255,255,255,0.3)] hover:bg-gray-800 dark:hover:bg-white/90",
            !selected && today && "bg-gray-100 dark:bg-white/[0.03] text-gray-900 dark:text-white border border-gray-200 dark:border-white/10",
            !selected && !today && "text-gray-700 dark:text-white/70 hover:text-gray-900 dark:hover:text-white"
          )}
        >
          {day}
        </button>
      );
    }

    return days;
  };

  return (
    <div className={cn("p-4 bg-white dark:bg-black/40 backdrop-blur-xl border border-gray-200 dark:border-white/10 rounded-2xl w-fit", className)}>
      <div className="flex items-center justify-between mb-4 px-1">
        <div className="font-semibold text-gray-900 dark:text-white">
          {MONTHS[viewDate.getMonth()]} <span className="text-gray-500 dark:text-white/50">{viewDate.getFullYear()}</span>
        </div>
        <div className="flex gap-1">
          <button
            onClick={handlePrevMonth}
            type="button"
            className="p-1.5 rounded-lg hover:bg-gray-100 dark:hover:bg-white/[0.06] text-gray-600 dark:text-white/70 hover:text-gray-900 dark:hover:text-white transition-colors"
          >
            <ChevronLeft className="h-4 w-4" />
          </button>
          <button
            onClick={handleNextMonth}
            type="button"
            className="p-1.5 rounded-lg hover:bg-gray-100 dark:hover:bg-white/[0.06] text-gray-600 dark:text-white/70 hover:text-gray-900 dark:hover:text-white transition-colors"
          >
            <ChevronRight className="h-4 w-4" />
          </button>
        </div>
      </div>
      
      <div className="grid grid-cols-7 gap-1 mb-2 text-center">
        {DAYS.map(day => (
          <div key={day} className="h-9 w-9 flex items-center justify-center text-xs font-medium text-gray-400 dark:text-white/40">
            {day}
          </div>
        ))}
      </div>
      
      <div className="grid grid-cols-7 gap-1">
        {renderDays()}
      </div>
    </div>
  );
}



=== FILE: packages\ui\src\components\data-display\chart\AreaChart.tsx ===

import React from 'react';
import type { ChartDataPoint } from './Chart';
import { useChart, normalize } from './Chart';
import { cn } from '../../../utils/cn';

export interface AreaChartProps<T = any> {
  color?: 'cyan' | 'purple' | 'emerald' | 'amber' | 'rose';
  showValues?: boolean;
  animationDelay?: number;
  onValueClick?: (data: ChartDataPoint<T>) => void;
}

export function AreaChart<T = any>({ 
  color = 'purple', 
  showValues = false, 
  animationDelay = 0,
  onValueClick 
}: AreaChartProps<T>) {
  const { width, height, padding, data, maxValue, setHoveredIndex, hoveredIndex } = useChart<T>();
  
  if (!data || data.length === 0) return null;

  const chartWidth = width - padding.left - padding.right;
  const chartHeight = height - padding.top - padding.bottom;
  const itemWidth = data.length > 1 ? chartWidth / (data.length - 1) : chartWidth; 

  const colors = {
    cyan: { stroke: '#06b6d4', fill: 'rgba(6, 182, 212, 0.2)' },
    purple: { stroke: '#8b5cf6', fill: 'rgba(139, 92, 246, 0.2)' },
    emerald: { stroke: '#10b981', fill: 'rgba(16, 185, 129, 0.2)' },
    amber: { stroke: '#f59e0b', fill: 'rgba(245, 158, 11, 0.2)' },
    rose: { stroke: '#f43f5e', fill: 'rgba(244, 63, 94, 0.2)' },
  };

  const theme = colors[color];

  // Generate Path Data
  const points = data.map((point, i) => {
    const x = padding.left + itemWidth * i;
    const y = height - padding.bottom - normalize(point.value, maxValue, chartHeight);
    return { x, y, item: point };
  });

  // Simple Line Path
  const linePath = points.map((p, i) => (i === 0 ? `M ${p.x} ${p.y}` : `L ${p.x} ${p.y}`)).join(' ');

  // Area Path (closes the loop)
  const areaPath = `
    ${linePath}
    L ${width - padding.right} ${height - padding.bottom}
    L ${padding.left} ${height - padding.bottom}
    Z
  `;

  return (
    <g>
      {/* Area Fill */}
      <path
        d={areaPath}
        fill={theme.fill}
        style={{ 
            opacity: 0,
            animation: `fade-in 1s ease-out ${animationDelay}s forwards` 
        }}
      />

      {/* Stroke Line */}
      <path
        d={linePath}
        fill="none"
        stroke={theme.stroke}
        strokeWidth={3}
        strokeLinecap="round"
        strokeLinejoin="round"
        style={{
            strokeDasharray: 2000,
            strokeDashoffset: 2000,
            animation: `draw-line 2s ease-out ${animationDelay}s forwards`
        }}
      />

      {/* Interactive Points */}
      {points.map((p, i) => (
        <g 
            key={i} 
            onMouseEnter={() => setHoveredIndex(i)}
            onMouseLeave={() => setHoveredIndex(null)}
            onClick={() => onValueClick?.(p.item)}
            className={cn("cursor-crosshair", onValueClick && "cursor-pointer")}
        >
            {/* Invisible Hit Area */}
            <rect 
                x={p.x - itemWidth / 2} 
                y={padding.top} 
                width={itemWidth} 
                height={chartHeight} 
                fill="transparent" 
            />
            
            {/* Active Point Indicator */}
            {(hoveredIndex === i || showValues) && (
                <>
                    {hoveredIndex === i && (
                      <line
                          x1={p.x}
                          y1={padding.top}
                          x2={p.x}
                          y2={height - padding.bottom}
                          stroke="white"
                          strokeWidth={1}
                          strokeDasharray="4 4"
                          className="opacity-50"
                      />
                    )}
                    <circle
                        cx={p.x}
                        cy={p.y}
                        r={hoveredIndex === i ? 6 : 4}
                        fill={theme.stroke}
                        stroke="white"
                        strokeWidth={2}
                        style={{
                            transition: 'r 0.2s ease-out'
                        }}
                    />
                    {showValues && (
                      <text
                          x={p.x}
                          y={p.y - 12}
                          textAnchor="middle"
                          fill="white"
                          fontSize={12}
                          fontWeight={500}
                          style={{ 
                              opacity: 0,
                              animation: `fade-in-up 0.5s ease-out ${animationDelay + 1 + i * 0.1}s forwards`,
                              textShadow: '0 2px 4px rgba(0,0,0,0.5)'
                          }}
                      >
                          {data[i]?.value}
                      </text>
                    )}
                </>
            )}
        </g>
      ))}

      <style>{`
        @keyframes draw-line {
          to { stroke-dashoffset: 0; }
        }
        @keyframes fade-in {
          from { opacity: 0; }
          to { opacity: 1; }
        }
        @keyframes fade-in-up {
          from { opacity: 0; transform: translateY(10px); }
          to { opacity: 1; transform: translateY(0); }
        }
      `}</style>
    </g>
  );
}



=== FILE: packages\ui\src\components\data-display\chart\BarChart.tsx ===

import React from 'react';
import type { ChartDataPoint } from './Chart';
import { useChart, normalize } from './Chart';
import { cn } from '../../../utils/cn';

export interface BarChartProps<T = any> {
  color?: 'cyan' | 'purple' | 'emerald' | 'amber' | 'rose';
  showValues?: boolean;
  animationDelay?: number;
  onValueClick?: (data: ChartDataPoint<T>) => void;
}

export function BarChart<T = any>({ 
  color = 'cyan', 
  showValues = false, 
  animationDelay = 0,
  onValueClick 
}: BarChartProps<T>) {
  const { width, height, padding, data, maxValue, setHoveredIndex, hoveredIndex } = useChart<T>();

  if (!data || data.length === 0) return null;

  const chartWidth = width - padding.left - padding.right;
  const chartHeight = height - padding.top - padding.bottom;
  const itemWidth = chartWidth / data.length;
  const barWidth = itemWidth * 0.6; // 60% of slot width

  const colors = {
    cyan: 'from-cyan-500 to-blue-600',
    purple: 'from-purple-500 to-indigo-600',
    emerald: 'from-emerald-500 to-teal-600',
    amber: 'from-amber-400 to-orange-600',
    rose: 'from-rose-500 to-pink-600',
  };

  return (
    <g>
      {data.map((point, i) => {
        const barHeight = normalize(point.value, maxValue, chartHeight);
        const x = padding.left + itemWidth * i + (itemWidth - barWidth) / 2;
        const y = height - padding.bottom - barHeight;
        const isHovered = hoveredIndex === i;
        const delay = i * 0.1 + animationDelay; // Slower stagger for smoothness

        return (
          <g 
            key={i} 
            onMouseEnter={() => setHoveredIndex(i)}
            onMouseLeave={() => setHoveredIndex(null)}
            onClick={() => onValueClick?.(point)}
            className={cn("cursor-pointer", onValueClick && "cursor-pointer")}
          >
            {/* Invisible hit area for easier hovering */}
            <rect
              x={padding.left + itemWidth * i}
              y={padding.top}
              width={itemWidth}
              height={chartHeight}
              fill="transparent"
            />
            
            {/* The Bar */}
            <rect
              x={x}
              y={y}
              width={barWidth}
              height={barHeight}
              rx={4}
              className={cn(
                "transition-all duration-300 ease-out",
                isHovered ? "brightness-125 filter" : "opacity-80"
              )}
              style={{
                transformOrigin: `center ${height - padding.bottom}px`,
                animation: `grow-up 0.8s cubic-bezier(0.16, 1, 0.3, 1) ${delay}s backwards`
              }}
            >
               {/* Gradient Definition would be better in defs, but inline style works for dynamic colors if needed. 
                   Here we use classes for gradients. */}
            </rect>
            
            {/* Gradient Overlay via Class */}
            <rect
               x={x}
               y={y}
               width={barWidth}
               height={barHeight}
               rx={4}
               className={cn("bg-gradient-to-b", colors[color])}
               style={{
                pointerEvents: 'none',
                transformOrigin: `center ${height - padding.bottom}px`,
                animation: `grow-up 0.8s cubic-bezier(0.16, 1, 0.3, 1) ${delay}s backwards`
               }}
            />

            {/* Value Label */}
            {showValues && (
              <text
                x={x + barWidth / 2}
                y={y - 8}
                textAnchor="middle"
                fill="white"
                fontSize={12}
                fontWeight={500}
                style={{ 
                  opacity: 0,
                  animation: `fade-in-up 0.5s ease-out ${delay + 0.4}s forwards`,
                  textShadow: '0 2px 4px rgba(0,0,0,0.5)'
                }}
              >
                {point.value}
              </text>
            )}
          </g>
        );
      })}
      <style>{`
        @keyframes grow-up {
          from { transform: scaleY(0); }
          to { transform: scaleY(1); }
        }
        @keyframes fade-in-up {
          from { opacity: 0; transform: translateY(10px); }
          to { opacity: 1; transform: translateY(0); }
        }
      `}</style>
    </g>
  );
}



=== FILE: packages\ui\src\components\data-display\chart\Chart.tsx ===

import React, { createContext, useContext, useState, useMemo } from 'react';
import { cn } from '../../../utils/cn';

// --- Types ---
export type ChartDataPoint<T = Record<string, any>> = {
  label: string;
  value: number;
} & T;

export interface ChartContextValue<T = any> {
  width: number;
  height: number;
  data: ChartDataPoint<T>[];
  maxValue: number;
  padding: { top: number; right: number; bottom: number; left: number };
  hoveredIndex: number | null;
  setHoveredIndex: (index: number | null) => void;
}

// --- Context ---
const ChartContext = createContext<ChartContextValue<any> | undefined>(undefined);

export function useChart<T = any>() {
  const context = useContext(ChartContext);
  if (!context) throw new Error('Chart components must be used within a ChartContainer');
  return context as ChartContextValue<T>;
}

// --- Utils ---
export function normalize(value: number, max: number, height: number) {
  if (max === 0) return 0;
  return (value / max) * height;
}

// --- Components ---

export interface ChartContainerProps<T = any> extends React.HTMLAttributes<HTMLDivElement> {
  data: ChartDataPoint<T>[];
  height?: number;
  padding?: { top: number; right: number; bottom: number; left: number };
  children: React.ReactNode;
}

export function ChartContainer<T = any>({
  data,
  height = 300,
  padding = { top: 20, right: 20, bottom: 40, left: 40 },
  className,
  children,
  ...props
}: ChartContainerProps<T>) {
  const [hoveredIndex, setHoveredIndex] = useState<number | null>(null);
  const [containerWidth, setContainerWidth] = useState(0);
  const containerRef = React.useRef<HTMLDivElement>(null);

  // Responsive width
  React.useEffect(() => {
    if (!containerRef.current) return;
    const observer = new ResizeObserver((entries) => {
      if (entries[0]) {
        setContainerWidth(entries[0].contentRect.width);
      }
    });
    observer.observe(containerRef.current);
    return () => observer.disconnect();
  }, []);

  const maxValue = useMemo(() => {
    if (!data || data.length === 0) return 1;
    const max = Math.max(...data.map((d) => d.value));
    return max === 0 ? 1 : max * 1.1; // Add 10% headroom, min 1
  }, [data]);

  return (
    <ChartContext.Provider
      value={{
        width: containerWidth,
        height,
        data,
        maxValue,
        padding,
        hoveredIndex,
        setHoveredIndex,
      }}
    >
      <div
        ref={containerRef}
        className={cn("relative w-full select-none", className)}
        style={{ height }}
        {...props}
      >
        {containerWidth > 0 && (
          <svg
            width="100%"
            height="100%"
            viewBox={`0 0 ${containerWidth} ${height}`}
            className="overflow-visible"
          >
            {children}
          </svg>
        )}
      </div>
    </ChartContext.Provider>
  );
}

export function ChartGrid({ lines = 5 }: { lines?: number }) {
  const { width, height, padding } = useChart();
  const chartHeight = height - padding.top - padding.bottom;

  return (
    <g className="text-gray-200 dark:text-white/5">
      {Array.from({ length: lines + 1 }).map((_, i) => {
        const y = padding.top + (chartHeight / lines) * i;
        return (
          <line
            key={i}
            x1={padding.left}
            y1={y}
            x2={width - padding.right}
            y2={y}
            stroke="currentColor"
            strokeWidth={1}
            strokeDasharray="4 4"
          />
        );
      })}
    </g>
  );
}

export function ChartXAxis() {
  const { width, height, padding, data } = useChart();
  const chartWidth = width - padding.left - padding.right;
  const itemWidth = chartWidth / data.length;

  return (
    <g>
      {data.map((point, i) => {
        const x = padding.left + itemWidth * i + itemWidth / 2;
        const y = height - padding.bottom + 20;
        return (
          <text
            key={i}
            x={x}
            y={y}
            textAnchor="middle"
            className="fill-gray-400 dark:fill-white/40 text-xs font-medium"
          >
            {point.label}
          </text>
        );
      })}
    </g>
  );
}

export function ChartTooltip({ 
  renderTooltip 
}: { 
  renderTooltip?: (data: ChartDataPoint) => React.ReactNode 
}) {
  const { hoveredIndex, data, width, padding } = useChart();
  
  if (hoveredIndex === null) return null;

  const chartWidth = width - padding.left - padding.right;
  const itemWidth = chartWidth / data.length;
  const x = padding.left + itemWidth * hoveredIndex + itemWidth / 2;
  const point = data[hoveredIndex];

  if (!point) return null;

  // Simple default tooltip if none provided
  const content = renderTooltip ? renderTooltip(point) : (
    <div className="rounded-xl border border-gray-200 dark:border-white/10 bg-white/90 dark:bg-black/80 px-3 py-2 text-xs shadow-xl backdrop-blur-md">
      <div className="font-semibold text-gray-900 dark:text-white">{point.label}</div>
      <div className="text-gray-500 dark:text-white/70">Value: {point.value}</div>
    </div>
  );

  return (
    <foreignObject
      x={x - 75} // Center roughly (150px width assumed)
      y={0}
      width={150}
      height="100%"
      className="pointer-events-none overflow-visible"
    >
      <div className="flex h-full flex-col justify-center items-center">
         <div className="animate-in fade-in zoom-in-95 duration-200">
            {content}
         </div>
      </div>
    </foreignObject>
  );
}

export function ChartSkeleton() {
  return (
    <div className="w-full h-full flex items-end justify-between gap-2 p-4 animate-pulse bg-gray-100 dark:bg-white/[0.02] rounded-2xl border border-gray-200 dark:border-white/5">
      {[...Array(12)].map((_, i) => (
        <div 
          key={i} 
          className="w-full bg-gray-200 dark:bg-white/[0.03] rounded-t-lg" 
          style={{ height: `${Math.random() * 60 + 20}%` }}
        />
      ))}
    </div>
  );
}



=== FILE: packages\ui\src\components\data-display\chart\LineChart.tsx ===

import React from 'react';
import type { ChartDataPoint } from './Chart';
import { useChart, normalize } from './Chart';
import { cn } from '../../../utils/cn';

export interface LineChartProps<T = any> {
  color?: 'cyan' | 'purple' | 'emerald' | 'amber' | 'rose';
  showValues?: boolean;
  animationDelay?: number;
  curve?: 'linear' | 'smooth' | 'step';
  strokeWidth?: number;
  align?: 'center' | 'edge';
  onValueClick?: (data: ChartDataPoint<T>) => void;
}

export function LineChart<T = any>({ 
  color = 'cyan', 
  showValues = false, 
  animationDelay = 0,
  curve = 'smooth',
  strokeWidth = 3,
  align = 'edge',
  onValueClick 
}: LineChartProps<T>) {
  const { width, height, padding, data, maxValue, setHoveredIndex, hoveredIndex } = useChart<T>();

  if (!data || data.length === 0) return null;

  const chartWidth = width - padding.left - padding.right;
  const chartHeight = height - padding.top - padding.bottom;
  
  // Align 'center' matches BarChart (bands), 'edge' matches AreaChart (points)
  const itemWidth = align === 'center' 
    ? chartWidth / data.length 
    : (data.length > 1 ? chartWidth / (data.length - 1) : chartWidth);

  const colors = {
    cyan: '#06b6d4',
    purple: '#8b5cf6',
    emerald: '#10b981',
    amber: '#f59e0b',
    rose: '#f43f5e',
  };

  const strokeColor = colors[color];

  // Generate Points
  const points = data.map((point, i) => {
    let x;
    if (align === 'center') {
      // Center of the band
      x = padding.left + itemWidth * i + itemWidth / 2;
    } else {
      // Edge
      x = padding.left + itemWidth * i;
    }
    
    const y = height - padding.bottom - normalize(point.value, maxValue, chartHeight);
    return { x, y, item: point };
  });

  // Generate Path Command
  let d = '';
  if (points.length > 0) {
    d = `M ${points[0]!.x} ${points[0]!.y}`;
    
    if (curve === 'smooth') {
      // Simple Catmull-Rom or Bezier approximation could go here, 
      // but for now let's use a simple cubic bezier strategy or just straight lines if complex.
      // Actually, let's do a simple smoothing by using midpoints for control points if requested,
      // or just standard SVG commands.
      // For simplicity and robustness without a library like d3-shape, let's stick to linear or a basic smooth approximation.
      
      // Basic smooth strategy: Cubic Bezier between points
      for (let i = 0; i < points.length - 1; i++) {
        const p0 = points[i]!;
        const p1 = points[i + 1]!;
        const cp1x = p0.x + (p1.x - p0.x) / 2;
        const cp1y = p0.y;
        const cp2x = p0.x + (p1.x - p0.x) / 2;
        const cp2y = p1.y;
        d += ` C ${cp1x} ${cp1y}, ${cp2x} ${cp2y}, ${p1.x} ${p1.y}`;
      }
    } else if (curve === 'step') {
      for (let i = 0; i < points.length - 1; i++) {
        const p0 = points[i]!;
        const p1 = points[i + 1]!;
        d += ` L ${p1.x} ${p0.y} L ${p1.x} ${p1.y}`;
      }
    } else {
      // Linear
      for (let i = 1; i < points.length; i++) {
        d += ` L ${points[i]!.x} ${points[i]!.y}`;
      }
    }
  }

  return (
    <g>
      {/* The Line */}
      <path
        d={d}
        fill="none"
        stroke={strokeColor}
        strokeWidth={strokeWidth}
        strokeLinecap="round"
        strokeLinejoin="round"
        style={{
            strokeDasharray: 3000,
            strokeDashoffset: 3000,
            animation: `draw-line 2.5s ease-out ${animationDelay}s forwards`
        }}
      />

      {/* Interactive Points */}
      {points.map((p, i) => (
        <g 
            key={i} 
            onMouseEnter={() => setHoveredIndex(i)}
            onMouseLeave={() => setHoveredIndex(null)}
            onClick={() => onValueClick?.(p.item)}
            className={cn("cursor-crosshair", onValueClick && "cursor-pointer")}
        >
            {/* Invisible Hit Area */}
            <rect 
                x={p.x - itemWidth / 2} 
                y={padding.top} 
                width={itemWidth} 
                height={chartHeight} 
                fill="transparent" 
            />
            
            {/* Active Point Indicator */}
            {(hoveredIndex === i || showValues) && (
                <>
                    {hoveredIndex === i && (
                      <line
                          x1={p.x}
                          y1={padding.top}
                          x2={p.x}
                          y2={height - padding.bottom}
                          stroke="white"
                          strokeWidth={1}
                          strokeDasharray="4 4"
                          className="opacity-50"
                      />
                    )}
                    <circle
                        cx={p.x}
                        cy={p.y}
                        r={hoveredIndex === i ? 6 : 4}
                        fill={strokeColor}
                        stroke="white"
                        strokeWidth={2}
                        style={{ transition: 'r 0.2s ease-out' }}
                    />
                    {showValues && (
                      <text
                          x={p.x}
                          y={p.y - 12}
                          textAnchor="middle"
                          fill="white"
                          fontSize={12}
                          fontWeight={500}
                          style={{ 
                              opacity: 0,
                              animation: `fade-in-up 0.5s ease-out ${animationDelay + 1 + i * 0.1}s forwards`,
                              textShadow: '0 2px 4px rgba(0,0,0,0.5)'
                          }}
                      >
                          {data[i]?.value}
                      </text>
                    )}
                </>
            )}
        </g>
      ))}

      <style>{`
        @keyframes draw-line {
          to { stroke-dashoffset: 0; }
        }
        @keyframes fade-in-up {
          from { opacity: 0; transform: translateY(10px); }
          to { opacity: 1; transform: translateY(0); }
        }
      `}</style>
    </g>
  );
}



=== FILE: packages\ui\src\components\data-display\chart\PieChart.tsx ===

import React, { useMemo } from 'react';
import type { ChartDataPoint } from './Chart';
import { useChart } from './Chart';
import { cn } from '../../../utils/cn';

export interface PieChartProps<T = any> {
  innerRadius?: number; // 0 for Pie, >0 for Donut (0-1 relative to radius, or absolute pixels?) Let's say 0-1 relative.
  padAngle?: number;
  showLabels?: boolean;
  colors?: string[];
  onValueClick?: (data: ChartDataPoint<T>) => void;
}

export function PieChart<T = any>({ 
  innerRadius = 0, 
  padAngle = 0.02, 
  showLabels = false,
  colors = ['#06b6d4', '#8b5cf6', '#10b981', '#f59e0b', '#f43f5e', '#3b82f6', '#ec4899'],
  onValueClick
}: PieChartProps<T>) {
  const { width, height, data, setHoveredIndex, hoveredIndex } = useChart<T>();
  
  const radius = Math.min(width, height) / 2 * 0.8; // 80% of half-size to leave room for labels/hover
  const centerX = width / 2;
  const centerY = height / 2;
  
  const total = useMemo(() => data.reduce((acc, cur) => acc + cur.value, 0), [data]);
  
  let currentAngle = 0;
  
  const slices = data.map((point, i) => {
    const percentage = point.value / total;
    const angle = percentage * 2 * Math.PI;
    
    const startAngle = currentAngle;
    const endAngle = currentAngle + angle;
    
    currentAngle += angle;
    
    return {
      ...point,
      startAngle,
      endAngle,
      color: colors[i % colors.length],
      percentage
    };
  });

  // Helper to get coordinates
  const getCoordinatesForPercent = (percent: number, r: number) => {
    const x = centerX + r * Math.cos(percent);
    const y = centerY + r * Math.sin(percent);
    return [x, y];
  };

  return (
    <g>
      {slices.map((slice, i) => {
        // Calculate path
        // We need to handle the gap (padAngle) if multiple slices
        const effectiveStartAngle = slice.startAngle + (slices.length > 1 ? padAngle / 2 : 0);
        const effectiveEndAngle = slice.endAngle - (slices.length > 1 ? padAngle / 2 : 0);
        
        // If the slice is too small due to padding, just skip or render a line? 
        // For simplicity, let's just clamp.
        if (effectiveEndAngle <= effectiveStartAngle) return null;

        const [startX, startY] = getCoordinatesForPercent(effectiveStartAngle, radius);
        const [endX, endY] = getCoordinatesForPercent(effectiveEndAngle, radius);
        
        const largeArcFlag = effectiveEndAngle - effectiveStartAngle > Math.PI ? 1 : 0;
        
        // Inner radius (for donut)
        const rInner = radius * innerRadius;
        const [innerStartX, innerStartY] = getCoordinatesForPercent(effectiveEndAngle, rInner);
        const [innerEndX, innerEndY] = getCoordinatesForPercent(effectiveStartAngle, rInner);

        const pathData = [
          `M ${startX} ${startY}`,
          `A ${radius} ${radius} 0 ${largeArcFlag} 1 ${endX} ${endY}`,
          innerRadius > 0 ? `L ${innerStartX} ${innerStartY}` : `L ${centerX} ${centerY}`,
          innerRadius > 0 ? `A ${rInner} ${rInner} 0 ${largeArcFlag} 0 ${innerEndX} ${innerEndY}` : '',
          'Z'
        ].join(' ');

        const isHovered = hoveredIndex === i;
        
        // Label position (centroid)
        const midAngle = (slice.startAngle + slice.endAngle) / 2;
        const labelRadius = radius * (innerRadius > 0 ? (1 + innerRadius) / 2 : 0.7);
        const [labelX, labelY] = getCoordinatesForPercent(midAngle, labelRadius);

        return (
          <g 
            key={i}
            onMouseEnter={() => setHoveredIndex(i)}
            onMouseLeave={() => setHoveredIndex(null)}
            className="cursor-pointer"
          >
            <path
              d={pathData}
              fill={slice.color}
              className={cn(
                "transition-all duration-300 ease-out",
                isHovered ? "opacity-100 brightness-110" : "opacity-90"
              )}
              style={{
                transformOrigin: `${centerX}px ${centerY}px`,
                transform: isHovered ? 'scale(1.05)' : 'scale(1)',
                animation: `pie-enter 0.6s ease-out ${i * 0.05}s backwards`
              }}
            />
            
            {(showLabels || isHovered) && (
              <text
                x={labelX}
                y={labelY}
                textAnchor="middle"
                dominantBaseline="middle"
                fill="white"
                fontSize={12}
                fontWeight={600}
                className="pointer-events-none"
                style={{ textShadow: '0 1px 2px rgba(0,0,0,0.5)' }}
              >
                {Math.round(slice.percentage * 100)}%
              </text>
            )}
          </g>
        );
      })}
      <style>{`
        @keyframes pie-enter {
          from { opacity: 0; transform: scale(0.8) rotate(-10deg); }
          to { opacity: 0.9; transform: scale(1) rotate(0); }
        }
      `}</style>
    </g>
  );
}



=== FILE: packages\ui\src\components\data-display\chart\RadarChart.tsx ===

import React, { useMemo, useState } from 'react';
import { cn } from '../../../utils/cn';

export type RadarDataPoint<T = Record<string, any>> = {
  subject: string;
} & T;

export interface RadarChartProps<T = any> extends React.HTMLAttributes<HTMLDivElement> {
  data: RadarDataPoint<T>[];
  keys: (keyof T)[]; // Keys to plot (e.g. ['A', 'B'])
  colors?: string[]; // Colors for each key
  maxValue?: number;
  height?: number;
}

export function RadarChart<T = any>({
  data,
  keys,
  colors = ['cyan', 'purple', 'emerald'],
  maxValue: userMaxValue,
  height = 300,
  className,
  ...props
}: RadarChartProps<T>) {
  const [containerWidth, setContainerWidth] = useState(0);
  const containerRef = React.useRef<HTMLDivElement>(null);

  // Responsive width
  React.useEffect(() => {
    if (!containerRef.current) return;
    const observer = new ResizeObserver((entries) => {
      if (entries[0]) {
        setContainerWidth(entries[0].contentRect.width);
      }
    });
    observer.observe(containerRef.current);
    return () => observer.disconnect();
  }, []);

  const center = { x: containerWidth / 2, y: height / 2 };
  const radius = Math.min(containerWidth, height) / 2 - 40; // 40px padding

  const maxValue = useMemo(() => {
    if (userMaxValue) return userMaxValue;
    let max = 0;
    data.forEach(d => {
      keys.forEach(k => {
        const val = Number(d[k]) || 0;
        if (val > max) max = val;
      });
    });
    return max * 1.1 || 100;
  }, [data, keys, userMaxValue]);

  const angleSlice = (Math.PI * 2) / data.length;

  const colorMap: Record<string, string> = {
    cyan: 'rgba(6, 182, 212, 0.5)',
    purple: 'rgba(139, 92, 246, 0.5)',
    emerald: 'rgba(16, 185, 129, 0.5)',
    amber: 'rgba(245, 158, 11, 0.5)',
    rose: 'rgba(244, 63, 94, 0.5)',
  };
  
  const strokeMap: Record<string, string> = {
    cyan: '#06b6d4',
    purple: '#8b5cf6',
    emerald: '#10b981',
    amber: '#f59e0b',
    rose: '#f43f5e',
  };

  if (containerWidth === 0) return <div ref={containerRef} style={{ height }} />;

  return (
    <div
      ref={containerRef}
      className={cn("relative w-full select-none", className)}
      style={{ height }}
      {...props}
    >
      <svg width="100%" height="100%" viewBox={`0 0 ${containerWidth} ${height}`} className="overflow-visible">
        {/* Grid */}
        {[1, 2, 3, 4, 5].map((level) => {
          const levelRadius = (radius / 5) * level;
          const points = data.map((_, i) => {
            const angle = angleSlice * i - Math.PI / 2;
            return `${center.x + Math.cos(angle) * levelRadius},${center.y + Math.sin(angle) * levelRadius}`;
          }).join(' ');
          
          return (
            <polygon
              key={level}
              points={points}
              fill="none"
              stroke="rgba(255,255,255,0.1)"
              strokeWidth="1"
            />
          );
        })}

        {/* Axes & Labels */}
        {data.map((d, i) => {
          const angle = angleSlice * i - Math.PI / 2;
          const x = center.x + Math.cos(angle) * radius;
          const y = center.y + Math.sin(angle) * radius;
          
          // Label position (slightly outside)
          const labelX = center.x + Math.cos(angle) * (radius + 20);
          const labelY = center.y + Math.sin(angle) * (radius + 20);

          return (
            <g key={i}>
              <line
                x1={center.x}
                y1={center.y}
                x2={x}
                y2={y}
                stroke="rgba(255,255,255,0.1)"
                strokeWidth="1"
              />
              <text
                x={labelX}
                y={labelY}
                textAnchor="middle"
                dominantBaseline="middle"
                fill="rgba(255,255,255,0.6)"
                fontSize="12"
              >
                {d.subject}
              </text>
            </g>
          );
        })}

        {/* Data Polygons */}
        {keys.map((key, kIndex) => {
          const points = data.map((d, i) => {
            const value = Number(d[key]) || 0;
            const r = (value / maxValue) * radius;
            const angle = angleSlice * i - Math.PI / 2;
            return `${center.x + Math.cos(angle) * r},${center.y + Math.sin(angle) * r}`;
          }).join(' ');

          const colorName = colors[kIndex % colors.length] || 'cyan';
          const fill = colorMap[colorName];
          const stroke = strokeMap[colorName];

          return (
            <polygon
              key={key as string}
              points={points}
              fill={fill}
              fillOpacity={0.3}
              stroke={stroke}
              strokeWidth={2}
              className="transition-all duration-500 ease-out hover:fill-opacity-50"
            />
          );
        })}
      </svg>
    </div>
  );
}



=== FILE: packages\ui\src\components\data-display\chart\Sparkline.tsx ===

import React from 'react';
import { cn } from '../../../utils/cn';

export interface SparklineProps extends React.HTMLAttributes<HTMLDivElement> {
  data: number[];
  color?: 'cyan' | 'purple' | 'emerald' | 'amber' | 'rose' | 'white';
  height?: number;
  strokeWidth?: number;
  fill?: boolean;
}

export function Sparkline({
  data,
  color = 'emerald',
  height = 40,
  strokeWidth = 2,
  fill = false,
  className,
  ...props
}: SparklineProps) {
  const max = Math.max(...data);
  const min = Math.min(...data);
  const range = max - min || 1;

  const colors = {
    cyan: '#06b6d4',
    purple: '#8b5cf6',
    emerald: '#10b981',
    amber: '#f59e0b',
    rose: '#f43f5e',
    white: '#ffffff',
  };

  const strokeColor = colors[color];

  // Generate points
  // We assume width is 100% (viewBox 0 0 100 100) but we need aspect ratio.
  // To make it responsive without JS, we can use preserveAspectRatio="none" on the SVG
  // and map x from 0 to 100.
  
  const points = data.map((val, i) => {
    const x = (i / (data.length - 1)) * 100;
    // Invert Y because SVG 0 is top
    // Normalize value between 0 and 100 (height of viewBox)
    // Add some padding (5%) so stroke doesn't clip
    const normalized = ((val - min) / range);
    const y = 95 - (normalized * 90); 
    return { x, y };
  });

  let d = '';
  if (points.length > 0) {
    d = `M ${points[0]!.x} ${points[0]!.y}`;
    // Simple smoothing
    for (let i = 0; i < points.length - 1; i++) {
      const p0 = points[i]!;
      const p1 = points[i + 1]!;
      const cp1x = p0.x + (p1.x - p0.x) / 2;
      const cp1y = p0.y;
      const cp2x = p0.x + (p1.x - p0.x) / 2;
      const cp2y = p1.y;
      d += ` C ${cp1x} ${cp1y}, ${cp2x} ${cp2y}, ${p1.x} ${p1.y}`;
    }
  }

  const fillPath = fill 
    ? `${d} L 100 100 L 0 100 Z` 
    : undefined;

  return (
    <div 
      className={cn("w-full overflow-hidden", className)} 
      style={{ height }} 
      {...props}
    >
      <svg
        width="100%"
        height="100%"
        viewBox="0 0 100 100"
        preserveAspectRatio="none"
        className="overflow-visible"
      >
        {fill && (
          <path
            d={fillPath}
            fill={strokeColor}
            fillOpacity={0.1}
            stroke="none"
          />
        )}
        <path
          d={d}
          fill="none"
          stroke={strokeColor}
          strokeWidth={strokeWidth}
          strokeLinecap="round"
          strokeLinejoin="round"
          vectorEffect="non-scaling-stroke" // Keeps stroke width constant despite scaling
        />
      </svg>
    </div>
  );
}



=== FILE: packages\ui\src\components\data-display\chart\YAxis.tsx ===

import React from 'react';
import { useChart } from './Chart';

export interface YAxisProps {
  ticks?: number;
  format?: (value: number) => string;
}

export function ChartYAxis({ ticks = 5, format = (v) => v.toString() }: YAxisProps) {
  const { height, padding, maxValue } = useChart();
  const chartHeight = height - padding.top - padding.bottom;

  return (
    <g>
      {Array.from({ length: ticks + 1 }).map((_, i) => {
        const value = (maxValue / ticks) * i;
        const y = height - padding.bottom - (chartHeight / ticks) * i;
        
        return (
          <text
            key={i}
            x={padding.left - 10}
            y={y}
            textAnchor="end"
            dominantBaseline="middle"
            className="fill-gray-400 dark:fill-white/40 text-xs font-medium"
          >
            {format(Math.round(value))}
          </text>
        );
      })}
    </g>
  );
}



=== FILE: packages\ui\src\components\data-display\Collapse.tsx ===

import React, { useState, useRef, useEffect } from 'react';
import { cn } from '../../utils/cn';
import { ChevronDown } from 'lucide-react';

export interface CollapseProps extends Omit<React.HTMLAttributes<HTMLDivElement>, 'title'> {
  title?: React.ReactNode;
  open?: boolean;
  defaultOpen?: boolean;
  onOpenChange?: (open: boolean) => void;
  disabled?: boolean;
  children: React.ReactNode;
  triggerClassName?: string;
  contentClassName?: string;
}

export function Collapse({
  title,
  open: controlledOpen,
  defaultOpen = false,
  onOpenChange,
  disabled = false,
  children,
  className,
  triggerClassName,
  contentClassName,
  ...props
}: CollapseProps) {
  const [uncontrolledOpen, setUncontrolledOpen] = useState(defaultOpen);
  const isControlled = controlledOpen !== undefined;
  const isOpen = isControlled ? controlledOpen : uncontrolledOpen;

  const handleToggle = () => {
    if (disabled) return;
    const newState = !isOpen;
    if (!isControlled) {
      setUncontrolledOpen(newState);
    }
    onOpenChange?.(newState);
  };

  return (
    <div 
      className={cn(
        'w-full overflow-hidden rounded-2xl border border-gray-200 bg-white dark:border-white/10 dark:bg-white/[0.02]',
        className
      )} 
      {...props}
    >
      {title && (
        <button
          type="button"
          onClick={handleToggle}
          disabled={disabled}
          className={cn(
            'flex w-full items-center justify-between px-4 py-3 text-sm font-medium transition-colors hover:bg-gray-50 dark:hover:bg-white/[0.02]',
            disabled && 'cursor-not-allowed opacity-50',
            triggerClassName
          )}
        >
          {title}
          <ChevronDown
            className={cn(
              'h-4 w-4 shrink-0 text-gray-500 transition-transform duration-200 dark:text-gray-400',
              isOpen && 'rotate-180'
            )}
          />
        </button>
      )}
      
      <div
        className={cn(
          'grid transition-all duration-300 ease-in-out',
          isOpen ? 'grid-rows-[1fr]' : 'grid-rows-[0fr]'
        )}
      >
        <div className="overflow-hidden">
          <div className={cn('px-4 pb-4 pt-0', title && 'pt-1', contentClassName)}>
            {children}
          </div>
        </div>
      </div>
    </div>
  );
}



=== FILE: packages\ui\src\components\data-display\DataTable.tsx ===

import React, { useState, useMemo } from 'react';
import { Search, ArrowUpDown, ArrowUp, ArrowDown } from 'lucide-react';
import { Table, TableHeader, TableBody, TableRow, TableHead, TableCell } from './Table';
import { TextInput } from '../form/TextInput';
import { cn } from '../../utils/cn';

export interface Column<T> {
  key: keyof T | string;
  header: string;
  sortable?: boolean;
  render?: (item: T) => React.ReactNode;
  className?: string;
}

interface DataTableProps<T> {
  data: T[];
  columns: Column<T>[];
  searchPlaceholder?: string;
  searchKeys?: (keyof T)[];
  onRowClick?: (item: T) => void;
  className?: string;
  maxHeight?: number;
  rounded?: boolean;
}

export function DataTable<T extends Record<string, unknown>>({
  data,
  columns,
  searchPlaceholder = "Search...",
  searchKeys,
  onRowClick,
  className,
  maxHeight,
  rounded = true
}: DataTableProps<T>) {
  const [search, setSearch] = useState('');
  const [sortConfig, setSortConfig] = useState<{ key: keyof T | string; direction: 'asc' | 'desc' | null }>({
    key: '',
    direction: null
  });

  // Optimized search and sort logic with useMemo
  const processedData = useMemo(() => {
    let filtered = [...data];

    // Search
    if (search && searchKeys) {
      filtered = filtered.filter(item =>
        searchKeys.some(key => 
          String(item[key] ?? '').toLowerCase().includes(search.toLowerCase())
        )
      );
    }

    // Sort
    if (sortConfig.key && sortConfig.direction) {
      filtered.sort((a, b) => {
        const aValue = a[sortConfig.key as keyof T];
        const bValue = b[sortConfig.key as keyof T];
        
        if (aValue === undefined || aValue === null || bValue === undefined || bValue === null) return 0;
        if (aValue < bValue) return sortConfig.direction === 'asc' ? -1 : 1;
        if (aValue > bValue) return sortConfig.direction === 'asc' ? 1 : -1;
        return 0;
      });
    }

    return filtered;
  }, [data, search, searchKeys, sortConfig]);

  const handleSort = (key: keyof T | string) => {
    setSortConfig(prev => ({
      key,
      direction: prev.key === key && prev.direction === 'asc' ? 'desc' : 'asc'
    }));
  };

  return (
    <div className={cn("space-y-4", className)}>
      {searchKeys && (
        <div className="relative max-w-sm">
          <TextInput
            placeholder={searchPlaceholder}
            value={search}
            onChange={(e) => setSearch(e.target.value)}
            leftIcon={<Search className="w-4 h-4 text-white/40" />}
          />
        </div>
      )}

      <Table rounded={rounded} maxHeight={maxHeight}>
        <TableHeader>
          <TableRow>
            {columns.map((col) => (
              <TableHead 
                key={String(col.key)} 
                className={cn(col.sortable && "cursor-pointer select-none hover:text-cyan-500 transition-colors", col.className)}
                onClick={() => col.sortable && handleSort(col.key)}
              >
                <div className="flex items-center gap-2">
                  {col.header}
                  {col.sortable && (
                    <span className="text-white/30">
                      {sortConfig.key === col.key ? (
                        sortConfig.direction === 'asc' ? <ArrowUp className="w-3 h-3 text-cyan-500" /> : <ArrowDown className="w-3 h-3 text-cyan-500" />
                      ) : (
                        <ArrowUpDown className="w-3 h-3" />
                      )}
                    </span>
                  )}
                </div>
              </TableHead>
            ))}
          </TableRow>
        </TableHeader>
        <TableBody>
          {processedData.map((item, idx) => (
            <TableRow 
              key={idx} 
              onClick={() => onRowClick?.(item)}
              className={cn(onRowClick && "cursor-pointer hover:bg-white/[0.03] transition-colors group")}
            >
              {columns.map((col) => (
                <TableCell key={String(col.key)} className={col.className}>
                  {col.render ? col.render(item) : (item[col.key as keyof T] as React.ReactNode)}
                </TableCell>
              ))}
            </TableRow>
          ))}
          {processedData.length === 0 && (
            <TableRow>
              <TableCell colSpan={columns.length} className="h-32 text-center text-white/40">
                No results found for "{search}"
              </TableCell>
            </TableRow>
          )}
        </TableBody>
      </Table>
    </div>
  );
}



=== FILE: packages\ui\src\components\data-display\Image.tsx ===

import React, { useState } from 'react';
import { cn } from '../../utils/cn';
import { Skeleton } from '../feedback/Skeleton';

export interface ImageProps extends React.ImgHTMLAttributes<HTMLImageElement> {
  fallback?: React.ReactNode;
  containerClassName?: string;
}

export const Image = React.forwardRef<HTMLImageElement, ImageProps>(
  ({ className, containerClassName, alt, src, fallback, onLoad, onError, ...props }, ref) => {
    const [isLoading, setIsLoading] = useState(true);
    const [hasError, setHasError] = useState(false);

    const handleLoad = (e: React.SyntheticEvent<HTMLImageElement, Event>) => {
      setIsLoading(false);
      onLoad?.(e);
    };

    const handleError = (e: React.SyntheticEvent<HTMLImageElement, Event>) => {
      setIsLoading(false);
      setHasError(true);
      onError?.(e);
    };

    if (hasError && fallback) {
      return <>{fallback}</>;
    }

    return (
      <div className={cn("relative overflow-hidden rounded-2xl bg-gray-100 dark:bg-white/[0.02] border border-gray-200 dark:border-white/10", containerClassName)}>
        {isLoading && (
           <Skeleton className="absolute inset-0 h-full w-full" />
        )}
        <img
          ref={ref}
          src={src}
          alt={alt}
          onLoad={handleLoad}
          onError={handleError}
          className={cn(
            "h-full w-full object-cover transition-opacity duration-300",
            isLoading ? "opacity-0" : "opacity-100",
            className
          )}
          {...props}
        />
      </div>
    );
  }
);
Image.displayName = "Image";



=== FILE: packages\ui\src\components\data-display\kanban\components\AssigneePicker.tsx ===

import React from 'react';
import { cn } from '../../../../utils/cn';
import { Avatar } from '../../Avatar';
import { Check, Users } from 'lucide-react';
import type { KanbanUser } from '../types';

interface AssigneePickerProps {
  users: KanbanUser[];
  selectedId?: string;
  onSelect: (id: string) => void;
  className?: string;
}

export function AssigneePicker({ users, selectedId, onSelect, className }: AssigneePickerProps) {
  return (
    <div className={cn("space-y-3", className)}>
      <h4 className="text-[10px] text-white/40 uppercase tracking-wider font-bold flex items-center gap-2">
        <Users className="h-3 w-3" />
        Assignee
      </h4>
      <div className="grid grid-cols-1 gap-1">
        {users.map((user) => {
          const isSelected = selectedId === user.id;
          return (
            <button
              key={user.id}
              onClick={() => onSelect(user.id)}
              className={cn(
                "flex items-center gap-3 p-2 rounded-xl transition-all text-left",
                isSelected 
                  ? "bg-white/10 text-white" 
                  : "text-white/60 hover:bg-white/5"
              )}
            >
              <Avatar src={user.avatar} alt={user.name} size="sm" />
              <span className="text-sm flex-1 truncate">{user.name}</span>
              {isSelected && <Check className="h-4 w-4 text-blue-500" />}
            </button>
          );
        })}
      </div>
    </div>
  );
}



=== FILE: packages\ui\src\components\data-display\kanban\components\Checklist.tsx ===

import React from 'react';
import { cn } from '../../../../utils/cn';
import { CheckSquare, Square } from 'lucide-react';
import type { ChecklistItem } from '../types';

interface ChecklistProps {
  items: ChecklistItem[];
  onToggle?: (id: string) => void;
  className?: string;
}

export function Checklist({ items, onToggle, className }: ChecklistProps) {
  if (!items || items.length === 0) return null;

  const completedCount = items.filter(i => i.completed).length;
  const progress = (completedCount / items.length) * 100;

  return (
    <div className={cn("space-y-3", className)}>
      <div className="flex items-center justify-between text-[10px] text-white/40 uppercase tracking-wider font-bold">
        <span>Checklist</span>
        <span>{completedCount}/{items.length}</span>
      </div>
      
      <div className="h-1 w-full bg-white/5 rounded-full overflow-hidden">
        <div 
          className="h-full bg-blue-500 transition-all duration-500" 
          style={{ width: `${progress}%` }}
        />
      </div>

      <div className="space-y-2">
        {items.map((item) => (
          <div 
            key={item.id}
            className="flex items-center gap-2 group cursor-pointer"
            onClick={() => onToggle?.(item.id)}
          >
            {item.completed ? (
              <CheckSquare className="h-4 w-4 text-blue-500" />
            ) : (
              <Square className="h-4 w-4 text-white/20 group-hover:text-white/40" />
            )}
            <span className={cn(
              "text-sm transition-colors",
              item.completed ? "text-white/40 line-through" : "text-white/80"
            )}>
              {item.title}
            </span>
          </div>
        ))}
      </div>
    </div>
  );
}



=== FILE: packages\ui\src\components\data-display\kanban\components\ColumnLimit.tsx ===

import React from 'react';
import { cn } from '../../../../utils/cn';
import { AlertCircle } from 'lucide-react';

interface ColumnLimitProps {
  count: number;
  limit?: number;
  className?: string;
}

export function ColumnLimit({ count, limit, className }: ColumnLimitProps) {
  if (!limit) return null;

  const isOverLimit = count > limit;
  const percentage = Math.min((count / limit) * 100, 100);

  return (
    <div className={cn("flex items-center gap-3", className)}>
      <div className="flex-1 h-1 bg-white/5 rounded-full overflow-hidden">
        <div 
          className={cn(
            "h-full transition-all duration-500",
            isOverLimit ? "bg-red-500" : percentage > 80 ? "bg-orange-500" : "bg-blue-500"
          )}
          style={{ width: `${percentage}%` }}
        />
      </div>
      <div className={cn(
        "flex items-center gap-1.5 text-[10px] font-bold px-2 py-0.5 rounded-full",
        isOverLimit ? "bg-red-500/20 text-red-400" : "bg-white/5 text-white/40"
      )}>
        {isOverLimit && <AlertCircle className="h-3 w-3" />}
        {count}/{limit}
      </div>
    </div>
  );
}



=== FILE: packages\ui\src\components\data-display\kanban\components\DueDatePicker.tsx ===

import React from 'react';
import { cn } from '../../../../utils/cn';
import { Calendar as CalendarIcon, Clock, X } from 'lucide-react';
import { Button } from '../../../button/Button';

interface DueDatePickerProps {
  date?: Date;
  onChange: (date: Date | undefined) => void;
  className?: string;
}

export function DueDatePicker({ date, onChange, className }: DueDatePickerProps) {
  return (
    <div className={cn("space-y-3", className)}>
      <h4 className="text-[10px] text-white/40 uppercase tracking-wider font-bold flex items-center gap-2">
        <CalendarIcon className="h-3 w-3" />
        Due Date
      </h4>
      
      {date ? (
        <div className="flex items-center gap-2 p-3 rounded-2xl bg-white/5 border border-white/10">
          <div className="h-8 w-8 rounded-lg bg-blue-500/20 flex items-center justify-center text-blue-400">
            <Clock className="h-4 w-4" />
          </div>
          <div className="flex-1">
            <p className="text-sm font-medium text-white">
              {date.toLocaleDateString(undefined, { month: 'short', day: 'numeric', year: 'numeric' })}
            </p>
            <p className="text-[10px] text-white/40">
              {date.toLocaleTimeString(undefined, { hour: '2-digit', minute: '2-digit' })}
            </p>
          </div>
          <Button 
            variant="ghost" 
            size="icon" 
            className="h-8 w-8 text-white/20 hover:text-red-400"
            onClick={() => onChange(undefined)}
          >
            <X className="h-4 w-4" />
          </Button>
        </div>
      ) : (
        <Button 
          variant="ghost" 
          className="w-full justify-start gap-3 h-12 rounded-2xl border border-dashed border-white/10 text-white/40 hover:border-white/20 hover:bg-white/5"
          onClick={() => onChange(new Date())}
        >
          <CalendarIcon className="h-4 w-4" />
          Set due date
        </Button>
      )}
    </div>
  );
}



=== FILE: packages\ui\src\components\data-display\kanban\components\LabelPicker.tsx ===

import React from 'react';
import { cn } from '../../../../utils/cn';
import { Check, Tag } from 'lucide-react';
import type { KanbanLabel } from '../types';

interface LabelPickerProps {
  labels: KanbanLabel[];
  selectedIds: string[];
  onToggle: (id: string) => void;
  className?: string;
}

export function LabelPicker({ labels, selectedIds, onToggle, className }: LabelPickerProps) {
  return (
    <div className={cn("space-y-3", className)}>
      <h4 className="text-[10px] text-white/40 uppercase tracking-wider font-bold flex items-center gap-2">
        <Tag className="h-3 w-3" />
        Labels
      </h4>
      <div className="flex flex-wrap gap-2">
        {labels.map((label) => {
          const isSelected = selectedIds.includes(label.id);
          return (
            <button
              key={label.id}
              onClick={() => onToggle(label.id)}
              className={cn(
                "px-3 py-1.5 rounded-full text-xs font-medium transition-all flex items-center gap-2 border",
                isSelected 
                  ? "bg-white/10 border-white/20 text-white" 
                  : "bg-transparent border-white/5 text-white/40 hover:border-white/10"
              )}
            >
              <div 
                className="h-2 w-2 rounded-full" 
                style={{ backgroundColor: label.color }} 
              />
              {label.name}
              {isSelected && <Check className="h-3 w-3" />}
            </button>
          );
        })}
      </div>
    </div>
  );
}



=== FILE: packages\ui\src\components\data-display\kanban\components\SubtaskList.tsx ===

import React from 'react';
import { cn } from '../../../../utils/cn';
import { CheckCircle2, Circle } from 'lucide-react';
import type { Subtask } from '../types';

interface SubtaskListProps {
  subtasks: Subtask[];
  onToggle?: (id: string) => void;
  className?: string;
}

export function SubtaskList({ subtasks, onToggle, className }: SubtaskListProps) {
  if (!subtasks || subtasks.length === 0) return null;

  return (
    <div className={cn("space-y-1", className)}>
      {subtasks.map((subtask) => (
        <div 
          key={subtask.id}
          className="flex items-center gap-2 group cursor-pointer"
          onClick={() => onToggle?.(subtask.id)}
        >
          {subtask.completed ? (
            <CheckCircle2 className="h-3.5 w-3.5 text-green-500" />
          ) : (
            <Circle className="h-3.5 w-3.5 text-white/20 group-hover:text-white/40" />
          )}
          <span className={cn(
            "text-xs transition-colors",
            subtask.completed ? "text-white/40 line-through" : "text-white/70"
          )}>
            {subtask.title}
          </span>
        </div>
      ))}
    </div>
  );
}



=== FILE: packages\ui\src\components\data-display\kanban\components\TaskActivity.tsx ===

import React from 'react';
import { cn } from '../../../../utils/cn';
import { Avatar } from '../../Avatar';
import type { KanbanUser } from '../types';

interface Activity {
  id: string;
  user: KanbanUser;
  action: string;
  target?: string;
  timestamp: Date;
}

interface TaskActivityProps {
  activities: Activity[];
  className?: string;
}

export function TaskActivity({ activities, className }: TaskActivityProps) {
  return (
    <div className={cn("space-y-4", className)}>
      <h4 className="text-[10px] text-white/40 uppercase tracking-wider font-bold">Activity</h4>
      <div className="space-y-4">
        {activities.map((activity) => (
          <div key={activity.id} className="flex gap-3">
            <Avatar src={activity.user.avatar} alt={activity.user.name} size="sm" />
            <div className="flex-1 min-w-0">
              <p className="text-xs text-white/80">
                <span className="font-bold text-white">{activity.user.name}</span>
                {' '}{activity.action}{' '}
                {activity.target && <span className="font-medium text-blue-400">{activity.target}</span>}
              </p>
              <p className="text-[10px] text-white/30 mt-0.5">
                {activity.timestamp.toLocaleString()}
              </p>
            </div>
          </div>
        ))}
      </div>
    </div>
  );
}



=== FILE: packages\ui\src\components\data-display\kanban\components\TaskAttachments.tsx ===

import React from 'react';
import { cn } from '../../../../utils/cn';
import { FileIcon, X, Download, Paperclip } from 'lucide-react';
import { Button } from '../../../button/Button';

interface Attachment {
  id: string;
  name: string;
  size: string;
  type: string;
  url: string;
  thumbnail?: string;
}

interface TaskAttachmentsProps {
  attachments: Attachment[];
  onRemove?: (id: string) => void;
  onDownload?: (attachment: Attachment) => void;
  className?: string;
}

export function TaskAttachments({ attachments, onRemove, onDownload, className }: TaskAttachmentsProps) {
  return (
    <div className={cn("space-y-4", className)}>
      <div className="flex items-center justify-between">
        <h4 className="text-[10px] text-white/40 uppercase tracking-wider font-bold">Attachments</h4>
        <Button variant="ghost" size="sm" className="h-7 gap-1.5 text-white/40 hover:text-white">
          <Paperclip className="h-3 w-3" />
          Add
        </Button>
      </div>

      <div className="grid grid-cols-2 gap-3">
        {attachments.map((file) => (
          <div 
            key={file.id} 
            className="group relative bg-white/[0.03] border border-white/5 rounded-xl overflow-hidden hover:border-white/20 transition-all"
          >
            {file.thumbnail ? (
              <div className="aspect-video w-full overflow-hidden">
                <img src={file.thumbnail} alt={file.name} className="w-full h-full object-cover" />
              </div>
            ) : (
              <div className="aspect-video w-full flex items-center justify-center bg-white/5">
                <FileIcon className="h-8 w-8 text-white/20" />
              </div>
            )}
            
            <div className="p-2">
              <p className="text-xs font-medium text-white truncate">{file.name}</p>
              <p className="text-[10px] text-white/30 uppercase">{file.size}</p>
            </div>

            <div className="absolute inset-0 bg-black/60 opacity-0 group-hover:opacity-100 transition-opacity flex items-center justify-center gap-2">
              <Button 
                variant="ghost" 
                size="icon" 
                className="h-8 w-8 rounded-full bg-white/10 hover:bg-white/20"
                onClick={() => onDownload?.(file)}
              >
                <Download className="h-4 w-4" />
              </Button>
              <Button 
                variant="ghost" 
                size="icon" 
                className="h-8 w-8 rounded-full bg-red-500/20 hover:bg-red-500/40 text-red-400"
                onClick={() => onRemove?.(file.id)}
              >
                <X className="h-4 w-4" />
              </Button>
            </div>
          </div>
        ))}
      </div>
    </div>
  );
}



=== FILE: packages\ui\src\components\data-display\kanban\components\TaskComments.tsx ===

import React, { useState } from 'react';
import { cn } from '../../../../utils/cn';
import { Avatar } from '../../Avatar';
import { Button } from '../../../button/Button';
import { Textarea } from '../../../form/Textarea';
import { Send } from 'lucide-react';
import type { KanbanUser } from '../types';

interface Comment {
  id: string;
  user: KanbanUser;
  content: string;
  timestamp: Date;
}

interface TaskCommentsProps {
  comments: Comment[];
  onAddComment?: (content: string) => void;
  className?: string;
}

export function TaskComments({ comments, onAddComment, className }: TaskCommentsProps) {
  const [newComment, setNewComment] = useState('');

  const handleSubmit = () => {
    if (!newComment.trim()) return;
    onAddComment?.(newComment);
    setNewComment('');
  };

  return (
    <div className={cn("space-y-6", className)}>
      <h4 className="text-[10px] text-white/40 uppercase tracking-wider font-bold">Comments</h4>
      
      <div className="flex gap-3">
        <div className="flex-1">
          <Textarea 
            placeholder="Write a comment..."
            value={newComment}
            onChange={(e) => setNewComment(e.target.value)}
            className="min-h-[80px] bg-white/[0.03] border-white/10 text-sm"
          />
          <div className="flex justify-end mt-2">
            <Button 
              size="sm" 
              onClick={handleSubmit}
              disabled={!newComment.trim()}
              className="gap-2"
            >
              <Send className="h-3.5 w-3.5" />
              Comment
            </Button>
          </div>
        </div>
      </div>

      <div className="space-y-6">
        {comments.map((comment) => (
          <div key={comment.id} className="flex gap-3">
            <Avatar src={comment.user.avatar} alt={comment.user.name} size="sm" />
            <div className="flex-1 bg-white/[0.03] border border-white/5 rounded-2xl p-3">
              <div className="flex items-center justify-between mb-1">
                <span className="text-xs font-bold text-white">{comment.user.name}</span>
                <span className="text-[10px] text-white/30">{comment.timestamp.toLocaleString()}</span>
              </div>
              <p className="text-sm text-white/70 leading-relaxed">{comment.content}</p>
            </div>
          </div>
        ))}
      </div>
    </div>
  );
}



=== FILE: packages\ui\src\components\data-display\kanban\components\TimeTracker.tsx ===

import React, { useState, useEffect } from 'react';
import { cn } from '../../../../utils/cn';
import { Play, Pause, RotateCcw, Timer } from 'lucide-react';
import { Button } from '../../../button/Button';

interface TimeTrackerProps {
  initialSeconds?: number;
  onTimeUpdate?: (seconds: number) => void;
  className?: string;
}

export function TimeTracker({ initialSeconds = 0, onTimeUpdate, className }: TimeTrackerProps) {
  const [seconds, setSeconds] = useState(initialSeconds);
  const [isActive, setIsActive] = useState(false);

  useEffect(() => {
    let interval: any = null;
    if (isActive) {
      interval = setInterval(() => {
        setSeconds((s) => {
          const next = s + 1;
          onTimeUpdate?.(next);
          return next;
        });
      }, 1000);
    } else {
      clearInterval(interval);
    }
    return () => clearInterval(interval);
  }, [isActive, onTimeUpdate]);

  const formatTime = (s: number) => {
    const hrs = Math.floor(s / 3600);
    const mins = Math.floor((s % 3600) / 60);
    const secs = s % 60;
    return `${hrs.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
  };

  return (
    <div className={cn("space-y-3", className)}>
      <h4 className="text-[10px] text-white/40 uppercase tracking-wider font-bold flex items-center gap-2">
        <Timer className="h-3 w-3" />
        Time Tracking
      </h4>
      
      <div className="flex items-center gap-4 p-4 rounded-2xl bg-white/[0.03] border border-white/5">
        <div className="flex-1">
          <p className="text-2xl font-mono font-bold text-white tracking-tight">
            {formatTime(seconds)}
          </p>
          <p className="text-[10px] text-white/30 uppercase font-bold mt-1">Total Time Spent</p>
        </div>
        
        <div className="flex gap-2">
          <Button
            variant="ghost"
            size="icon"
            className="h-10 w-10 rounded-full bg-white/5 hover:bg-white/10"
            onClick={() => setSeconds(0)}
          >
            <RotateCcw className="h-4 w-4" />
          </Button>
          <Button
            variant={isActive ? "secondary" : "primary"}
            size="icon"
            className={cn(
              "h-10 w-10 rounded-full shadow-lg transition-all",
              isActive ? "bg-orange-500 hover:bg-orange-600" : "bg-blue-600 hover:bg-blue-700"
            )}
            onClick={() => setIsActive(!isActive)}
          >
            {isActive ? <Pause className="h-4 w-4" /> : <Play className="h-4 w-4 ml-0.5" />}
          </Button>
        </div>
      </div>
    </div>
  );
}



=== FILE: packages\ui\src\components\data-display\kanban\KanbanBoard.tsx ===

import React, { useState, useMemo } from 'react';
import { cn } from '../../../utils/cn';
import { KanbanHeader } from './KanbanHeader';
import { KanbanColumn } from './KanbanColumn';
import { KanbanListView } from './KanbanListView';
import { KanbanTimelineView } from './KanbanTimelineView';
import { KanbanTableView } from './KanbanTableView';
import { KanbanCalendarView } from './KanbanCalendarView';
import { KanbanFilterBar } from './KanbanFilterBar';
import { KanbanTaskModal } from './KanbanTaskModal';
import { KanbanSwimlane } from './KanbanSwimlane';
import { useKanbanFilters } from './useKanbanFilters';
import { useKanbanUndo } from './useKanbanUndo';
import { useKanbanKeyboard } from './useKanbanKeyboard';
import { useKanbanDragAndDrop } from './useKanbanDragAndDrop';
import type { KanbanProps, KanbanTask, KanbanColumnDef } from './types';

export function KanbanBoard({
  columns: initialColumns,
  tasks: initialTasks,
  onTaskMove,
  onColumnMove,
  onTaskClick,
  onTaskAdd,
  onColumnAction,
  swimlanes = false,
  swimlaneBy = 'priority',
  view: propView,
  onViewChange,
  className,
  ...props
}: KanbanProps) {
  const [internalView, setInternalView] = useState<'board' | 'list' | 'calendar' | 'timeline' | 'table'>(propView || 'board');
  const [selectedTaskId, setSelectedTaskId] = useState<string | null>(null);
  const [collapsedSwimlanes, setCollapsedSwimlanes] = useState<string[]>([]);

  const view = propView || internalView;
  const setView = (v: 'board' | 'list' | 'calendar' | 'timeline' | 'table') => {
    setInternalView(v);
    onViewChange?.(v);
  };
  
  const { 
    state, 
    pushState, 
    undo, 
    redo, 
    canUndo, 
    canRedo 
  } = useKanbanUndo({ tasks: initialTasks, columns: initialColumns });

  const tasks = state?.tasks || [];
  const columns = state?.columns || [];

  const {
    setSearchQuery,
    setActiveFilters,
    filteredTasks
  } = useKanbanFilters(tasks);

  const swimlaneGroups = useMemo(() => {
    if (!swimlanes) return null;
    const groups: Record<string, KanbanTask[]> = {};
    
    const getNestedValue = (obj: any, path: string) => {
      if (!path.includes('.')) return obj[path];
      return path.split('.').reduce((acc, part) => acc && acc[part], obj);
    };

    filteredTasks.forEach(task => {
      const rawValue = getNestedValue(task, swimlaneBy as string);
      const value = String(rawValue || 'Uncategorized');
      if (!groups[value]) groups[value] = [];
      groups[value].push(task);
    });
    return groups;
  }, [filteredTasks, swimlanes, swimlaneBy]);

  const {
    handleDragStart,
    handleDragOver,
    handleDrop,
    handleDragEnd
  } = useKanbanDragAndDrop({ 
    columns, 
    tasks, 
    selectedTaskIds: [], 
    onTaskMove: (taskId, toColumnId, toTaskId, position) => {
      const newTasks = [...tasks];
      const taskIndex = newTasks.findIndex(t => t.id === taskId);
      if (taskIndex === -1) return;

      const task = { ...newTasks[taskIndex], columnId: toColumnId } as KanbanTask;
      newTasks.splice(taskIndex, 1);
      
      if (!toTaskId) {
        newTasks.push(task);
      } else {
        const targetIndex = newTasks.findIndex(t => t.id === toTaskId);
        const insertIndex = position === 'bottom' ? targetIndex + 1 : targetIndex;
        newTasks.splice(insertIndex, 0, task);
      }

      pushState({ tasks: newTasks, columns });
      onTaskMove?.(taskId, toColumnId, toTaskId, position);
    }
  });

  useKanbanKeyboard({
    onUndo: undo,
    onRedo: redo,
    onSearch: () => document.querySelector<HTMLInputElement>('input[placeholder*="Search"]')?.focus(),
    onNewTask: () => onTaskAdd?.('todo', 'New Task')
  });

  const selectedTask = useMemo(() => 
    tasks.find(t => t.id === selectedTaskId), 
    [tasks, selectedTaskId]
  );

  const renderView = () => {
    const handleTaskClick = (task: KanbanTask) => {
      setSelectedTaskId(task.id);
      onTaskClick?.(task);
    };

    switch (view) {
      case 'list':
        return <KanbanListView tasks={filteredTasks} columns={columns} onTaskClick={handleTaskClick} />;
      case 'timeline':
        return <KanbanTimelineView tasks={filteredTasks} />;
      case 'table':
        return <KanbanTableView tasks={filteredTasks} columns={columns} onTaskClick={handleTaskClick} />;
      case 'calendar':
        return <KanbanCalendarView tasks={filteredTasks} onTaskClick={handleTaskClick} />;
      default:
        if (swimlanes) {
          const groups = swimlaneGroups && Object.keys(swimlaneGroups).length > 0 
            ? swimlaneGroups 
            : { 'All Tasks': [] };

          return (
            <div className="flex flex-col gap-8 overflow-y-auto h-full pr-2 custom-scrollbar">
              {Object.entries(groups).map(([groupName, groupTasks]) => (
                <KanbanSwimlane
                  key={groupName}
                  title={groupName}
                  count={groupTasks.length}
                  isCollapsed={collapsedSwimlanes.includes(groupName)}
                  onToggle={() => setCollapsedSwimlanes(prev => 
                    prev.includes(groupName) ? prev.filter(s => s !== groupName) : [...prev, groupName]
                  )}
                >
                  <div className="flex gap-6 min-h-[200px]">
                    {columns.map(column => (
                      <KanbanColumn
                        key={column.id}
                        column={column}
                        tasks={groupTasks.filter(t => t.columnId === column.id)}
                        onTaskClick={handleTaskClick}
                        onAddTask={() => onTaskAdd?.(column.id, 'New Task')}
                        onAction={(action) => onColumnAction?.(column.id, action)}
                        onDragStart={handleDragStart}
                        onDragOver={(e, taskId) => handleDragOver(e, column.id, taskId)}
                        onDrop={(e, taskId) => handleDrop(e, column.id, taskId)}
                      />
                    ))}
                  </div>
                </KanbanSwimlane>
              ))}
            </div>
          );
        }

        return (
          <div className="flex gap-6 overflow-x-auto pb-4 min-h-[500px] scrollbar-thin scrollbar-thumb-white/10">
            {columns.map(column => (
              <KanbanColumn
                key={column.id}
                column={column}
                tasks={filteredTasks.filter(t => t.columnId === column.id)}
                onTaskClick={handleTaskClick}
                onAddTask={() => onTaskAdd?.(column.id, 'New Task')}
                onAction={(action) => onColumnAction?.(column.id, action)}
                onDragStart={handleDragStart}
                onDragOver={(e, taskId) => handleDragOver(e, column.id, taskId)}
                onDrop={(e, taskId) => handleDrop(e, column.id, taskId)}
              />
            ))}
          </div>
        );
    }
  };

  return (
    <div className={cn("flex flex-col gap-4 h-full", className)}>
      <KanbanHeader 
        title="Project Board"
        view={view}
        onViewChange={(v) => setView(v as any)}
        canUndo={canUndo}
        canRedo={canRedo}
        onUndo={undo}
        onRedo={redo}
      />
      
      <KanbanFilterBar 
        onSearchChange={setSearchQuery}
        onFilterChange={setActiveFilters}
      />

      <div className="flex-1 overflow-hidden">
        {renderView()}
      </div>

      {selectedTask && (
        <KanbanTaskModal
          isOpen={!!selectedTaskId}
          onClose={() => setSelectedTaskId(null)}
          task={selectedTask}
          onSave={(updatedTask) => {
            const updatedTasks = tasks.map(t => t.id === selectedTask.id ? { ...t, ...updatedTask } : t);
            pushState({ tasks: updatedTasks, columns });
            setSelectedTaskId(null);
          }}
        />
      )}
    </div>
  );
}



=== FILE: packages\ui\src\components\data-display\kanban\KanbanCalendarView.tsx ===

import React, { useState } from 'react';
import { cn } from '../../../utils/cn';
import { Surface } from '../../../primitives/Surface';
import { Text } from '../../typography/Text';
import { Button } from '../../button/Button';
import { ChevronLeft, ChevronRight, Plus } from 'lucide-react';
import type { KanbanTask } from './types';

export interface KanbanCalendarViewProps {
  tasks: KanbanTask[];
  onTaskClick?: (task: KanbanTask) => void;
  onAddTask?: (date: Date) => void;
  className?: string;
}

export function KanbanCalendarView({ 
  tasks, 
  onTaskClick, 
  onAddTask,
  className 
}: KanbanCalendarViewProps) {
  const [currentDate, setCurrentDate] = useState(new Date());

  const daysInMonth = (year: number, month: number) => new Date(year, month + 1, 0).getDate();
  const firstDayOfMonth = (year: number, month: number) => new Date(year, month, 1).getDay();

  const year = currentDate.getFullYear();
  const month = currentDate.getMonth();
  const totalDays = daysInMonth(year, month);
  const startDay = firstDayOfMonth(year, month);

  const prevMonth = () => setCurrentDate(new Date(year, month - 1, 1));
  const nextMonth = () => setCurrentDate(new Date(year, month + 1, 1));

  const monthNames = [
    "January", "February", "March", "April", "May", "June",
    "July", "August", "September", "October", "November", "December"
  ];

  const days = [];
  // Add empty slots for previous month
  for (let i = 0; i < startDay; i++) {
    days.push(null);
  }
  // Add days of current month
  for (let i = 1; i <= totalDays; i++) {
    days.push(new Date(year, month, i));
  }

  const getTasksForDate = (date: Date) => {
    return tasks.filter(task => {
      if (!task.dueDate) return false;
      const d = new Date(task.dueDate);
      return d.getDate() === date.getDate() && 
             d.getMonth() === date.getMonth() && 
             d.getFullYear() === date.getFullYear();
    });
  };

  return (
    <div className={cn("flex flex-col h-full", className)}>
      <div className="flex items-center justify-between mb-6">
        <div className="flex items-center gap-4">
          <Heading level={3} className="text-white">{monthNames[month]} {year}</Heading>
          <div className="flex items-center gap-1">
            <Button variant="ghost" size="sm" onClick={prevMonth}>
              <ChevronLeft className="h-4 w-4" />
            </Button>
            <Button variant="ghost" size="sm" onClick={nextMonth}>
              <ChevronRight className="h-4 w-4" />
            </Button>
          </div>
        </div>
        <Button variant="ghost" size="sm" onClick={() => setCurrentDate(new Date())}>
          Today
        </Button>
      </div>

      <div className="grid grid-cols-7 gap-px bg-white/5 border border-white/5 rounded-2xl overflow-hidden flex-1">
        {["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"].map(day => (
          <div key={day} className="bg-white/[0.02] p-3 text-center">
            <Text size="xs" className="text-white/40 font-medium uppercase tracking-wider">{day}</Text>
          </div>
        ))}

        {days.map((date, i) => (
          <div 
            key={i} 
            className={cn(
              "bg-gray-900/50 min-h-[120px] p-2 group transition-colors hover:bg-white/[0.02]",
              !date && "bg-transparent"
            )}
          >
            {date && (
              <>
                <div className="flex items-center justify-between mb-2">
                  <span className={cn(
                    "text-xs font-medium w-6 h-6 flex items-center justify-center rounded-full",
                    date.toDateString() === new Date().toDateString() 
                      ? "bg-blue-500 text-white" 
                      : "text-white/40"
                  )}>
                    {date.getDate()}
                  </span>
                  <button 
                    onClick={() => onAddTask?.(date)}
                    className="opacity-0 group-hover:opacity-100 p-1 hover:bg-white/10 rounded-lg transition-all"
                  >
                    <Plus className="h-3 w-3 text-white/40" />
                  </button>
                </div>
                <div className="space-y-1">
                  {getTasksForDate(date).map(task => (
                    <div 
                      key={task.id}
                      onClick={() => onTaskClick?.(task)}
                      className="px-2 py-1 rounded-lg bg-blue-500/10 border border-blue-500/20 cursor-pointer hover:bg-blue-500/20 transition-all"
                    >
                      <Text size="xs" className="text-blue-400 truncate">{task.title}</Text>
                    </div>
                  ))}
                </div>
              </>
            )}
          </div>
        ))}
      </div>
    </div>
  );
}

function Heading({ children, level, className }: { children: React.ReactNode, level: number, className?: string }) {
  const Tag = `h${level}` as any;
  return <Tag className={cn("font-semibold", className)}>{children}</Tag>;
}



=== FILE: packages\ui\src\components\data-display\kanban\KanbanCard.tsx ===

import React from 'react';
import { Lock, Trash2, GripVertical, MessageSquare, Paperclip, Clock, Play, Pause } from 'lucide-react';
import { Surface } from '../../../primitives/Surface';
import { Badge } from '../../../primitives/Badge';
import { Text } from '../../typography/Text';
import { Checkbox } from '../../form/Checkbox';
import { cn } from '../../../utils/cn';
import type { KanbanTask } from './types';

interface KanbanCardProps {
  task: KanbanTask;
  isSelected?: boolean;
  showTimer?: boolean;
  onEdit?: (task: KanbanTask) => void;
  onDelete?: (taskId: string) => void;
  draggable?: boolean;
  activeTimerTaskId?: string | null;
  selectable?: boolean;
  cardClassName?: string;
  onTaskClick?: (e: React.MouseEvent, task: KanbanTask) => void;
  onTaskSelectionChange?: (selectedIds: string[]) => void;
  onTaskTimerToggle?: (taskId: string) => void;
  onDragStart?: (e: React.DragEvent) => void;
  onDragOver?: (e: React.DragEvent) => void;
  onDrop?: (e: React.DragEvent) => void;
  renderCard?: (task: KanbanTask) => React.ReactNode;
}

export const KanbanCard = React.memo(({
  task,
  isSelected,
  showTimer,
  onEdit,
  onDelete,
  draggable = true,
  activeTimerTaskId,
  selectable,
  cardClassName,
  onTaskClick,
  onTaskSelectionChange,
  onTaskTimerToggle,
  onDragStart,
  onDragOver,
  onDrop,
  renderCard
}: KanbanCardProps) => {
  if (renderCard) return <>{renderCard(task)}</>;

  const getPriorityColor = (priority?: string) => {
    switch (priority) {
      case 'urgent': return 'danger';
      case 'high': return 'warning';
      case 'medium': return 'info';
      case 'low': return 'success';
      default: return 'neutral';
    }
  };

  return (
    <Surface 
      onClick={(e) => onTaskClick?.(e, task)}
      draggable={draggable}
      onDragStart={onDragStart}
      onDragOver={onDragOver}
      onDrop={onDrop}
      className={cn(
        "p-6 border border-white/10 bg-white/[0.03] hover:bg-white/[0.06] transition-all duration-200 rounded-2xl group cursor-grab active:cursor-grabbing",
        task.blockedBy && task.blockedBy.length > 0 && "border-red-500/30 bg-red-500/[0.02]",
        isSelected && "ring-2 ring-cyan-500/50 bg-cyan-500/[0.02]",
        cardClassName
      )}
    >
      <div className="flex flex-col gap-3">
        <div className="flex items-start justify-between gap-2">
          <div className="flex items-center gap-2 min-w-0">
            {selectable && (
              <Checkbox 
                checked={isSelected}
                onChange={(e) => {
                  // This should be handled by the parent now or via onTaskSelectionChange
                  onTaskSelectionChange?.(isSelected ? [] : [task.id]);
                }}
                onClick={(e) => e.stopPropagation()}
                className="mr-1"
              />
            )}
            {task.blockedBy && task.blockedBy.length > 0 && (
              <Lock className="h-3.5 w-3.5 text-red-500 flex-shrink-0" />
            )}
            <Text className={cn(
              "font-medium text-sm leading-tight group-hover:text-cyan-400 transition-colors truncate",
              task.blockedBy && task.blockedBy.length > 0 && "text-red-400/80"
            )}>
              {task.title}
            </Text>
          </div>
          <div className="flex items-center gap-1">
            {onDelete && (
              <button
                onClick={(e) => {
                  e.stopPropagation();
                  onDelete(task.id);
                }}
                className="p-1 rounded-md hover:bg-red-500/20 text-white/20 hover:text-red-400 transition-colors"
              >
                <Trash2 className="h-3.5 w-3.5" />
              </button>
            )}
            {draggable && <GripVertical className="h-4 w-4 text-white/20 opacity-0 group-hover:opacity-100 transition-opacity flex-shrink-0" />}
          </div>
        </div>

        {task.description && (
          <Text className="text-xs text-white/50 line-clamp-2">
            {task.description}
          </Text>
        )}

        {task.progress !== undefined && (
          <div className="space-y-1.5">
            <div className="flex items-center justify-between text-[10px]">
              <span className="text-white/30 uppercase font-bold tracking-wider">Progress</span>
              <span className="text-white/50">{task.progress}%</span>
            </div>
            <div className="h-1 w-full bg-white/[0.03] rounded-full overflow-hidden">
              <div 
                className="h-full bg-cyan-500 transition-all duration-500" 
                style={{ width: `${task.progress}%` }}
              />
            </div>
          </div>
        )}

        <div className="flex flex-wrap gap-2 mt-1">
          {task.priority && (
            <Badge variant={getPriorityColor(task.priority)} className="text-[10px] px-1.5 py-0 uppercase font-bold">
              {task.priority}
            </Badge>
          )}
          {task.tags?.map(tag => (
            <Badge key={tag} variant="neutral" className="text-[10px] px-1.5 py-0 bg-white/[0.03] border-white/5">
              {tag}
            </Badge>
          ))}
        </div>

        <div className="flex items-center justify-between mt-2 pt-3 border-t border-white/5">
          <div className="flex items-center gap-3 text-[10px] text-white/30">
            {task.timeSpent !== undefined && (
              <div className={cn(
                "flex items-center gap-1 px-1.5 py-0.5 rounded-md transition-colors",
                activeTimerTaskId === task.id ? "bg-cyan-500/20 text-cyan-400" : "bg-white/[0.03]"
              )}>
                {activeTimerTaskId === task.id ? (
                  <Pause 
                    className="h-2.5 w-2.5 cursor-pointer hover:scale-110 transition-transform" 
                    onClick={(e) => {
                      e.stopPropagation();
                      onTaskTimerToggle?.(task.id);
                    }}
                  />
                ) : (
                  <Play 
                    className="h-2.5 w-2.5 cursor-pointer hover:scale-110 transition-transform" 
                    onClick={(e) => {
                      e.stopPropagation();
                      onTaskTimerToggle?.(task.id);
                    }}
                  />
                )}
                <span className="font-mono">
                  {Math.floor(task.timeSpent / 3600)}h {Math.floor((task.timeSpent % 3600) / 60)}m
                </span>
              </div>
            )}
            {task.comments !== undefined && (
              <div className="flex items-center gap-1">
                <MessageSquare className="h-3 w-3" />
                {task.comments}
              </div>
            )}
            {task.attachments !== undefined && (
              <div className="flex items-center gap-1">
                <Paperclip className="h-3 w-3" />
                {task.attachments}
              </div>
            )}
            {task.dueDate && (
              <div className="flex items-center gap-1">
                <Clock className="h-3 w-3" />
                {task.dueDate}
              </div>
            )}
          </div>
          
          {task.assignee && (
            <div className="flex -space-x-2">
              <div className="h-6 w-6 rounded-full border-2 border-[#0a0a0a] bg-white/[0.06] flex items-center justify-center text-[10px] font-bold overflow-hidden">
                {task.assignee.avatar ? (
                  <img src={task.assignee.avatar} alt={task.assignee.name} className="h-full w-full object-cover" />
                ) : (
                  task.assignee.name[0]
                )}
              </div>
            </div>
          )}
        </div>
      </div>
    </Surface>
  );
});

KanbanCard.displayName = 'KanbanCard';



=== FILE: packages\ui\src\components\data-display\kanban\KanbanColumn.tsx ===

import React from 'react';
import { cn } from '../../../utils/cn';
import { Plus, MoreVertical, ChevronDown, ChevronRight } from 'lucide-react';
import { Button } from '../../button/Button';
import { ColumnLimit } from './components/ColumnLimit';
import { KanbanCard } from './KanbanCard';
import type { KanbanColumnDef, KanbanTask } from './types';

interface KanbanColumnProps {
  column: KanbanColumnDef;
  tasks: KanbanTask[];
  onAddTask?: (columnId: string) => void;
  onCollapse?: (columnId: string) => void;
  onTaskClick?: (task: KanbanTask) => void;
  onAction?: (action: string) => void;
  onDragStart?: (e: React.DragEvent, id: string, type: 'task' | 'column') => void;
  onDragOver?: (e: React.DragEvent, taskId?: string) => void;
  onDrop?: (e: React.DragEvent, taskId?: string) => void;
  isCollapsed?: boolean;
  children?: React.ReactNode;
  className?: string;
}

export function KanbanColumn({ 
  column, 
  tasks, 
  onAddTask, 
  onCollapse, 
  onTaskClick,
  onAction,
  onDragStart,
  onDragOver, 
  onDrop, 
  isCollapsed, 
  children,
  className 
}: KanbanColumnProps) {
  return (
    <div 
      className={cn(
        "flex flex-col h-full transition-all duration-300",
        isCollapsed ? "w-12" : "w-80",
        className
      )}
      onDragOver={(e) => onDragOver?.(e)}
      onDrop={(e) => onDrop?.(e)}
      onDragStart={(e) => onDragStart?.(e, column.id, 'column')}
      draggable={!isCollapsed}
    >
      {/* Header */}
      <div className={cn(
        "flex items-center justify-between mb-4 px-2",
        isCollapsed && "flex-col gap-4"
      )}>
        <div className="flex items-center gap-2 min-w-0">
          <button 
            onClick={() => onCollapse?.(column.id)}
            className="p-1 rounded hover:bg-white/5 text-white/40"
          >
            {isCollapsed ? <ChevronRight className="h-4 w-4" /> : <ChevronDown className="h-4 w-4" />}
          </button>
          
          {!isCollapsed && (
            <>
              <div 
                className="h-2 w-2 rounded-full" 
                style={{ backgroundColor: column.color || '#3b82f6' }} 
              />
              <h3 className="font-bold text-sm text-white truncate">{column.title}</h3>
              <span className="text-[10px] font-bold px-1.5 py-0.5 rounded-md bg-white/5 text-white/40">
                {tasks.length}
              </span>
            </>
          )}
        </div>

        {!isCollapsed && (
          <div className="flex items-center gap-1">
            <Button 
              variant="ghost" 
              size="icon" 
              className="h-8 w-8 text-white/40 hover:text-white"
              onClick={() => onAddTask?.(column.id)}
            >
              <Plus className="h-4 w-4" />
            </Button>
            <Button 
              variant="ghost" 
              size="icon" 
              className="h-8 w-8 text-white/40 hover:text-white"
              onClick={() => onAction?.('more')}
            >
              <MoreVertical className="h-4 w-4" />
            </Button>
          </div>
        )}
      </div>

      {/* WIP Limit */}
      {!isCollapsed && column.limit && (
        <div className="px-2 mb-4">
          <ColumnLimit count={tasks.length} limit={column.limit} />
        </div>
      )}

      {/* Content */}
      <div className={cn(
        "flex-1 overflow-y-auto min-h-0 px-2 space-y-3 custom-scrollbar",
        isCollapsed && "hidden"
      )}>
        {children || tasks.map(task => (
          <KanbanCard 
            key={task.id} 
            task={task} 
            onTaskClick={(_, t) => onTaskClick?.(t)}
            onDragStart={(e) => onDragStart?.(e, task.id, 'task')}
            onDragOver={(e) => onDragOver?.(e, task.id)}
            onDrop={(e) => onDrop?.(e, task.id)}
          />
        ))}
      </div>

      {/* Collapsed Label */}
      {isCollapsed && (
        <div className="flex-1 flex items-center justify-center">
          <span className="rotate-90 whitespace-nowrap text-[10px] font-bold uppercase tracking-widest text-white/20">
            {column.title}
          </span>
        </div>
      )}
    </div>
  );
}



=== FILE: packages\ui\src\components\data-display\kanban\KanbanColumnContent.tsx ===

import React from 'react';
import { Plus, LayoutGrid } from 'lucide-react';
import { Button } from '../../button/Button';
import { Text } from '../../typography/Text';
import { cn } from '../../../utils/cn';
import type { KanbanTask, KanbanColumnDef, DropPosition } from './types';
import { KanbanCard } from './KanbanCard';

interface KanbanColumnContentProps {
  column: KanbanColumnDef;
  columnMap: Record<string, KanbanTask[]>;
  groupName: string;
  visibleCount: number;
  pageSize: number;
  columnHeight?: number | string;
  draggedTaskId: string | null;
  draggedColumnId: string | null;
  dragOverTaskId: string | null;
  dragOverColumnId: string | null;
  dropPosition: DropPosition | null;
  quickAddColumnId: string | null;
  quickAddValue: string;
  selectedTaskIds: string[];
  activeTimerTaskId?: string | null;
  handleDragStart: (e: React.DragEvent, id: string, type: 'task' | 'column') => void;
  handleDragEnd: () => void;
  handleDragOver: (e: React.DragEvent, columnId: string, taskId?: string) => void;
  handleDrop: (e: React.DragEvent, toColumnId: string, toTaskId?: string) => void;
  handleTouchStart: (e: React.TouchEvent, id: string, type: 'task' | 'column') => void;
  handleTouchMove: (e: React.TouchEvent) => void;
  handleTouchEnd: (e: React.TouchEvent) => void;
  handleKeyDown: (e: React.KeyboardEvent, taskId: string, columnId: string) => void;
  handleLoadMore: (columnId: string) => void;
  handleSetQuickAdd: (columnId: string, groupName?: string) => void;
  handleQuickAdd: (columnId: string, groupName?: string) => void;
  setQuickAddValue: (value: string) => void;
  setQuickAddColumnId: (id: string | null) => void;
  onTaskClick: (e: React.MouseEvent, task: KanbanTask) => void;
  onTaskFullAdd?: (columnId: string) => void;
  onTaskRemove?: (taskId: string) => void;
  onTaskTimerToggle?: (taskId: string) => void;
  onTaskSelectionChange?: (selectedIds: string[]) => void;
  renderCard?: (task: KanbanTask) => React.ReactNode;
  selectable?: boolean;
  cardClassName?: string;
}

export const KanbanColumnContent = ({
  column,
  columnMap,
  groupName,
  visibleCount,
  pageSize,
  draggedTaskId,
  draggedColumnId,
  dragOverTaskId,
  dragOverColumnId,
  dropPosition,
  quickAddColumnId,
  quickAddValue,
  selectedTaskIds,
  activeTimerTaskId,
  handleDragStart,
  handleDragEnd,
  handleDragOver,
  handleDrop,
  handleTouchStart,
  handleTouchMove,
  handleTouchEnd,
  handleKeyDown,
  handleLoadMore,
  handleSetQuickAdd,
  handleQuickAdd,
  setQuickAddValue,
  setQuickAddColumnId,
  onTaskClick,
  onTaskFullAdd,
  onTaskRemove,
  onTaskTimerToggle,
  onTaskSelectionChange,
  renderCard,
  selectable,
  cardClassName
}: KanbanColumnContentProps) => {
  const columnTasks = columnMap[column.id] || [];
  const visibleTasks = columnTasks.slice(0, visibleCount);
  const hasMore = columnTasks.length > visibleCount;

  return (
    <div className="flex flex-col gap-4 h-full min-h-0">
      {/* Quick Add Input */}
      {quickAddColumnId === `${groupName}-${column.id}` ? (
        <div className="p-4 bg-white/[0.03] border border-cyan-500/30 rounded-2xl animate-in fade-in slide-in-from-top-2 duration-200">
          <input
            autoFocus
            className="w-full bg-transparent border-none outline-none text-sm text-white placeholder:text-white/20"
            placeholder="Task title..."
            value={quickAddValue}
            onChange={(e) => setQuickAddValue(e.target.value)}
            onKeyDown={(e) => {
              if (e.key === 'Enter') handleQuickAdd(column.id, groupName);
              if (e.key === 'Escape') setQuickAddColumnId(null);
            }}
            onBlur={() => {
              if (!quickAddValue.trim()) setQuickAddColumnId(null);
            }}
          />
          <div className="flex items-center justify-between mt-3">
            <Text className="text-[10px] text-white/30 uppercase font-bold">Press Enter to save</Text>
            <div className="flex gap-1">
              <Button 
                variant="ghost" 
                size="sm" 
                className="h-7 px-2 text-[10px] hover:bg-white/[0.06]"
                onClick={() => setQuickAddColumnId(null)}
              >
                Cancel
              </Button>
              <Button 
                variant="primary" 
                size="sm" 
                className="h-7 px-3 text-[10px] bg-cyan-500 hover:bg-cyan-400 text-black font-bold"
                onClick={() => handleQuickAdd(column.id, groupName)}
              >
                Add Task
              </Button>
            </div>
          </div>
        </div>
      ) : (
        <button 
          onClick={() => handleSetQuickAdd(column.id, groupName)}
          className="group/add flex items-center justify-center gap-2 p-4 border border-dashed border-white/10 hover:border-cyan-500/30 hover:bg-cyan-500/[0.02] rounded-2xl transition-all duration-200"
        >
          <Plus className="h-4 w-4 text-white/20 group-hover/add:text-cyan-400 transition-colors" />
          <Text className="text-xs font-bold text-white/20 group-hover/add:text-cyan-400 uppercase tracking-widest transition-colors">
            Add New Task
          </Text>
        </button>
      )}

      {/* Tasks List */}
      <div 
        role="list"
        aria-label={`Tasks in ${column.title}`}
        className="flex-1 overflow-y-auto pr-2 custom-scrollbar flex flex-col gap-4 min-h-0 pb-20"
      >
        {visibleTasks.map((task) => (
          <React.Fragment key={task.id}>
            {/* Task Ghost Placeholder TOP */}
            {draggedTaskId && dragOverTaskId === task.id && dropPosition === 'top' && draggedTaskId !== task.id && (
              <div className="h-1 bg-cyan-500/50 rounded-full animate-pulse" />
            )}

            <div
              draggable
              role="listitem"
              aria-label={`Task: ${task.title}`}
              onDragStart={(e) => handleDragStart(e, task.id, 'task')}
              onDragEnd={handleDragEnd}
              onDragOver={(e) => handleDragOver(e, column.id, task.id)}
              onDrop={(e) => handleDrop(e, column.id, task.id)}
              onTouchStart={(e) => handleTouchStart(e, task.id, 'task')}
              onTouchMove={handleTouchMove}
              onTouchEnd={handleTouchEnd}
              onKeyDown={(e) => handleKeyDown(e, task.id, column.id)}
              tabIndex={0}
              data-task-id={task.id}
              className={cn(
                "outline-none transition-all duration-200",
                draggedTaskId === task.id ? "opacity-20 scale-95" : "opacity-100 scale-100",
                dragOverTaskId === task.id && draggedTaskId ? "ring-2 ring-cyan-500/30 rounded-2xl" : ""
              )}
            >
              <KanbanCard 
                task={task}
                isSelected={selectedTaskIds.includes(task.id)}
                activeTimerTaskId={activeTimerTaskId}
                selectable={selectable}
                cardClassName={cardClassName}
                onTaskClick={onTaskClick}
                onTaskSelectionChange={onTaskSelectionChange}
                onDelete={onTaskRemove}
                onTaskTimerToggle={onTaskTimerToggle}
                renderCard={renderCard}
              />
            </div>

            {/* Task Ghost Placeholder BOTTOM */}
            {draggedTaskId && dragOverTaskId === task.id && dropPosition === 'bottom' && draggedTaskId !== task.id && (
              <div className="h-1 bg-cyan-500/50 rounded-full animate-pulse" />
            )}
          </React.Fragment>
        ))}

        {/* Load More Trigger */}
        {hasMore && (
          <button
            onClick={() => handleLoadMore(column.id)}
            className="flex items-center justify-center gap-2 p-4 text-white/30 hover:text-cyan-400 transition-colors"
          >
            <Plus className="h-4 w-4" />
            <span className="text-xs font-bold uppercase tracking-widest">
              Load {columnTasks.length - visibleCount} more tasks
            </span>
          </button>
        )}

        {/* Empty State */}
        {columnTasks.length === 0 && !draggedTaskId && (
          <div className="flex flex-col items-center justify-center py-12 px-4 border border-dashed border-white/5 rounded-[2rem] opacity-20">
            <LayoutGrid className="h-8 w-8 mb-3" />
            <Text className="text-xs font-medium">No tasks yet</Text>
          </div>
        )}

        {/* Drop Zone for empty column */}
        {columnTasks.length === 0 && draggedTaskId && (
          <div 
            className="flex-1 min-h-[200px] border-2 border-dashed border-cyan-500/20 rounded-[2rem] bg-cyan-500/[0.02] flex items-center justify-center"
            onDragOver={(e) => handleDragOver(e, column.id)}
            onDrop={(e) => handleDrop(e, column.id)}
          >
            <Text className="text-xs font-bold text-cyan-500/40 uppercase tracking-widest">Drop here</Text>
          </div>
        )}
      </div>
    </div>
  );
};



=== FILE: packages\ui\src\components\data-display\kanban\KanbanFilterBar.tsx ===

import React, { useState } from 'react';
import { Search, Filter, X, ChevronDown, Check, SortAsc, Layout, List, Calendar, Clock } from 'lucide-react';
import { cn } from '../../../utils/cn';
import { Surface } from '../../../primitives/Surface';
import { Button } from '../../button/Button';
import { Badge } from '../../../primitives/Badge';
import { Popover, PopoverTrigger, PopoverContent } from '../../overlay/Popover';
import { Command, CommandInput, CommandList, CommandItem, CommandGroup } from '../../overlay/Command';
import type { FilterOption, SavedFilter } from './types';

export interface KanbanFilterBarProps {
  onSearchChange?: (query: string) => void;
  onFilterChange?: (filters: Record<string, string[]>) => void;
  onSortChange?: (sortBy: string, order: 'asc' | 'desc') => void;
  onViewChange?: (view: string) => void;
  onGroupChange?: (groupBy: string) => void;
  priorityOptions?: FilterOption[];
  tagOptions?: FilterOption[];
  assigneeOptions?: FilterOption[];
  viewOptions?: ('board' | 'list' | 'calendar' | 'timeline')[];
  sortOptions?: FilterOption[];
  groupOptions?: FilterOption[];
  savedFilters?: SavedFilter[];
  onSaveFilter?: (filter: SavedFilter) => void;
  className?: string;
}

export function KanbanFilterBar({
  onSearchChange,
  onFilterChange,
  onSortChange,
  onViewChange,
  onGroupChange,
  priorityOptions = [],
  tagOptions = [],
  assigneeOptions = [],
  viewOptions = ['board', 'list', 'calendar', 'timeline'],
  sortOptions = [],
  groupOptions = [],
  savedFilters = [],
  onSaveFilter,
  className
}: KanbanFilterBarProps) {
  const [search, setSearch] = useState('');
  const [activeFilters, setActiveFilters] = useState<Record<string, string[]>>({});
  const [currentView, setCurrentView] = useState('board');

  const toggleFilter = (category: string, value: string) => {
    const current = activeFilters[category] || [];
    const next = current.includes(value)
      ? current.filter(v => v !== value)
      : [...current, value];
    
    const newFilters = { ...activeFilters, [category]: next };
    if (next.length === 0) delete newFilters[category];
    
    setActiveFilters(newFilters);
    onFilterChange?.(newFilters);
  };

  const clearFilters = () => {
    setActiveFilters({});
    onFilterChange?.({});
    setSearch('');
    onSearchChange?.('');
  };

  const activeCount = Object.values(activeFilters).flat().length;

  return (
    <Surface className={cn("p-2 flex flex-wrap items-center gap-3 bg-white/[0.02] border-white/5", className)}>
      <div className="relative flex-1 min-w-[200px]">
        <Search className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-white/20" />
        <input 
          type="text"
          placeholder="Search tasks..."
          className="w-full pl-10 pr-4 py-2 text-sm rounded-2xl border border-white/10 bg-white/[0.03] focus:outline-none focus:ring-2 focus:ring-blue-500/50 transition-all placeholder:text-white/20 text-white"
          value={search}
          onChange={(e) => {
            setSearch(e.target.value);
            onSearchChange?.(e.target.value);
          }}
        />
      </div>

      <div className="flex items-center gap-2">
        <FilterPopover 
          label="Priority" 
          options={priorityOptions} 
          selected={activeFilters['priority'] || []}
          onSelect={(val) => toggleFilter('priority', val)}
        />

        <FilterPopover 
          label="Tags" 
          options={tagOptions} 
          selected={activeFilters['tags'] || []}
          onSelect={(val) => toggleFilter('tags', val)}
        />

        <FilterPopover 
          label="Assignee" 
          options={assigneeOptions} 
          selected={activeFilters['assignee'] || []}
          onSelect={(val) => toggleFilter('assignee', val)}
        />

        <div className="w-px h-4 bg-white/10 mx-1" />

        <Popover>
          <PopoverTrigger>
            <Button variant="ghost" size="sm" className="h-9 gap-2 text-white/60">
              <SortAsc className="h-4 w-4" />
              Sort
            </Button>
          </PopoverTrigger>
          <PopoverContent className="w-48 p-1 bg-gray-900 border-white/10">
            {sortOptions.map(opt => (
              <button
                key={opt.value}
                className="w-full flex items-center gap-2 px-3 py-2 text-xs text-white/60 hover:text-white hover:bg-white/5 rounded-lg text-left"
                onClick={() => onSortChange?.(opt.value, 'asc')}
              >
                {opt.label}
              </button>
            ))}
          </PopoverContent>
        </Popover>

        {activeCount > 0 && (
          <Button 
            variant="ghost" 
            size="sm" 
            onClick={clearFilters}
            className="h-9 px-3 text-xs text-white/40 hover:text-white gap-2"
          >
            <X className="h-3.5 w-3.5" /> Clear
            <Badge variant="neutral" className="bg-white/[0.06] border-white/10 ml-1">
              {activeCount}
            </Badge>
          </Button>
        )}
      </div>
    </Surface>
  );
}

function FilterPopover({ label, options, selected, onSelect }: { 
  label: string, 
  options: FilterOption[], 
  selected: string[],
  onSelect: (val: string) => void 
}) {
  return (
    <Popover>
      <PopoverTrigger>
        <Button 
          variant="ghost" 
          size="sm" 
          className={cn(
            "h-9 gap-2 text-xs transition-all",
            selected.length > 0 ? "bg-blue-500/10 text-blue-400" : "text-white/60 hover:text-white"
          )}
        >
          {label}
          {selected.length > 0 ? (
            <Badge variant="info" className="h-4 min-w-[16px] px-1 bg-blue-500 text-white border-none">
              {selected.length}
            </Badge>
          ) : (
            <ChevronDown className="h-3.5 w-3.5 opacity-40" />
          )}
        </Button>
      </PopoverTrigger>
      <PopoverContent className="w-56 p-0 bg-gray-900 border-white/10 shadow-2xl">
        <Command>
          <CommandInput placeholder={`Search ${label.toLowerCase()}...`} className="border-none" />
          <CommandList className="max-h-[240px]">
            <CommandGroup>
              {options.map((option) => (
                <CommandItem
                  key={option.value}
                  value={option.value}
                  onClick={() => onSelect(option.value)}
                  className="flex items-center justify-between py-2 px-3 cursor-pointer hover:bg-white/5"
                >
                  <span className="text-xs text-white/80">{option.label}</span>
                  {selected.includes(option.value) && (
                    <Check className="h-3.5 w-3.5 text-blue-500" />
                  )}
                </CommandItem>
              ))}
            </CommandGroup>
          </CommandList>
        </Command>
      </PopoverContent>
    </Popover>
  );
}



=== FILE: packages\ui\src\components\data-display\kanban\KanbanHeader.tsx ===

import React from 'react';
import { cn } from '../../../utils/cn';
import { Layout, List, Calendar, Clock, Filter, SortAsc, MoreHorizontal, Plus, Undo2, Redo2 } from 'lucide-react';
import { Button } from '../../button/Button';

interface KanbanHeaderProps {
  title: string;
  view?: string;
  onViewChange?: (view: string) => void;
  onFilter?: () => void;
  onSort?: () => void;
  onAddColumn?: () => void;
  canUndo?: boolean;
  canRedo?: boolean;
  onUndo?: () => void;
  onRedo?: () => void;
  className?: string;
}

export function KanbanHeader({ 
  title, 
  view = 'board', 
  onViewChange, 
  onFilter, 
  onSort, 
  onAddColumn,
  canUndo,
  canRedo,
  onUndo,
  onRedo,
  className 
}: KanbanHeaderProps) {
  const views = [
    { id: 'board', icon: Layout, label: 'Board' },
    { id: 'list', icon: List, label: 'List' },
    { id: 'calendar', icon: Calendar, label: 'Calendar' },
    { id: 'timeline', icon: Clock, label: 'Timeline' },
  ];

  return (
    <div className={cn("flex items-center justify-between mb-8", className)}>
      <div className="flex items-center gap-6">
        <h1 className="text-2xl font-bold text-white tracking-tight">{title}</h1>
        
        <div className="flex items-center bg-white/5 rounded-xl p-1">
          {views.map((v) => (
            <button
              key={v.id}
              onClick={() => onViewChange?.(v.id)}
              className={cn(
                "flex items-center gap-2 px-3 py-1.5 rounded-lg text-xs font-medium transition-all",
                view === v.id 
                  ? "bg-white/10 text-white shadow-lg" 
                  : "text-white/40 hover:text-white/60"
              )}
            >
              <v.icon className="h-3.5 w-3.5" />
              {v.label}
            </button>
          ))}
        </div>
      </div>

      <div className="flex items-center gap-2">
        <div className="flex items-center gap-1 mr-2">
          <Button 
            variant="ghost" 
            size="icon" 
            onClick={onUndo} 
            disabled={!canUndo}
            className="h-8 w-8 text-white/40 disabled:opacity-20"
          >
            <Undo2 className="h-4 w-4" />
          </Button>
          <Button 
            variant="ghost" 
            size="icon" 
            onClick={onRedo} 
            disabled={!canRedo}
            className="h-8 w-8 text-white/40 disabled:opacity-20"
          >
            <Redo2 className="h-4 w-4" />
          </Button>
        </div>

        <Button variant="ghost" size="sm" onClick={onFilter} className="gap-2 text-white/60">
          <Filter className="h-4 w-4" />
          Filter
        </Button>
        <Button variant="ghost" size="sm" onClick={onSort} className="gap-2 text-white/60">
          <SortAsc className="h-4 w-4" />
          Sort
        </Button>
        <div className="w-px h-4 bg-white/10 mx-2" />
        <Button size="sm" onClick={onAddColumn} className="gap-2">
          <Plus className="h-4 w-4" />
          Add Column
        </Button>
        <Button variant="ghost" size="icon" className="h-9 w-9 text-white/40">
          <MoreHorizontal className="h-4 w-4" />
        </Button>
      </div>
    </div>
  );
}



=== FILE: packages\ui\src\components\data-display\kanban\KanbanListView.tsx ===

import React from 'react';
import { cn } from '../../../utils/cn';
import { Table, TableHeader, TableBody, TableRow, TableHead, TableCell } from '../Table';
import { Badge } from '../../../primitives/Badge';
import { Avatar } from '../Avatar';
import type { KanbanTask, KanbanColumnDef } from './types';

interface KanbanListViewProps {
  tasks: KanbanTask[];
  columns: KanbanColumnDef[];
  onTaskClick?: (task: KanbanTask) => void;
  className?: string;
}

export function KanbanListView({ tasks, columns, onTaskClick, className }: KanbanListViewProps) {
  const getColumn = (id: string) => columns.find(c => c.id === id);

  return (
    <div className={cn("bg-white/[0.02] border border-white/5 rounded-2xl overflow-hidden", className)}>
      <Table>
        <TableHeader>
          <TableRow className="hover:bg-transparent border-white/5">
            <TableHead className="text-white/40 uppercase text-[10px] font-bold">Task</TableHead>
            <TableHead className="text-white/40 uppercase text-[10px] font-bold">Status</TableHead>
            <TableHead className="text-white/40 uppercase text-[10px] font-bold">Priority</TableHead>
            <TableHead className="text-white/40 uppercase text-[10px] font-bold">Assignee</TableHead>
            <TableHead className="text-white/40 uppercase text-[10px] font-bold">Due Date</TableHead>
          </TableRow>
        </TableHeader>
        <TableBody>
          {tasks.map((task) => {
            const column = getColumn(task.columnId);
            return (
              <TableRow 
                key={task.id} 
                className="border-white/5 hover:bg-white/[0.03] cursor-pointer transition-colors"
                onClick={() => onTaskClick?.(task)}
              >
                <TableCell className="font-medium text-white">{task.title}</TableCell>
                <TableCell>
                  <div className="flex items-center gap-2">
                    <div className="h-2 w-2 rounded-full" style={{ backgroundColor: column?.color || '#3b82f6' }} />
                    <span className="text-xs text-white/60">{column?.title}</span>
                  </div>
                </TableCell>
                <TableCell>
                  <Badge 
                    variant={task.priority === 'urgent' ? 'danger' : task.priority === 'high' ? 'warning' : 'info'}
                    className="text-[10px] uppercase"
                  >
                    {task.priority || 'medium'}
                  </Badge>
                </TableCell>
                <TableCell>
                  {task.assignee && (
                    <div className="flex items-center gap-2">
                      <Avatar src={task.assignee.avatar} alt={task.assignee.name} size="sm" />
                      <span className="text-xs text-white/60">{task.assignee.name}</span>
                    </div>
                  )}
                </TableCell>
                <TableCell className="text-xs text-white/40">
                  {task.dueDate ? new Date(task.dueDate).toLocaleDateString() : '-'}
                </TableCell>
              </TableRow>
            );
          })}
        </TableBody>
      </Table>
    </div>
  );
}



=== FILE: packages\ui\src\components\data-display\kanban\KanbanQuickAdd.tsx ===

import React, { useState } from 'react';
import { cn } from '../../../utils/cn';
import { Plus, X } from 'lucide-react';
import { Button } from '../../button/Button';

interface KanbanQuickAddProps {
  columnId: string;
  onAdd: (columnId: string, title: string) => void;
  placeholder?: string;
  className?: string;
}

export function KanbanQuickAdd({ columnId, onAdd, placeholder = "Add task...", className }: KanbanQuickAddProps) {
  const [isAdding, setIsAdding] = useState(false);
  const [title, setTitle] = useState('');

  const handleSubmit = (e?: React.FormEvent) => {
    e?.preventDefault();
    if (!title.trim()) return;
    onAdd(columnId, title);
    setTitle('');
    setIsAdding(false);
  };

  if (!isAdding) {
    return (
      <button
        onClick={() => setIsAdding(true)}
        className={cn(
          "w-full flex items-center gap-2 p-3 rounded-2xl border border-dashed border-white/10 text-white/40 hover:border-white/20 hover:bg-white/5 transition-all text-sm",
          className
        )}
      >
        <Plus className="h-4 w-4" />
        {placeholder}
      </button>
    );
  }

  return (
    <form 
      onSubmit={handleSubmit}
      className={cn("bg-white/[0.03] border border-white/10 rounded-2xl p-3 space-y-3", className)}
    >
      <input
        autoFocus
        value={title}
        onChange={(e) => setTitle(e.target.value)}
        placeholder="What needs to be done?"
        className="w-full bg-transparent border-none outline-none text-sm text-white placeholder:text-white/20"
        onKeyDown={(e) => {
          if (e.key === 'Escape') setIsAdding(false);
        }}
      />
      <div className="flex items-center justify-end gap-2">
        <Button 
          variant="ghost" 
          size="sm" 
          onClick={() => setIsAdding(false)}
          className="h-8 text-white/40 hover:text-white"
        >
          Cancel
        </Button>
        <Button 
          size="sm" 
          onClick={() => handleSubmit()}
          disabled={!title.trim()}
          className="h-8"
        >
          Add Task
        </Button>
      </div>
    </form>
  );
}



=== FILE: packages\ui\src\components\data-display\kanban\KanbanSwimlane.tsx ===

import React from 'react';
import { cn } from '../../../utils/cn';
import { ChevronDown, ChevronRight } from 'lucide-react';

interface KanbanSwimlaneProps {
  title: string;
  count: number;
  isCollapsed?: boolean;
  onToggle?: () => void;
  children: React.ReactNode;
  className?: string;
}

export function KanbanSwimlane({ 
  title, 
  count, 
  isCollapsed, 
  onToggle, 
  children, 
  className 
}: KanbanSwimlaneProps) {
  return (
    <div className={cn("space-y-4", className)}>
      <button 
        onClick={onToggle}
        className="flex items-center gap-3 w-full group"
      >
        <div className="flex items-center gap-2">
          {isCollapsed ? <ChevronRight className="h-4 w-4 text-white/20" /> : <ChevronDown className="h-4 w-4 text-white/20" />}
          <h4 className="text-xs font-bold uppercase tracking-widest text-white/40 group-hover:text-white/60 transition-colors">
            {title}
          </h4>
        </div>
        <div className="h-px flex-1 bg-white/5" />
        <span className="text-[10px] font-bold px-2 py-0.5 rounded-full bg-white/5 text-white/20">
          {count}
        </span>
      </button>

      {!isCollapsed && (
        <div className="animate-in fade-in slide-in-from-top-2 duration-300">
          {children}
        </div>
      )}
    </div>
  );
}



=== FILE: packages\ui\src\components\data-display\kanban\KanbanTableView.tsx ===

import React from 'react';
import { cn } from '../../../utils/cn';
import { KanbanListView } from './KanbanListView';
import type { KanbanTask, KanbanColumnDef } from './types';

interface KanbanTableViewProps {
  tasks: KanbanTask[];
  columns: KanbanColumnDef[];
  onTaskClick?: (task: KanbanTask) => void;
  className?: string;
}

export function KanbanTableView({ tasks, columns, onTaskClick, className }: KanbanTableViewProps) {
  // Table view is essentially a more detailed list view
  return <KanbanListView tasks={tasks} columns={columns} onTaskClick={onTaskClick} className={className} />;
}



=== FILE: packages\ui\src\components\data-display\kanban\KanbanTaskModal.tsx ===

import React, { useState, useEffect } from 'react';
import { Modal, ModalHeader, ModalTitle, ModalFooter } from '../../overlay/Modal';
import { Button } from '../../button/Button';
import { TextInput } from '../../form/TextInput';
import { Textarea } from '../../form/Textarea';
import { Select } from '../../form/Select';
import { Label } from '../../form/Label';
import { FileDropzone } from '../../form/FileDropzone';
import { X, Paperclip, Tag, AlertCircle, Trash2, Copy, Archive, Clock } from 'lucide-react';
import { SubtaskList } from './components/SubtaskList';
import { Checklist } from './components/Checklist';
import { TaskActivity } from './components/TaskActivity';
import { TaskComments } from './components/TaskComments';
import { TaskAttachments } from './components/TaskAttachments';
import { LabelPicker } from './components/LabelPicker';
import { AssigneePicker } from './components/AssigneePicker';
import { DueDatePicker } from './components/DueDatePicker';
import { TimeTracker } from './components/TimeTracker';
import type { KanbanTask, KanbanColumnDef, KanbanUser, KanbanLabel } from './types';

export interface KanbanTaskModalProps {
  isOpen: boolean;
  onClose: () => void;
  onSave: (task: Partial<KanbanTask>) => void;
  onDelete?: (taskId: string) => void;
  onDuplicate?: (task: KanbanTask) => void;
  onArchive?: (taskId: string) => void;
  task?: KanbanTask;
  columnId?: string;
  columns?: KanbanColumnDef[];
  users?: KanbanUser[];
  availableLabels?: KanbanLabel[];
  showSubtasks?: boolean;
  showChecklist?: boolean;
  showAttachments?: boolean;
  showComments?: boolean;
  showActivity?: boolean;
}

export function KanbanTaskModal({ 
  isOpen, 
  onClose, 
  onSave, 
  onDelete,
  onDuplicate,
  onArchive,
  task, 
  columnId,
  columns = [],
  users = [],
  availableLabels = [],
  showSubtasks = true,
  showChecklist = true,
  showAttachments = true,
  showComments = true,
  showActivity = true
}: KanbanTaskModalProps) {
  const [title, setTitle] = useState('');
  const [description, setDescription] = useState('');
  const [priority, setPriority] = useState<'low' | 'medium' | 'high' | 'urgent'>('medium');
  const [currentColumnId, setCurrentColumnId] = useState('');
  const [assigneeId, setAssigneeId] = useState<string | undefined>(undefined);
  const [selectedLabels, setSelectedLabels] = useState<string[]>([]);
  const [dueDate, setDueDate] = useState<Date | undefined>(undefined);

  useEffect(() => {
    if (task) {
      setTitle(task.title || '');
      setDescription(task.description || '');
      setPriority(task.priority || 'medium');
      setCurrentColumnId(task.columnId || '');
      setAssigneeId(task.assignee?.id);
      setSelectedLabels(task.labels?.map(l => l.id) || []);
      setDueDate(task.dueDate ? new Date(task.dueDate) : undefined);
    } else {
      setTitle('');
      setDescription('');
      setPriority('medium');
      setCurrentColumnId(columnId || '');
      setAssigneeId(undefined);
      setSelectedLabels([]);
      setDueDate(undefined);
    }
  }, [task, isOpen, columnId]);

  const handleSave = () => {
    if (!title.trim()) return;
    onSave({
      ...task,
      title,
      description,
      priority,
      columnId: currentColumnId,
      assignee: users.find(u => u.id === assigneeId),
      labels: availableLabels.filter(l => selectedLabels.includes(l.id)),
      dueDate: dueDate?.toISOString()
    });
    onClose();
  };

  return (
    <Modal isOpen={isOpen} onClose={onClose}>
      <ModalHeader className="flex items-center justify-between pr-12">
        <ModalTitle>{task ? 'Edit Task' : 'Create New Task'}</ModalTitle>
        <div className="flex items-center gap-2">
          {task && (
            <>
              <Button variant="ghost" size="icon" className="h-8 w-8 text-white/40 hover:text-white" onClick={() => onDuplicate?.(task)}>
                <Copy className="h-4 w-4" />
              </Button>
              <Button variant="ghost" size="icon" className="h-8 w-8 text-white/40 hover:text-white" onClick={() => onArchive?.(task.id)}>
                <Archive className="h-4 w-4" />
              </Button>
              <Button variant="ghost" size="icon" className="h-8 w-8 text-white/40 hover:text-red-400" onClick={() => onDelete?.(task.id)}>
                <Trash2 className="h-4 w-4" />
              </Button>
            </>
          )}
        </div>
      </ModalHeader>
      
      <div className="grid grid-cols-1 lg:grid-cols-3 gap-8 py-6">
        {/* Main Content */}
        <div className="lg:col-span-2 space-y-8">
          <div className="space-y-2">
            <Label htmlFor="task-title" className="text-[10px] uppercase tracking-wider text-white/40 font-bold">Title</Label>
            <TextInput 
              id="task-title"
              placeholder="What needs to be done?" 
              value={title}
              onChange={(e) => setTitle(e.target.value)}
              className="text-lg font-bold bg-transparent border-white/10 focus:border-blue-500"
              autoFocus
            />
          </div>

          <div className="space-y-2">
            <Label htmlFor="task-desc" className="text-[10px] uppercase tracking-wider text-white/40 font-bold">Description</Label>
            <Textarea 
              id="task-desc"
              placeholder="Add more details..." 
              value={description}
              onChange={(e) => setDescription(e.target.value)}
              rows={6}
              className="bg-white/[0.03] border-white/10 text-sm leading-relaxed"
            />
          </div>

          {showChecklist && task?.checklist && (
            <Checklist items={task.checklist} />
          )}

          {showAttachments && task?.attachments && (
            <TaskAttachments attachments={[]} />
          )}

          {showComments && (
            <TaskComments comments={[]} />
          )}
        </div>

        {/* Sidebar */}
        <div className="space-y-8 bg-white/[0.02] p-6 rounded-3xl border border-white/5 h-fit">
          <div className="space-y-2">
            <Label className="text-[10px] uppercase tracking-wider text-white/40 font-bold">Status</Label>
            <Select 
              value={currentColumnId}
              onChange={(val) => setCurrentColumnId(val)}
              options={columns.map(c => ({ label: c.title, value: c.id }))}
              className="bg-white/5 border-white/10"
            />
          </div>

          <div className="space-y-2">
            <Label className="text-[10px] uppercase tracking-wider text-white/40 font-bold">Priority</Label>
            <Select 
              value={priority}
              onChange={(val) => setPriority(val as any)}
              options={[
                { label: 'Low', value: 'low' },
                { label: 'Medium', value: 'medium' },
                { label: 'High', value: 'high' },
                { label: 'Urgent', value: 'urgent' },
              ]}
              className="bg-white/5 border-white/10"
            />
          </div>

          <AssigneePicker 
            users={users} 
            selectedId={assigneeId} 
            onSelect={setAssigneeId} 
          />

          <LabelPicker 
            labels={availableLabels} 
            selectedIds={selectedLabels} 
            onToggle={(id) => setSelectedLabels(prev => prev.includes(id) ? prev.filter(i => i !== id) : [...prev, id])} 
          />

          <DueDatePicker 
            date={dueDate} 
            onChange={setDueDate} 
          />

          <TimeTracker initialSeconds={task?.timeSpent} />
        </div>
      </div>

      <ModalFooter className="border-t border-white/5 pt-6">
        <Button variant="ghost" onClick={onClose}>Cancel</Button>
        <Button onClick={handleSave} className="px-8">Save Changes</Button>
      </ModalFooter>
    </Modal>
  );
}



=== FILE: packages\ui\src\components\data-display\kanban\KanbanTimelineView.tsx ===

import React from 'react';
import { cn } from '../../../utils/cn';
import type { KanbanTask } from './types';

interface KanbanTimelineViewProps {
  tasks: KanbanTask[];
  className?: string;
}

export function KanbanTimelineView({ tasks, className }: KanbanTimelineViewProps) {
  // Simplified timeline view for now
  return (
    <div className={cn("p-8 bg-white/[0.02] border border-white/5 rounded-2xl flex flex-col items-center justify-center min-h-[400px]", className)}>
      <div className="h-12 w-12 rounded-full bg-blue-500/10 flex items-center justify-center mb-4">
        <div className="h-6 w-6 border-2 border-blue-500 border-t-transparent rounded-full animate-spin" />
      </div>
      <h3 className="text-lg font-bold text-white mb-2">Timeline View</h3>
      <p className="text-sm text-white/40 text-center max-w-xs">
        The timeline view is currently being optimized for high-performance rendering of {tasks.length} tasks.
      </p>
    </div>
  );
}



=== FILE: packages\ui\src\components\data-display\kanban\types.ts ===

import type { ReactNode } from 'react';

export interface KanbanUser {
  id: string;
  name: string;
  avatar?: string;
  status?: 'online' | 'offline' | 'away' | 'busy';
}

export interface Subtask {
  id: string;
  title: string;
  completed: boolean;
}

export interface ChecklistItem {
  id: string;
  title: string;
  completed: boolean;
}

export interface KanbanLabel {
  id: string;
  name: string;
  color: string;
}

export interface KanbanTask {
  id: string;
  columnId: string;
  title: string;
  description?: string;
  priority?: 'low' | 'medium' | 'high' | 'urgent';
  tags?: string[];
  assignee?: KanbanUser;
  dueDate?: string;
  progress?: number;
  comments?: number;
  attachments?: number;
  timeSpent?: number; // in seconds
  blockedBy?: string[];
  createdAt?: Date;
  updatedAt?: Date;
  createdBy?: KanbanUser;
  subtasks?: Subtask[];
  checklist?: ChecklistItem[];
  estimatedTime?: number;
  customFields?: Record<string, any>;
  labels?: KanbanLabel[];
  watchers?: KanbanUser[];
  order?: number;
  archived?: boolean;
  parentId?: string;
  [key: string]: any;
}

export interface KanbanColumnDef {
  id: string;
  title: string;
  color?: string;
  limit?: number;
  description?: string;
  isCollapsed?: boolean;
  order?: number;
  icon?: ReactNode;
  autoMove?: {
    when: 'overdue' | 'completed';
    toColumnId: string;
  };
}

export type DropPosition = 'top' | 'bottom' | 'left' | 'right';

export interface KanbanProps {
  columns: KanbanColumnDef[];
  tasks: KanbanTask[];
  onTaskMove?: (taskId: string, toColumnId: string, toTaskId?: string, position?: 'top' | 'bottom') => void;
  onColumnMove?: (columnId: string, toColumnId: string, position?: 'left' | 'right') => void;
  onTaskClick?: (task: KanbanTask) => void;
  onTaskAdd?: (columnId: string, title: string) => void;
  onTaskFullAdd?: (columnId: string) => void;
  onTaskRemove?: (taskId: string) => void;
  onColumnAction?: (columnId: string, action: string) => void;
  onTaskDrop?: (taskId: string, fromColumnId: string, toColumnId: string, index: number) => void;
  onTaskDragStart?: (taskId: string) => void;
  onTaskDragEnd?: (taskId: string) => void;
  onTaskSelectionChange?: (selectedIds: string[]) => void;
  onTaskTimerToggle?: (taskId: string) => void;
  onColumnAdd?: () => void;
  onColumnEdit?: (columnId: string) => void;
  onColumnDelete?: (columnId: string) => void;
  onColumnCollapse?: (columnId: string) => void;
  collapsedColumns?: string[];
  onBulkAction?: (taskIds: string[], action: string) => void;
  sortBy?: 'priority' | 'dueDate' | 'title' | 'created' | 'order';
  sortOrder?: 'asc' | 'desc';
  view?: 'board' | 'list' | 'calendar' | 'timeline' | 'table';
  onViewChange?: (view: string) => void;
  swimlanes?: boolean;
  swimlaneBy?: keyof KanbanTask;
  showColumnActions?: boolean;
  showQuickAdd?: boolean;
  enableKeyboardNavigation?: boolean;
  renderCard?: (task: KanbanTask) => ReactNode;
  className?: string;
  columnClassName?: string;
  cardClassName?: string;
  groupBy?: keyof KanbanTask;
  accentColor?: string;
  showTaskCount?: boolean;
  showDividers?: boolean;
  columnHeight?: number | string;
  pageSize?: number;
  selectable?: boolean;
  selectedTaskIds?: string[];
  activeTimerTaskId?: string | null;
}

export interface SortConfig {
  field: 'title' | 'priority' | 'dueDate' | 'created' | 'order';
  direction: 'asc' | 'desc';
}

export interface FilterOption {
  label: string;
  value: string;
}

export interface SavedFilter {
  id: string;
  name: string;
  query: any;
}



=== FILE: packages\ui\src\components\data-display\kanban\useKanbanBoardScroll.ts ===

import { useState, useRef, useCallback } from 'react';

export function useKanbanBoardScroll() {
  const [isDraggingBoard, setIsDraggingBoard] = useState(false);
  const [startX, setStartX] = useState(0);
  const [scrollLeft, setScrollLeft] = useState(0);
  const boardRef = useRef<HTMLDivElement>(null);

  const handleBoardMouseDown = (e: React.MouseEvent) => {
    if ((e.target as HTMLElement).closest('button') || 
        (e.target as HTMLElement).closest('[draggable="true"]') ||
        (e.target as HTMLElement).closest('.no-drag')) return;
    
    setIsDraggingBoard(true);
    setStartX(e.pageX - (boardRef.current?.offsetLeft || 0));
    setScrollLeft(boardRef.current?.scrollLeft || 0);
  };

  const handleBoardMouseMove = (e: React.MouseEvent) => {
    if (!isDraggingBoard) return;
    e.preventDefault();
    const x = e.pageX - (boardRef.current?.offsetLeft || 0);
    const walk = (x - startX) * 2;
    if (boardRef.current) {
      boardRef.current.scrollLeft = scrollLeft - walk;
    }
  };

  const handleBoardMouseUp = () => {
    setIsDraggingBoard(false);
  };

  return {
    boardRef,
    isDraggingBoard,
    handleBoardMouseDown,
    handleBoardMouseMove,
    handleBoardMouseUp
  };
}



=== FILE: packages\ui\src\components\data-display\kanban\useKanbanDragAndDrop.ts ===

import { useState, useCallback, useRef } from 'react';
import type { KanbanTask, KanbanColumnDef, DropPosition } from './types';

interface UseKanbanDragAndDropProps {
  tasks: KanbanTask[];
  columns: KanbanColumnDef[];
  selectedTaskIds: string[];
  onTaskMove?: (taskId: string, toColumnId: string, toTaskId?: string, position?: 'top' | 'bottom') => void;
  onColumnMove?: (columnId: string, toColumnId: string, position?: 'left' | 'right') => void;
  onTaskDrop?: (taskId: string, fromColumnId: string, toColumnId: string, index: number) => void;
  onTaskDragStart?: (taskId: string) => void;
  onTaskDragEnd?: (taskId: string) => void;
}

export function useKanbanDragAndDrop({
  tasks,
  columns,
  selectedTaskIds,
  onTaskMove,
  onColumnMove,
  onTaskDrop,
  onTaskDragStart,
  onTaskDragEnd
}: UseKanbanDragAndDropProps) {
  const [draggedTaskId, setDraggedTaskId] = useState<string | null>(null);
  const [draggedColumnId, setDraggedColumnId] = useState<string | null>(null);
  const [dragOverColumnId, setDragOverColumnId] = useState<string | null>(null);
  const [dragOverTaskId, setDragOverTaskId] = useState<string | null>(null);
  const [dropPosition, setDropPosition] = useState<DropPosition | null>(null);
  
  const touchTimeout = useRef<any>(null);
  const lastTouchPos = useRef<{ x: number, y: number } | null>(null);

  const handleDragStart = (e: React.DragEvent, id: string, type: 'task' | 'column') => {
    if (type === 'task') {
      setDraggedTaskId(id);
      e.dataTransfer.setData('taskId', id);
      onTaskDragStart?.(id);
    } else {
      setDraggedColumnId(id);
      e.dataTransfer.setData('columnId', id);
    }
    e.dataTransfer.effectAllowed = 'move';
  };

  const handleDragEnd = useCallback(() => {
    if (draggedTaskId) {
      onTaskDragEnd?.(draggedTaskId);
    }
    setDraggedTaskId(null);
    setDraggedColumnId(null);
    setDragOverColumnId(null);
    setDragOverTaskId(null);
    setDropPosition(null);
  }, [draggedTaskId, onTaskDragEnd]);

  const handleDragOver = (e: React.DragEvent, columnId: string, taskId?: string) => {
    e.preventDefault();
    e.dataTransfer.dropEffect = 'move';
    
    if (draggedColumnId) {
      setDragOverColumnId(columnId);
      const rect = (e.currentTarget as HTMLElement).getBoundingClientRect();
      const midpoint = rect.left + rect.width / 2;
      setDropPosition(e.clientX < midpoint ? 'left' : 'right');
    } else {
      setDragOverColumnId(columnId);
      
      if (taskId) {
        setDragOverTaskId(taskId);
        const rect = (e.currentTarget as HTMLElement).getBoundingClientRect();
        const midpoint = rect.top + rect.height / 2;
        setDropPosition(e.clientY < midpoint ? 'top' : 'bottom');
      } else if (e.target === e.currentTarget) {
        setDragOverTaskId(null);
        setDropPosition(null);
      }
    }
  };

  const handleDrop = (e: React.DragEvent, toColumnId: string, toTaskId?: string) => {
    e.preventDefault();
    const taskId = draggedTaskId || e.dataTransfer.getData('taskId');
    const columnId = draggedColumnId || e.dataTransfer.getData('columnId');

    if (columnId && onColumnMove) {
      onColumnMove(columnId, toColumnId, dropPosition === 'right' ? 'right' : 'left');
    } else if (taskId && onTaskMove) {
      const task = tasks.find(t => t.id === taskId);
      if (!task) return;

      const tasksToMove = selectedTaskIds.includes(taskId) 
        ? selectedTaskIds 
        : [taskId];

      tasksToMove.forEach((id) => {
        const currentTask = tasks.find(t => t.id === id);
        const fromColumnId = currentTask?.columnId || '';
        onTaskMove(id, toColumnId, toTaskId, dropPosition === 'bottom' ? 'bottom' : 'top');
        onTaskDrop?.(id, fromColumnId, toColumnId, 0);
      });
    }

    handleDragEnd();
  };

  const handleTouchStart = (e: React.TouchEvent, id: string, type: 'task' | 'column') => {
    const touch = e.touches[0];
    if (!touch) return;

    touchTimeout.current = setTimeout(() => {
      if (type === 'task') {
        setDraggedTaskId(id);
        onTaskDragStart?.(id);
      } else {
        setDraggedColumnId(id);
      }
      lastTouchPos.current = { x: touch.clientX, y: touch.clientY };
    }, 500);
  };

  const handleTouchMove = (e: React.TouchEvent) => {
    if (!draggedTaskId && !draggedColumnId) return;
    e.preventDefault();
    
    const touch = e.touches[0];
    if (!touch) return;

    const target = document.elementFromPoint(touch.clientX, touch.clientY);
    if (!target) return;

    const columnEl = target.closest('[data-column-id]');
    const taskEl = target.closest('[data-task-id]');

    if (columnEl) {
      const columnId = columnEl.getAttribute('data-column-id')!;
      setDragOverColumnId(columnId);
      
      if (draggedColumnId) {
        const rect = columnEl.getBoundingClientRect();
        const midpoint = rect.left + rect.width / 2;
        setDropPosition(touch.clientX < midpoint ? 'left' : 'right');
      } else if (taskEl) {
        const taskId = taskEl.getAttribute('data-task-id')!;
        setDragOverTaskId(taskId);
        const rect = taskEl.getBoundingClientRect();
        const midpoint = rect.top + rect.height / 2;
        setDropPosition(touch.clientY < midpoint ? 'top' : 'bottom');
      }
    }
  };

  const handleTouchEnd = (e: React.TouchEvent) => {
    clearTimeout(touchTimeout.current);
    if (draggedTaskId || draggedColumnId) {
      if (dragOverColumnId) {
        const taskId = draggedTaskId;
        const columnId = draggedColumnId;

        if (columnId && onColumnMove) {
          onColumnMove(columnId, dragOverColumnId, dropPosition === 'right' ? 'right' : 'left');
        } else if (taskId && onTaskMove) {
          onTaskMove(taskId, dragOverColumnId, dragOverTaskId || undefined, dropPosition === 'bottom' ? 'bottom' : 'top');
        }
      }
      handleDragEnd();
    }
  };

  return {
    draggedTaskId,
    draggedColumnId,
    dragOverColumnId,
    dragOverTaskId,
    dropPosition,
    handleDragStart,
    handleDragEnd,
    handleDragOver,
    handleDrop,
    handleTouchStart,
    handleTouchMove,
    handleTouchEnd,
    setDraggedTaskId
  };
}



=== FILE: packages\ui\src\components\data-display\kanban\useKanbanFilters.ts ===

import { useState, useMemo, useCallback } from 'react';
import type { KanbanTask } from './types';

export function useKanbanFilters(tasks: KanbanTask[]) {
  const [searchQuery, setSearchQuery] = useState('');
  const [activeFilters, setActiveFilters] = useState<Record<string, any[]>>({});

  const filteredTasks = useMemo(() => {
    return tasks.filter(task => {
      // Search filter
      if (searchQuery) {
        const query = searchQuery.toLowerCase();
        const matchesSearch = 
          task.title.toLowerCase().includes(query) || 
          task.description?.toLowerCase().includes(query) ||
          task.tags?.some(tag => tag.toLowerCase().includes(query));
        
        if (!matchesSearch) return false;
      }

      // Category filters
      for (const [key, values] of Object.entries(activeFilters)) {
        if (!values || values.length === 0) continue;
        
        if (key === 'priority') {
          if (!values.includes(task.priority)) return false;
        }
        
        if (key === 'assignee') {
          if (!task.assignee || !values.includes(task.assignee.id)) return false;
        }

        if (key === 'tags') {
          if (!task.tags?.some(tag => values.includes(tag))) return false;
        }
      }

      return true;
    });
  }, [tasks, searchQuery, activeFilters]);

  const toggleFilter = useCallback((category: string, value: any) => {
    setActiveFilters(prev => {
      const current = prev[category] || [];
      const next = current.includes(value)
        ? current.filter(v => v !== value)
        : [...current, value];
      
      const newState = { ...prev, [category]: next };
      if (next.length === 0) delete newState[category];
      return newState;
    });
  }, []);

  const clearFilters = useCallback(() => {
    setActiveFilters({});
    setSearchQuery('');
  }, []);

  return {
    searchQuery,
    setSearchQuery,
    activeFilters,
    setActiveFilters,
    filteredTasks,
    toggleFilter,
    clearFilters
  };
}



=== FILE: packages\ui\src\components\data-display\kanban\useKanbanHistory.ts ===

import { useState, useCallback } from 'react';
import type { KanbanUser } from './types';

export interface KanbanHistoryEntry {
  id: string;
  taskId?: string;
  columnId?: string;
  user: KanbanUser;
  action: string;
  details?: string;
  timestamp: Date;
}

export function useKanbanHistory() {
  const [history, setHistory] = useState<KanbanHistoryEntry[]>([]);

  const addEntry = useCallback((entry: Omit<KanbanHistoryEntry, 'id' | 'timestamp'>) => {
    const newEntry: KanbanHistoryEntry = {
      ...entry,
      id: Math.random().toString(36).substr(2, 9),
      timestamp: new Date()
    };
    setHistory(prev => [newEntry, ...prev]);
  }, []);

  const clearHistory = useCallback(() => {
    setHistory([]);
  }, []);

  return {
    history,
    addEntry,
    clearHistory
  };
}



=== FILE: packages\ui\src\components\data-display\kanban\useKanbanKeyboard.ts ===

import { useEffect } from 'react';

interface UseKanbanKeyboardProps {
  onUndo?: () => void;
  onRedo?: () => void;
  onSearch?: () => void;
  onNewTask?: () => void;
  onNewColumn?: () => void;
  enabled?: boolean;
}

export function useKanbanKeyboard({
  onUndo,
  onRedo,
  onSearch,
  onNewTask,
  onNewColumn,
  enabled = true
}: UseKanbanKeyboardProps) {
  useEffect(() => {
    if (!enabled) return;

    const handleKeyDown = (e: KeyboardEvent) => {
      // Undo: Ctrl+Z
      if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
        e.preventDefault();
        onUndo?.();
      }
      
      // Redo: Ctrl+Shift+Z or Ctrl+Y
      if (((e.ctrlKey || e.metaKey) && e.key === 'z' && e.shiftKey) || ((e.ctrlKey || e.metaKey) && e.key === 'y')) {
        e.preventDefault();
        onRedo?.();
      }

      // Search: Ctrl+F or /
      if (((e.ctrlKey || e.metaKey) && e.key === 'f') || (e.key === '/' && document.activeElement === document.body)) {
        e.preventDefault();
        onSearch?.();
      }

      // New Task: N
      if (e.key === 'n' && document.activeElement === document.body) {
        e.preventDefault();
        onNewTask?.();
      }

      // New Column: C
      if (e.key === 'c' && document.activeElement === document.body) {
        e.preventDefault();
        onNewColumn?.();
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [enabled, onUndo, onRedo, onSearch, onNewTask, onNewColumn]);
}



=== FILE: packages\ui\src\components\data-display\kanban\useKanbanSync.ts ===

import { useState, useEffect, useCallback } from 'react';
import type { KanbanTask, KanbanColumnDef } from './types';

interface UseKanbanSyncProps {
  onSync?: (data: { tasks: KanbanTask[], columns: KanbanColumnDef[] }) => Promise<void>;
  interval?: number;
  enabled?: boolean;
}

export function useKanbanSync({ onSync, interval = 30000, enabled = false }: UseKanbanSyncProps) {
  const [lastSynced, setLastSynced] = useState<Date | null>(null);
  const [isSyncing, setIsSyncing] = useState(false);
  const [error, setError] = useState<Error | null>(null);

  const sync = useCallback(async (data: { tasks: KanbanTask[], columns: KanbanColumnDef[] }) => {
    if (!onSync) return;
    
    setIsSyncing(true);
    setError(null);
    
    try {
      await onSync(data);
      setLastSynced(new Date());
    } catch (err) {
      setError(err instanceof Error ? err : new Error('Sync failed'));
    } finally {
      setIsSyncing(false);
    }
  }, [onSync]);

  return {
    sync,
    isSyncing,
    lastSynced,
    error
  };
}



=== FILE: packages\ui\src\components\data-display\kanban\useKanbanTasks.ts ===

import { useMemo, useState, useCallback } from 'react';
import type { KanbanTask, KanbanColumnDef, SortConfig } from './types';

interface UseKanbanTasksProps {
  tasks: KanbanTask[];
  columns: KanbanColumnDef[];
  groupBy?: keyof KanbanTask;
  pageSize: number;
}

export function useKanbanTasks({ tasks, columns, groupBy, pageSize }: UseKanbanTasksProps) {
  const [sortConfig, setSortConfig] = useState<SortConfig | null>(null);
  const [visibleCounts, setVisibleCounts] = useState<Record<string, number>>({});

  const sortedTasks = useMemo(() => {
    if (!sortConfig) return tasks;

    return [...tasks].sort((a, b) => {
      const { field, direction } = sortConfig;
      let comparison = 0;

      if (field === 'title') {
        comparison = a.title.localeCompare(b.title);
      } else if (field === 'priority') {
        const priorityOrder = { urgent: 4, high: 3, medium: 2, low: 1, neutral: 0 };
        const aPrio = priorityOrder[a.priority as keyof typeof priorityOrder] || 0;
        const bPrio = priorityOrder[b.priority as keyof typeof priorityOrder] || 0;
        comparison = aPrio - bPrio;
      } else if (field === 'dueDate') {
        comparison = (a.dueDate || '').localeCompare(b.dueDate || '');
      }

      return direction === 'asc' ? comparison : -comparison;
    });
  }, [tasks, sortConfig]);

  const tasksByGroupAndColumn = useMemo(() => {
    const groups: Record<string, Record<string, KanbanTask[]>> = {};

    if (groupBy) {
      sortedTasks.forEach(task => {
        const groupValue = String(task[groupBy] || 'Other');
        if (!groups[groupValue]) groups[groupValue] = {};
        const group = groups[groupValue]!;
        if (!group[task.columnId]) group[task.columnId] = [];
        group[task.columnId]!.push(task);
      });
    } else {
      groups['default'] = {};
      const defaultGroup = groups['default']!;
      columns.forEach(col => {
        defaultGroup[col.id] = sortedTasks.filter(t => t.columnId === col.id);
      });
    }

    return groups;
  }, [sortedTasks, columns, groupBy]);

  const handleLoadMore = useCallback((columnId: string) => {
    setVisibleCounts(prev => ({
      ...prev,
      [columnId]: (prev[columnId] || pageSize) + pageSize
    }));
  }, [pageSize]);

  return {
    tasksByGroupAndColumn,
    sortConfig,
    setSortConfig,
    visibleCounts,
    handleLoadMore,
    sortedTasks
  };
}



=== FILE: packages\ui\src\components\data-display\kanban\useKanbanUndo.ts ===

import { useState, useCallback, useEffect, useRef } from 'react';
import type { KanbanTask, KanbanColumnDef } from './types';

interface KanbanState {
  tasks: KanbanTask[];
  columns: KanbanColumnDef[];
}

interface HistoryState {
  history: KanbanState[];
  currentIndex: number;
}

export function useKanbanUndo(initialState: KanbanState) {
  const [state, setState] = useState<HistoryState>({
    history: [initialState],
    currentIndex: 0
  });
  
  const lastInitialState = useRef(initialState);

  // Sync with external state changes
  useEffect(() => {
    const tasksChanged = initialState.tasks.length !== lastInitialState.current.tasks.length ||
                        initialState.tasks.some((t, i) => t.id !== lastInitialState.current.tasks[i]?.id || t.columnId !== lastInitialState.current.tasks[i]?.columnId);
    const columnsChanged = initialState.columns.length !== lastInitialState.current.columns.length ||
                          initialState.columns.some((c, i) => c.id !== lastInitialState.current.columns[i]?.id);

    if (tasksChanged || columnsChanged) {
      // Check if the new initialState matches our current state to avoid resetting history on our own changes
      const currentState = state.history[state.currentIndex];
      const isSameAsCurrent = currentState && 
                             initialState.tasks.length === currentState.tasks.length &&
                             initialState.tasks.every((t, i) => t.id === currentState.tasks[i]?.id && t.columnId === currentState.tasks[i]?.columnId);

      if (!isSameAsCurrent) {
        setState({
          history: [initialState],
          currentIndex: 0
        });
      }
      lastInitialState.current = initialState;
    }
  }, [initialState, state.history, state.currentIndex]);

  const pushState = useCallback((newState: KanbanState) => {
    setState(prev => {
      const nextHistory = prev.history.slice(0, prev.currentIndex + 1);
      return {
        history: [...nextHistory, newState],
        currentIndex: prev.currentIndex + 1
      };
    });
  }, []);

  const undo = useCallback(() => {
    setState(prev => {
      if (prev.currentIndex > 0) {
        return { ...prev, currentIndex: prev.currentIndex - 1 };
      }
      return prev;
    });
  }, []);

  const redo = useCallback(() => {
    setState(prev => {
      if (prev.currentIndex < prev.history.length - 1) {
        return { ...prev, currentIndex: prev.currentIndex + 1 };
      }
      return prev;
    });
  }, []);

  return {
    state: state.history[state.currentIndex],
    pushState,
    undo,
    redo,
    canUndo: state.currentIndex > 0,
    canRedo: state.currentIndex < state.history.length - 1
  };
}



=== FILE: packages\ui\src\components\data-display\Marquee.tsx ===

import React from 'react';
import { cn } from '../../utils/cn';

export interface MarqueeProps extends React.HTMLAttributes<HTMLDivElement> {
  pauseOnHover?: boolean;
  direction?: 'left' | 'right';
  speed?: 'slow' | 'normal' | 'fast';
  children: React.ReactNode;
}

export const Marquee = ({ 
  className, 
  pauseOnHover = false, 
  direction = 'left', 
  speed = 'normal',
  children, 
  ...props 
}: MarqueeProps) => {
  
  const speeds = {
    slow: "40s",
    normal: "20s",
    fast: "10s",
  };

  return (
    <div 
      className={cn("group flex overflow-hidden p-2 [--gap:1rem] [gap:var(--gap)]", className)} 
      {...props}
    >
      <div 
        className={cn(
          "flex shrink-0 justify-around [gap:var(--gap)] min-w-full",
          direction === 'left' ? "animate-marquee" : "animate-marquee-reverse",
          pauseOnHover && "group-hover:[animation-play-state:paused]"
        )}
        style={{ animationDuration: speeds[speed] }}
      >
        {children}
      </div>
      <div 
        aria-hidden="true"
        className={cn(
          "flex shrink-0 justify-around [gap:var(--gap)] min-w-full",
          direction === 'left' ? "animate-marquee" : "animate-marquee-reverse",
          pauseOnHover && "group-hover:[animation-play-state:paused]"
        )}
        style={{ animationDuration: speeds[speed] }}
      >
        {children}
      </div>
      <style>{`
        @keyframes marquee {
          from { transform: translateX(0); }
          to { transform: translateX(calc(-100% - var(--gap))); }
        }
        @keyframes marquee-reverse {
          from { transform: translateX(calc(-100% - var(--gap))); }
          to { transform: translateX(0); }
        }
        .animate-marquee {
          animation: marquee linear infinite;
        }
        .animate-marquee-reverse {
          animation: marquee-reverse linear infinite;
        }
      `}</style>
    </div>
  );
};



=== FILE: packages\ui\src\components\data-display\ScrollArea.tsx ===

import React from 'react';
import { cn } from '../../utils/cn';

export interface ScrollAreaProps extends React.HTMLAttributes<HTMLDivElement> {
  orientation?: 'vertical' | 'horizontal' | 'both';
  scrollbarSize?: 'sm' | 'md' | 'lg';
}

export const ScrollArea = React.forwardRef<HTMLDivElement, ScrollAreaProps>(
  ({ className, children, orientation = 'vertical', scrollbarSize = 'sm', ...props }, ref) => {
    return (
      <div
        ref={ref}
        className={cn(
          'overflow-auto',
          // Scrollbar base styles
          '[&::-webkit-scrollbar]:bg-transparent',
          '[&::-webkit-scrollbar-thumb]:bg-gray-300 dark:[&::-webkit-scrollbar-thumb]:bg-white/[0.06]',
          '[&::-webkit-scrollbar-thumb]:rounded-full',
          'hover:[&::-webkit-scrollbar-thumb]:bg-gray-400 dark:hover:[&::-webkit-scrollbar-thumb]:bg-white/20',
          '[&::-webkit-scrollbar-track]:bg-transparent',
          
          // Firefox support
          '[scrollbar-width:thin] [scrollbar-color:rgba(0,0,0,0.2)_transparent] dark:[scrollbar-color:rgba(255,255,255,0.1)_transparent]',
          
          // Orientation specific
          orientation === 'vertical' && 'overflow-y-auto overflow-x-hidden',
          orientation === 'horizontal' && 'overflow-x-auto overflow-y-hidden',
          orientation === 'both' && 'overflow-auto',

          // Size specific
          scrollbarSize === 'sm' && '[&::-webkit-scrollbar]:w-1.5 [&::-webkit-scrollbar]:h-1.5',
          scrollbarSize === 'md' && '[&::-webkit-scrollbar]:w-2.5 [&::-webkit-scrollbar]:h-2.5',
          scrollbarSize === 'lg' && '[&::-webkit-scrollbar]:w-4 [&::-webkit-scrollbar]:h-4',
          
          className
        )}
        {...props}
      >
        {children}
      </div>
    );
  }
);

ScrollArea.displayName = 'ScrollArea';



=== FILE: packages\ui\src\components\data-display\Separator.tsx ===

import React from 'react';
import { cva, type VariantProps } from 'class-variance-authority';
import { cn } from '../../utils/cn';

const separatorVariants = cva(
  "shrink-0 bg-gray-200 dark:bg-white/[0.03]",
  {
    variants: {
      orientation: {
        horizontal: "h-[1px] w-full",
        vertical: "h-full w-[1px]",
      },
    },
    defaultVariants: {
      orientation: "horizontal",
    },
  }
);

export interface SeparatorProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof separatorVariants> {
  orientation?: "horizontal" | "vertical";
  decorative?: boolean;
}

export const Separator = React.forwardRef<HTMLDivElement, SeparatorProps>(
  (
    { className, orientation = "horizontal", decorative = true, ...props },
    ref
  ) => (
    <div
      ref={ref}
      role={decorative ? "none" : "separator"}
      aria-orientation={decorative ? undefined : orientation}
      className={cn(separatorVariants({ orientation, className }))}
      {...props}
    />
  )
);
Separator.displayName = "Separator";



=== FILE: packages\ui\src\components\data-display\StatusDot.tsx ===

import React from 'react';
import { cva, type VariantProps } from 'class-variance-authority';
import { cn } from '../../utils/cn';

const statusDotVariants = cva(
  "inline-block rounded-full",
  {
    variants: {
      variant: {
        success: "bg-emerald-500",
        warning: "bg-amber-500",
        error: "bg-rose-500",
        info: "bg-blue-500",
        neutral: "bg-gray-400",
      },
      size: {
        sm: "h-2 w-2",
        md: "h-2.5 w-2.5",
        lg: "h-3 w-3",
      },
      animate: {
        true: "animate-pulse",
        false: "",
      }
    },
    defaultVariants: {
      variant: "neutral",
      size: "md",
      animate: false,
    }
  }
);

export interface StatusDotProps extends React.HTMLAttributes<HTMLSpanElement>, VariantProps<typeof statusDotVariants> {}

export const StatusDot = React.forwardRef<HTMLSpanElement, StatusDotProps>(
  ({ className, variant, size, animate, ...props }, ref) => {
    return (
      <span
        ref={ref}
        className={cn(statusDotVariants({ variant, size, animate, className }))}
        {...props}
      />
    );
  }
);
StatusDot.displayName = "StatusDot";



=== FILE: packages\ui\src\components\data-display\Table.tsx ===

import React from 'react';
import { cn } from '../../utils/cn';
import { ScrollArea } from './ScrollArea';

interface TableContextValue {
  // Add context values if needed in the future
}

const TableContext = React.createContext<TableContextValue | null>(null);

export interface TableProps extends React.HTMLAttributes<HTMLTableElement> {
  wrapperClassName?: string;
  rounded?: boolean;
  maxHeight?: string | number;
}

export const Table = React.forwardRef<HTMLTableElement, TableProps>(
  ({ className, wrapperClassName, rounded = false, maxHeight, ...props }, ref) => (
    <ScrollArea 
      className={cn("w-full", rounded && "rounded-2xl border border-white/10", wrapperClassName)}
      style={{ maxHeight }}
      orientation={maxHeight ? "both" : "horizontal"}
      scrollbarSize="sm"
    >
      <table
        ref={ref}
        className={cn('w-full caption-bottom text-sm text-left', className)}
        {...props}
      />
    </ScrollArea>
  )
);
Table.displayName = 'Table';

export const TableHeader = React.forwardRef<HTMLTableSectionElement, React.HTMLAttributes<HTMLTableSectionElement>>(
  ({ className, ...props }, ref) => (
    <thead ref={ref} className={cn('bg-white/[0.02] text-white/55', className)} {...props} />
  )
);
TableHeader.displayName = 'TableHeader';

export const TableBody = React.forwardRef<HTMLTableSectionElement, React.HTMLAttributes<HTMLTableSectionElement>>(
  ({ className, ...props }, ref) => (
    <tbody ref={ref} className={cn('[&_tr:last-child]:border-0', className)} {...props} />
  )
);
TableBody.displayName = 'TableBody';

export interface TableRowProps extends React.HTMLAttributes<HTMLTableRowElement> {
  hoverable?: boolean;
  optimized?: boolean;
}

export const TableRow = React.forwardRef<HTMLTableRowElement, TableRowProps>(
  ({ className, hoverable = true, optimized = false, ...props }, ref) => (
    <tr
      ref={ref}
      className={cn(
        'border-t border-white/10 transition-colors data-[state=selected]:bg-white/[0.04]',
        hoverable && 'hover:bg-white/[0.02]',
        className
      )}
      style={optimized ? {
        contentVisibility: 'auto',
        containIntrinsicSize: '0 56px', // Estimated row height
      } : undefined}
      {...props}
    />
  )
);
TableRow.displayName = 'TableRow';

export const TableHead = React.forwardRef<HTMLTableCellElement, React.ThHTMLAttributes<HTMLTableCellElement>>(
  ({ className, ...props }, ref) => (
    <th
      ref={ref}
      className={cn(
        'h-10 px-5 py-3 text-left align-middle font-semibold text-white/55 [&:has([role=checkbox])]:pr-0 whitespace-nowrap',
        className
      )}
      {...props}
    />
  )
);
TableHead.displayName = 'TableHead';

export const TableCell = React.forwardRef<HTMLTableCellElement, React.TdHTMLAttributes<HTMLTableCellElement>>(
  ({ className, ...props }, ref) => (
    <td
      ref={ref}
      className={cn('p-5 align-middle [&:has([role=checkbox])]:pr-0 text-white/85 whitespace-nowrap', className)}
      {...props}
    />
  )
);
TableCell.displayName = 'TableCell';



=== FILE: packages\ui\src\components\data-display\Terminal.tsx ===

import React from 'react';
import { cn } from '../../utils/cn';

export interface TerminalProps extends React.HTMLAttributes<HTMLDivElement> {
  title?: string;
  children: React.ReactNode;
}

export const Terminal = React.forwardRef<HTMLDivElement, TerminalProps>(
  ({ className, title = "Terminal", children, ...props }, ref) => {
    return (
      <div
        ref={ref}
        className={cn(
          "overflow-hidden rounded-2xl border border-gray-200 bg-gray-950 shadow-xl dark:border-white/10",
          className
        )}
        {...props}
      >
        <div className="flex items-center justify-between border-b border-white/10 bg-white/[0.03] px-4 py-2">
          <div className="flex items-center gap-1.5">
            <div className="h-3 w-3 rounded-full bg-rose-500/80" />
            <div className="h-3 w-3 rounded-full bg-amber-500/80" />
            <div className="h-3 w-3 rounded-full bg-emerald-500/80" />
          </div>
          <div className="text-xs font-medium text-white/50">{title}</div>
          <div className="w-10" /> {/* Spacer for centering */}
        </div>
        <div className="p-4 font-mono text-sm text-gray-300">
          {children}
        </div>
      </div>
    );
  }
);
Terminal.displayName = "Terminal";

export const TerminalLine = ({ children, prefix = "$", className }: { children: React.ReactNode, prefix?: string, className?: string }) => (
  <div className={cn("flex gap-2", className)}>
    <span className="select-none text-emerald-400">{prefix}</span>
    <span>{children}</span>
  </div>
);



=== FILE: packages\ui\src\components\data-display\Timeline.tsx ===

import React from 'react';
import { cva, type VariantProps } from 'class-variance-authority';
import { cn } from '../../utils/cn';

const timelineItemVariants = cva(
  "relative pl-8 pb-8 last:pb-0",
  {
    variants: {
      status: {
        default: "[&>div:first-child]:bg-gray-200 dark:[&>div:first-child]:bg-white/20",
        active: "[&>div:first-child]:bg-blue-500",
        success: "[&>div:first-child]:bg-emerald-500",
        error: "[&>div:first-child]:bg-rose-500",
      }
    },
    defaultVariants: {
      status: "default"
    }
  }
);

export interface TimelineItemProps extends React.HTMLAttributes<HTMLDivElement>, VariantProps<typeof timelineItemVariants> {
  title: string;
  date?: string;
  description?: React.ReactNode;
  icon?: React.ReactNode;
  isLast?: boolean;
}

export const TimelineItem = React.forwardRef<HTMLDivElement, TimelineItemProps>(
  ({ className, status, title, date, description, icon, isLast, ...props }, ref) => {
    return (
      <div ref={ref} className={cn(timelineItemVariants({ status, className }))} {...props}>
        {/* Line */}
        {!isLast && (
          <div className="absolute left-[11px] top-[24px] bottom-0 w-px bg-gray-200 dark:bg-white/[0.06]" />
        )}
        
        {/* Dot / Icon */}
        <div className={cn(
          "absolute left-0 top-1.5 flex h-6 w-6 items-center justify-center rounded-full border-2 border-white dark:border-black ring-1 ring-transparent transition-colors",
          status === 'active' ? "bg-blue-500 ring-blue-500/30" : 
          status === 'success' ? "bg-emerald-500 ring-emerald-500/30" :
          status === 'error' ? "bg-rose-500 ring-rose-500/30" :
          "bg-gray-200 dark:bg-white/20"
        )}>
          {icon && <span className="text-white text-[10px]">{icon}</span>}
        </div>

        <div className="flex flex-col gap-1">
          <div className="flex items-center gap-2">
            <span className="text-sm font-medium text-gray-900 dark:text-white">{title}</span>
            {date && <span className="text-xs text-gray-500 dark:text-white/40">{date}</span>}
          </div>
          {description && (
            <div className="text-sm text-gray-600 dark:text-gray-400">
              {description}
            </div>
          )}
        </div>
      </div>
    );
  }
);
TimelineItem.displayName = 'TimelineItem';

export const Timeline = ({ children, className }: { children: React.ReactNode, className?: string }) => {
  return <div className={cn("flex flex-col", className)}>{children}</div>;
};



=== FILE: packages\ui\src\components\data-display\Tree.tsx ===

import React, { useState } from 'react';
import { ChevronRight, ChevronDown, Folder, File, FolderOpen } from 'lucide-react';
import { cn } from '../../utils/cn';

export interface TreeNode {
  id: string;
  label: string;
  icon?: React.ReactNode;
  children?: TreeNode[];
}

export interface TreeProps {
  data: TreeNode[];
  className?: string;
  onSelect?: (node: TreeNode) => void;
}

const TreeNodeItem = ({ node, depth = 0, onSelect }: { node: TreeNode; depth?: number; onSelect?: (node: TreeNode) => void }) => {
  const [isOpen, setIsOpen] = useState(false);
  const hasChildren = node.children && node.children.length > 0;

  const handleToggle = (e: React.MouseEvent) => {
    e.stopPropagation();
    if (hasChildren) {
      setIsOpen(!isOpen);
    }
    onSelect?.(node);
  };

  return (
    <div>
      <div
        className={cn(
          "flex items-center gap-2 rounded-lg px-2 py-1.5 text-sm text-gray-700 transition-colors hover:bg-gray-100 dark:text-gray-300 dark:hover:bg-white/[0.03] cursor-pointer",
        )}
        style={{ paddingLeft: `${depth * 12 + 8}px` }}
        onClick={handleToggle}
      >
        {hasChildren ? (
          <span className="text-gray-400 dark:text-white/40">
            {isOpen ? <ChevronDown className="h-4 w-4" /> : <ChevronRight className="h-4 w-4" />}
          </span>
        ) : (
          <span className="w-4" /> 
        )}
        
        {node.icon ? (
          <span className="text-gray-500 dark:text-white/50">{node.icon}</span>
        ) : (
          <span className="text-blue-500 dark:text-blue-400">
            {hasChildren ? (isOpen ? <FolderOpen className="h-4 w-4" /> : <Folder className="h-4 w-4" />) : <File className="h-4 w-4" />}
          </span>
        )}
        
        <span className="truncate">{node.label}</span>
      </div>
      
      {isOpen && hasChildren && (
        <div className="animate-in slide-in-from-top-1 fade-in duration-200">
          {node.children!.map((child) => (
            <TreeNodeItem key={child.id} node={child} depth={depth + 1} onSelect={onSelect} />
          ))}
        </div>
      )}
    </div>
  );
};

export const Tree = ({ data, className, onSelect }: TreeProps) => {
  return (
    <div className={cn("w-full select-none", className)}>
      {data.map((node) => (
        <TreeNodeItem key={node.id} node={node} onSelect={onSelect} />
      ))}
    </div>
  );
};



=== FILE: packages\ui\src\components\data-display\UserPreview.tsx ===

import React from 'react';
import { cva, type VariantProps } from 'class-variance-authority';
import { cn } from '../../utils/cn';
import { Avatar } from './Avatar';
import { Button } from '../button/Button';

const userPreviewVariants = cva(
  "flex flex-col gap-4 rounded-2xl border p-4 transition-all duration-200",
  {
    variants: {
      variant: {
        default: "bg-white border-gray-200 dark:bg-white/[0.03] dark:border-white/10",
        glass: "backdrop-blur-md bg-white/80 border-white/20 dark:bg-black/40 dark:border-white/10",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
);

export interface UserPreviewProps 
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof userPreviewVariants> {
  user: {
    name: string;
    email?: string;
    avatarSrc?: string;
    role?: string;
    bio?: string;
    stats?: { label: string; value: string | number }[];
  };
  onFollow?: () => void;
  onMessage?: () => void;
}

export const UserPreview = React.forwardRef<HTMLDivElement, UserPreviewProps>(
  ({ className, variant, user, onFollow, onMessage, ...props }, ref) => {
    return (
      <div ref={ref} className={cn(userPreviewVariants({ variant, className }))} {...props}>
        <div className="flex items-start justify-between">
          <div className="flex gap-3">
            <Avatar src={user.avatarSrc} alt={user.name} size="lg" />
            <div>
              <h4 className="text-sm font-semibold text-gray-900 dark:text-white">{user.name}</h4>
              {user.role && (
                <span className="text-xs text-gray-500 dark:text-white/50">{user.role}</span>
              )}
              {user.email && (
                <div className="text-xs text-gray-400 dark:text-white/40 mt-0.5">{user.email}</div>
              )}
            </div>
          </div>
          {onFollow && (
             <Button size="sm" variant="outline" onClick={onFollow}>Follow</Button>
          )}
        </div>
        
        {user.bio && (
          <p className="text-sm text-gray-600 dark:text-gray-300 line-clamp-2">
            {user.bio}
          </p>
        )}

        {user.stats && (
          <div className="flex gap-4 border-t border-gray-100 pt-3 dark:border-white/5">
            {user.stats.map((stat, i) => (
              <div key={i} className="flex flex-col">
                <span className="text-xs font-medium text-gray-900 dark:text-white">{stat.value}</span>
                <span className="text-[10px] text-gray-500 dark:text-white/40">{stat.label}</span>
              </div>
            ))}
          </div>
        )}
        
        {onMessage && (
            <Button className="w-full mt-2" onClick={onMessage}>Message</Button>
        )}
      </div>
    );
  }
);
UserPreview.displayName = 'UserPreview';



=== FILE: packages\ui\src\components\feedback\Alert.tsx ===

import React from 'react';
import { cn } from '../../utils/cn';

export type AlertVariant = 'default' | 'success' | 'error' | 'warning' | 'info';

export interface AlertProps extends React.HTMLAttributes<HTMLDivElement> {
  variant?: AlertVariant;
  icon?: React.ReactNode;
  title?: string;
  children?: React.ReactNode;
}

const Icons = {
  success: (
    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="text-emerald-400">
      <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14" />
      <polyline points="22 4 12 14.01 9 11.01" />
    </svg>
  ),
  error: (
    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="text-rose-400">
      <circle cx="12" cy="12" r="10" />
      <line x1="12" y1="8" x2="12" y2="12" />
      <line x1="12" y1="16" x2="12.01" y2="16" />
    </svg>
  ),
  warning: (
    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="text-amber-400">
      <path d="m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z" />
      <line x1="12" y1="9" x2="12" y2="13" />
      <line x1="12" y1="17" x2="12.01" y2="17" />
    </svg>
  ),
  info: (
    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="text-blue-400">
      <circle cx="12" cy="12" r="10" />
      <line x1="12" y1="16" x2="12" y2="12" />
      <line x1="12" y1="8" x2="12.01" y2="8" />
    </svg>
  ),
};

export const Alert = React.forwardRef<HTMLDivElement, AlertProps>(
  ({ className, variant = 'default', icon, title, children, ...props }, ref) => {
    const Icon = icon || (variant !== 'default' ? Icons[variant] : null);

    return (
      <div
        ref={ref}
        role="alert"
        className={cn(
          "relative w-full rounded-2xl border p-4 [&>svg~*]:pl-7 [&>svg+div]:translate-y-[-3px] [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg]:text-gray-900 dark:[&>svg]:text-white",
          "bg-white dark:bg-[#0A0A0A]/50 backdrop-blur-md border-gray-200 dark:border-white/10 text-gray-900 dark:text-white",
          variant === 'error' && "border-rose-200 dark:border-rose-500/20 bg-rose-50 dark:bg-rose-950/10 text-rose-900 dark:text-rose-50 [&>svg]:text-rose-600 dark:[&>svg]:text-rose-400",
          variant === 'success' && "border-emerald-200 dark:border-emerald-500/20 bg-emerald-50 dark:bg-emerald-950/10 text-emerald-900 dark:text-emerald-50 [&>svg]:text-emerald-600 dark:[&>svg]:text-emerald-400",
          variant === 'warning' && "border-amber-200 dark:border-amber-500/20 bg-amber-50 dark:bg-amber-950/10 text-amber-900 dark:text-amber-50 [&>svg]:text-amber-600 dark:[&>svg]:text-amber-400",
          variant === 'info' && "border-blue-200 dark:border-blue-500/20 bg-blue-50 dark:bg-blue-950/10 text-blue-900 dark:text-blue-50 [&>svg]:text-blue-600 dark:[&>svg]:text-blue-400",
          className
        )}
        {...props}
      >
        {Icon}
        <div className="flex flex-col gap-1">
          {title && (
            <h5 className="mb-1 font-medium leading-none tracking-tight">
              {title}
            </h5>
          )}
          {children && (
            <div className="text-sm opacity-90 [&_p]:leading-relaxed">
              {children}
            </div>
          )}
        </div>
      </div>
    );
  }
);

Alert.displayName = 'Alert';



=== FILE: packages\ui\src\components\feedback\EmptyState.tsx ===

import React from 'react';
import { cn } from '../../utils/cn';
import { Surface } from '../../primitives/Surface';
import { Info } from 'lucide-react';

export interface EmptyStateProps extends React.HTMLAttributes<HTMLDivElement> {
  icon?: React.ReactNode;
  title: string;
  description?: string;
  action?: React.ReactNode;
}

export const EmptyState = React.forwardRef<HTMLDivElement, EmptyStateProps>(
  ({ icon, title, description, action, className, ...props }, ref) => {
    return (
      <Surface
        ref={ref}
        className={cn('p-8 text-center', className)}
        {...props}
      >
        <div className="mx-auto w-full max-w-md space-y-3">
          <div className="mx-auto grid h-12 w-12 place-items-center rounded-2xl border border-white/10 bg-white/[0.03] text-white/70">
            {icon ?? <Info className="h-5 w-5" />}
          </div>
          <div className="text-lg font-semibold text-white">{title}</div>
          {description ? <div className="text-sm text-white/55">{description}</div> : null}
          {action ? <div className="pt-2 flex justify-center">{action}</div> : null}
        </div>
      </Surface>
    );
  }
);

EmptyState.displayName = 'EmptyState';



=== FILE: packages\ui\src\components\feedback\Magnetic.tsx ===

import React, { useRef, useState, useEffect } from 'react';
import { cn } from '../../utils/cn';

export interface MagneticProps {
  children: React.ReactElement;
  strength?: number;
  className?: string;
}

export function Magnetic({ children, strength = 0.5, className }: MagneticProps) {
  const ref = useRef<HTMLDivElement>(null);

  const handleMouseMove = (e: MouseEvent) => {
    const el = ref.current;
    if (!el) return;
    
    const { clientX, clientY } = e;
    const { left, top, width, height } = el.getBoundingClientRect();
    
    const centerX = left + width / 2;
    const centerY = top + height / 2;
    
    const distanceX = clientX - centerX;
    const distanceY = clientY - centerY;
    
    // Only apply if mouse is relatively close
    const threshold = Math.max(width, height) * 1.5;
    if (Math.abs(distanceX) < threshold && Math.abs(distanceY) < threshold) {
      el.style.setProperty('--mag-x', `${distanceX * strength}px`);
      el.style.setProperty('--mag-y', `${distanceY * strength}px`);
    } else {
      el.style.setProperty('--mag-x', '0px');
      el.style.setProperty('--mag-y', '0px');
    }
  };

  const handleMouseLeave = () => {
    const el = ref.current;
    if (el) {
      el.style.setProperty('--mag-x', '0px');
      el.style.setProperty('--mag-y', '0px');
    }
  };

  useEffect(() => {
    window.addEventListener('mousemove', handleMouseMove);
    return () => window.removeEventListener('mousemove', handleMouseMove);
  }, [strength]);

  return (
    <div
      ref={ref}
      className={cn("inline-block transition-transform duration-300 ease-out will-change-transform", className)}
      onMouseLeave={handleMouseLeave}
      style={{
        transform: `translate3d(var(--mag-x, 0px), var(--mag-y, 0px), 0)`,
      }}
    >
      {children}
    </div>
  );
}



=== FILE: packages\ui\src\components\feedback\Motion.tsx ===

import React from 'react';
import { cva, type VariantProps } from 'class-variance-authority';
import { Slot } from '../../utils/Slot';
import { cn } from '../../utils/cn';
import { useInView } from '../../hooks/useInView';

const motionVariants = cva(
  'transition-all duration-700 ease-out', 
  {
    variants: {
      preset: {
        'fade': 'opacity-0 translate-y-4',
        'spring': 'opacity-0 scale-95 translate-y-4',
        'slide-right': 'opacity-0 -translate-x-8',
        'slide-left': 'opacity-0 translate-x-8',
        'blur': 'opacity-0 blur-sm scale-105',
        '3d-flip': 'opacity-0 rotate-x-90',
      },
      visibleState: {
        'fade': 'opacity-100 translate-y-0',
        'spring': 'opacity-100 scale-100 translate-y-0 animate-enter-spring',
        'slide-right': 'opacity-100 translate-x-0',
        'slide-left': 'opacity-100 translate-x-0',
        'blur': 'opacity-100 blur-0 scale-100',
        '3d-flip': 'opacity-100 rotate-x-0',
      }
    },
    defaultVariants: {
      preset: 'spring',
    },
  }
);

export interface MotionProps extends React.HTMLAttributes<HTMLDivElement>, Omit<VariantProps<typeof motionVariants>, 'visibleState'> {
  asChild?: boolean;
  viewport?: boolean; // If true, animates only when entering the viewport
  visible?: boolean; // Manual control override
  delay?: number; // Delay in ms
  once?: boolean; // If true, animates only once
}

export function Motion({ 
  className, 
  preset = 'spring', 
  viewport = true, 
  visible,
  delay = 0,
  once = true,
  asChild = false,
  children, 
  style,
  ...props 
}: MotionProps) {
  const { ref, isInView, hasAnimated } = useInView({ threshold: 0.1, enabled: viewport && visible === undefined });
  
  // Determine if we should show the final state
  const internalShow = viewport ? (once ? hasAnimated : isInView) : true;
  const shouldShow = visible !== undefined ? visible : internalShow;

  // We manually construct the class string to ensure the correct preset is applied in the visible state
  // This is a bit of a hack because CVA doesn't support "conditional variants" based on external state easily
  // without defining a new variant like "state: visible".
  // But here we want to map 'preset' to 'visible' styles when shouldShow is true.
  
  // Let's simplify:
  // If shouldShow is true, we want the styles from `visible: [preset]`.
  // If shouldShow is false, we want the styles from `preset: [preset]`.
  
  // However, CVA `visible` variant keys match `preset` keys.
  // So we can just pass `visible: shouldShow ? preset : null`? No, that would remove the base styles.
  
  // Correct approach with the current CVA definition:
  // The `preset` variant defines the INITIAL state (hidden).
  // The `visible` variant defines the FINAL state (shown).
  // We need to apply `preset` ALWAYS (as base), and then override with `visible` when shown?
  // No, `preset` has opacity-0. If we keep it, we need `visible` to have opacity-100 and override it.
  // Tailwind classes override based on order in CSS, but here they are utility classes.
  // `opacity-100` usually overrides `opacity-0` if generated later, but `cn` merges them.
  
  // Let's try to be cleaner:
  // We will use the `preset` prop to get the initial state classes.
  // And we will manually append the visible classes if `shouldShow` is true.
  
  const initialClasses = motionVariants({ preset });
  const visibleClasses = shouldShow ? motionVariants({ visibleState: preset as any }) : '';
  
  // If visibleClasses is applied, we want it to win over initialClasses.
  // `cn` (tailwind-merge) handles this conflict resolution perfectly.
  
  const Comp = asChild ? Slot : 'div';

  return (
    <Comp
      ref={ref}
      className={cn(
        initialClasses,
        visibleClasses,
        className
      )}
      style={{ 
        transitionDelay: `${delay}ms`,
        willChange: 'transform, opacity',
        ...style 
      }}
      {...props}
    >
      {children}
    </Comp>
  );
}



=== FILE: packages\ui\src\components\feedback\MotionGroup.tsx ===

import React from 'react';
import { useInView } from '../../hooks/useInView';
import { cn } from '../../utils/cn';

interface MotionGroupProps extends React.HTMLAttributes<HTMLDivElement> {
  children: React.ReactNode;
  stagger?: number; // Delay between items in ms
  delay?: number;   // Initial delay in ms
}

export function MotionGroup({ 
  children, 
  stagger = 100, 
  delay = 0, 
  className, 
  ...props 
}: MotionGroupProps) {
  const { ref, hasAnimated } = useInView({ threshold: 0.1 });

  return (
    <div ref={ref} className={cn('relative', className)} {...props}>
      {React.Children.map(children, (child, index) => {
        if (React.isValidElement(child)) {
          return React.cloneElement(child as React.ReactElement<any>, {
            // Force child to wait for group
            visible: hasAnimated,
            // Disable child's internal observer to save resources
            viewport: false,
            // Calculate stagger delay
            delay: delay + (index * stagger),
          });
        }
        return child;
      })}
    </div>
  );
}



=== FILE: packages\ui\src\components\feedback\NumberTicker.tsx ===

import React, { useEffect, useState, useRef } from 'react';
import { cn } from '../../utils/cn';
import { useInView } from '../../hooks/useInView';

export interface NumberTickerProps extends React.HTMLAttributes<HTMLSpanElement> {
  value: number;
  duration?: number;
  delay?: number;
  decimalPlaces?: number;
}

export function NumberTicker({
  value,
  duration = 2000,
  delay = 0,
  decimalPlaces = 0,
  className,
  ...props
}: NumberTickerProps) {
  const [displayValue, setDisplayValue] = useState(0);
  const { ref, hasAnimated } = useInView({ threshold: 0.1 });
  const startTimeRef = useRef<number | null>(null);

  useEffect(() => {
    if (!hasAnimated) return;

    const animate = (timestamp: number) => {
      if (!startTimeRef.current) startTimeRef.current = timestamp;
      const progress = Math.min((timestamp - startTimeRef.current - delay) / duration, 1);
      
      if (progress >= 0) {
        const current = progress * value;
        setDisplayValue(current);
      }

      if (progress < 1) {
        requestAnimationFrame(animate);
      }
    };

    const timeout = setTimeout(() => {
      requestAnimationFrame(animate);
    }, delay);

    return () => clearTimeout(timeout);
  }, [hasAnimated, value, duration, delay]);

  return (
    <span
      ref={ref}
      className={cn("tabular-nums tracking-tighter", className)}
      {...props}
    >
      {displayValue.toFixed(decimalPlaces)}
    </span>
  );
}



=== FILE: packages\ui\src\components\feedback\PageLoader.tsx ===

import React from 'react';
import { Loader2 } from 'lucide-react';
import { cn } from '../../utils/cn';

export interface PageLoaderProps extends React.HTMLAttributes<HTMLDivElement> {
  variant?: 'spinner' | 'bar' | 'dots' | 'logo' | 'glass';
  text?: string;
  fullscreen?: boolean;
}

export function PageLoader({
  variant = 'spinner',
  text,
  fullscreen = true,
  className,
  ...props
}: PageLoaderProps) {
  const baseStyles = fullscreen
    ? 'fixed inset-0 z-[200] flex items-center justify-center bg-white/80 dark:bg-black/80 backdrop-blur-sm'
    : 'flex items-center justify-center p-8 w-full h-full min-h-[200px]';

  if (variant === 'bar') {
    return (
      <div className={cn('fixed top-0 left-0 right-0 z-[200] h-1 bg-transparent', className)} {...props}>
        <div className="h-full bg-blue-500 animate-indeterminate-progress origin-left" />
      </div>
    );
  }

  if (variant === 'dots') {
    return (
      <div className={cn(baseStyles, className)} {...props}>
        <div className="flex space-x-2">
          <div className="h-3 w-3 rounded-full bg-blue-500 animate-bounce [animation-delay:-0.3s]" />
          <div className="h-3 w-3 rounded-full bg-blue-500 animate-bounce [animation-delay:-0.15s]" />
          <div className="h-3 w-3 rounded-full bg-blue-500 animate-bounce" />
        </div>
        {text && <span className="ml-4 text-sm font-medium text-gray-500 dark:text-white/70">{text}</span>}
      </div>
    );
  }

  if (variant === 'logo') {
    return (
      <div className={cn(baseStyles, className)} {...props}>
        <div className="flex flex-col items-center gap-4">
          <div className="relative flex h-16 w-16 items-center justify-center rounded-full bg-white dark:bg-white/[0.06] shadow-lg ring-1 ring-black/5">
            <div className="absolute inset-0 rounded-full animate-ping bg-blue-500/20" />
            <div className="h-8 w-8 rounded bg-blue-500" />
          </div>
          {text && <span className="text-sm font-medium text-gray-500 dark:text-white/70 animate-pulse">{text}</span>}
        </div>
      </div>
    );
  }

  if (variant === 'glass') {
    return (
      <div className={cn(baseStyles, 'bg-white/30 dark:bg-black/30 backdrop-blur-md', className)} {...props}>
        <div className="flex flex-col items-center gap-3">
          <Loader2 className="h-8 w-8 animate-spin text-white" />
          {text && <span className="text-sm font-medium text-white tracking-wider">{text}</span>}
        </div>
      </div>
    );
  }

  // Default: spinner
  return (
    <div className={cn(baseStyles, className)} {...props}>
      <div className="flex flex-col items-center gap-3">
        <Loader2 className="h-8 w-8 animate-spin text-blue-500" />
        {text && <span className="text-sm font-medium text-gray-500 dark:text-white/70">{text}</span>}
      </div>
    </div>
  );
}



=== FILE: packages\ui\src\components\feedback\PageTransition.tsx ===

import React, { useEffect, useState } from 'react';
import { cn } from '../../utils/cn';

export interface PageTransitionProps extends React.HTMLAttributes<HTMLDivElement> {
  preset?: 'fade' | 'slide-up' | 'scale' | 'blur' | 'none';
  duration?: number;
  useViewTransition?: boolean;
}

export function PageTransition({
  preset = 'fade',
  duration = 300,
  useViewTransition = false,
  className,
  children,
  ...props
}: PageTransitionProps) {
  const [isVisible, setIsVisible] = useState(false);

  useEffect(() => {
    if (useViewTransition && (document as any).startViewTransition) {
      (document as any).startViewTransition(() => {
        setIsVisible(true);
      });
    } else {
      const timer = requestAnimationFrame(() => {
        setIsVisible(true);
      });
      return () => cancelAnimationFrame(timer);
    }
  }, [useViewTransition]);

  const presets = {
    fade: {
      initial: 'opacity-0',
      animate: 'opacity-100',
    },
    'slide-up': {
      initial: 'opacity-0 translate-y-8',
      animate: 'opacity-100 translate-y-0',
    },
    scale: {
      initial: 'opacity-0 scale-95',
      animate: 'opacity-100 scale-100',
    },
    blur: {
      initial: 'opacity-0 blur-sm',
      animate: 'opacity-100 blur-0',
    },
    none: {
      initial: '',
      animate: '',
    }
  };

  const currentPreset = presets[preset];

  return (
    <div
      className={cn(
        'transition-all ease-out',
        isVisible ? currentPreset.animate : currentPreset.initial,
        className
      )}
      style={{ 
        transitionDuration: `${duration}ms`,
        viewTransitionName: useViewTransition ? 'page-content' : undefined
      } as any}
      {...props}
    >
      {children}
    </div>
  );
}



=== FILE: packages\ui\src\components\feedback\Parallax.tsx ===

import React, { useEffect, useRef } from 'react';
import { cn } from '../../utils/cn';

interface ParallaxProps extends React.HTMLAttributes<HTMLDivElement> {
  speed?: number; // -1 to 1. Positive = moves slower (depth), Negative = moves faster.
  direction?: 'vertical' | 'horizontal';
}

export function Parallax({ 
  children, 
  speed = 0.1, 
  direction = 'vertical',
  className,
  ...props 
}: ParallaxProps) {
  const ref = useRef<HTMLDivElement>(null);

  useEffect(() => {
    const element = ref.current;
    if (!element) return;

    const handleScroll = () => {
      const rect = element.getBoundingClientRect();
      const windowHeight = window.innerHeight;
      
      // Optimization: Only animate if roughly in view
      if (rect.top > windowHeight || rect.bottom < 0) return;

      // Calculate distance from center of viewport
      // 0 = center, -val = above center, +val = below center
      const centerOffset = (windowHeight / 2) - (rect.top + rect.height / 2);
      
      const translate = centerOffset * speed;

      if (direction === 'vertical') {
        element.style.transform = `translate3d(0, ${translate}px, 0)`;
      } else {
        element.style.transform = `translate3d(${translate}px, 0, 0)`;
      }
    };

    window.addEventListener('scroll', handleScroll, { passive: true });
    handleScroll(); // Initial calculation

    return () => window.removeEventListener('scroll', handleScroll);
  }, [speed, direction]);

  return (
    <div 
      ref={ref} 
      className={cn('will-change-transform', className)} 
      {...props}
    >
      {children}
    </div>
  );
}



=== FILE: packages\ui\src\components\feedback\Progress.tsx ===

import React from 'react';
import { cn } from '../../utils/cn';

export type ProgressVariant = 'default' | 'success' | 'warning' | 'danger' | 'gradient';
export type ProgressSize = 'sm' | 'md' | 'lg';

export interface ProgressProps extends React.HTMLAttributes<HTMLDivElement> {
  value?: number;
  max?: number;
  variant?: ProgressVariant;
  size?: ProgressSize;
  isIndeterminate?: boolean;
  hasStripe?: boolean;
  indicatorClassName?: string;
}

export const Progress = React.forwardRef<HTMLDivElement, ProgressProps>(
  ({ 
    className, 
    value = 0, 
    max = 100, 
    variant = 'default',
    size = 'md',
    isIndeterminate = false,
    hasStripe = false,
    indicatorClassName, 
    ...props 
  }, ref) => {
    const percentage = isIndeterminate ? 0 : Math.min(Math.max((value || 0) / max, 0), 1) * 100;

    const variants = {
      default: 'bg-gray-900 dark:bg-white dark:shadow-[0_0_10px_rgba(255,255,255,0.5)]',
      success: 'bg-emerald-500 shadow-sm dark:shadow-[0_0_10px_rgba(16,185,129,0.5)]',
      warning: 'bg-amber-500 shadow-sm dark:shadow-[0_0_10px_rgba(245,158,11,0.5)]',
      danger: 'bg-rose-500 shadow-sm dark:shadow-[0_0_10px_rgba(244,63,94,0.5)]',
      gradient: 'bg-gradient-to-r from-blue-600 via-purple-600 to-blue-600 shadow-sm dark:shadow-[0_0_15px_rgba(99,102,241,0.5)]'
    };

    const sizes = {
      sm: 'h-1',
      md: 'h-2',
      lg: 'h-4'
    };

    return (
      <div
        ref={ref}
        role="progressbar"
        aria-valuemin={0}
        aria-valuemax={max}
        aria-valuenow={isIndeterminate ? undefined : value}
        className={cn(
          "relative w-full overflow-hidden rounded-full bg-gray-200 dark:bg-white/[0.03] border border-gray-200 dark:border-white/5 backdrop-blur-sm",
          sizes[size],
          className
        )}
        {...props}
      >
        <div
          className={cn(
            "h-full w-full flex-1 transition-all duration-500 ease-in-out relative overflow-hidden",
            variants[variant],
            isIndeterminate && "absolute inset-0 w-full origin-left animate-indeterminate-progress",
            indicatorClassName
          )}
          style={{ 
            transform: isIndeterminate ? undefined : `translateX(-${100 - percentage}%)` 
          }}
        >
          {hasStripe && !isIndeterminate && (
            <div className="absolute inset-0 w-full h-full animate-progress-stripe" 
                 style={{
                   backgroundImage: 'linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent)',
                   backgroundSize: '1rem 1rem'
                 }} 
            />
          )}
        </div>
      </div>
    );
  }
);

Progress.displayName = "Progress";



=== FILE: packages\ui\src\components\feedback\Rating.tsx ===

import React, { useState } from 'react';
import { Star } from 'lucide-react';
import { cn } from '../../utils/cn';

export interface RatingProps extends Omit<React.HTMLAttributes<HTMLDivElement>, 'onChange'> {
  max?: number;
  value?: number;
  onChange?: (value: number) => void;
  readOnly?: boolean;
  size?: 'sm' | 'md' | 'lg';
}

export const Rating = React.forwardRef<HTMLDivElement, RatingProps>(
  ({ className, max = 5, value = 0, onChange, readOnly = false, size = 'md', ...props }, ref) => {
    const [hoverValue, setHoverValue] = useState<number | null>(null);

    const sizes = {
      sm: "h-4 w-4",
      md: "h-5 w-5",
      lg: "h-6 w-6",
    };

    return (
      <div ref={ref} className={cn("flex items-center gap-1", className)} {...props}>
        {Array.from({ length: max }).map((_, i) => {
          const index = i + 1;
          const isFilled = (hoverValue !== null ? hoverValue : value) >= index;
          
          return (
            <button
              key={i}
              type="button"
              disabled={readOnly}
              onClick={() => onChange?.(index)}
              onMouseEnter={() => !readOnly && setHoverValue(index)}
              onMouseLeave={() => !readOnly && setHoverValue(null)}
              className={cn(
                "transition-transform hover:scale-110 focus:outline-none",
                readOnly && "cursor-default hover:scale-100"
              )}
            >
              <Star
                className={cn(
                  sizes[size],
                  "transition-colors duration-200",
                  isFilled 
                    ? "fill-amber-400 text-amber-400" 
                    : "fill-transparent text-gray-300 dark:text-white/20"
                )}
              />
            </button>
          );
        })}
      </div>
    );
  }
);
Rating.displayName = "Rating";



=== FILE: packages\ui\src\components\feedback\Reveal.tsx ===

import React from 'react';
import { cn } from '../../utils/cn';
import { useInView } from '../../hooks/useInView';

export interface RevealProps extends React.HTMLAttributes<HTMLDivElement> {
  children: React.ReactNode;
  direction?: 'up' | 'down' | 'left' | 'right';
  duration?: number;
  delay?: number;
  boxColor?: string;
}

export function Reveal({
  children,
  direction = 'up',
  duration = 0.5,
  delay = 0,
  boxColor = 'bg-blue-500',
  className,
  ...props
}: RevealProps) {
  const { ref, hasAnimated } = useInView({ threshold: 0.2 });

  const directionClasses = {
    up: 'translate-y-full',
    down: '-translate-y-full',
    left: 'translate-x-full',
    right: '-translate-x-full',
  };

  return (
    <div
      ref={ref}
      className={cn("relative overflow-hidden inline-block", className)}
      {...props}
    >
      <div
        className={cn(
          "transition-all ease-out",
          hasAnimated ? "translate-x-0 translate-y-0 opacity-100" : cn("opacity-0", directionClasses[direction])
        )}
        style={{ 
          transitionDuration: `${duration}s`,
          transitionDelay: `${delay}s`
        }}
      >
        {children}
      </div>
      
      {/* Reveal Box Overlay */}
      <div
        className={cn(
          "absolute inset-0 z-10 transition-transform ease-in-out",
          boxColor,
          hasAnimated ? (direction === 'left' || direction === 'right' ? 'scale-x-0' : 'scale-y-0') : 'scale-100'
        )}
        style={{ 
          transitionDuration: `${duration}s`,
          transitionDelay: `${delay}s`,
          transformOrigin: direction === 'up' ? 'top' : direction === 'down' ? 'bottom' : direction === 'left' ? 'left' : 'right'
        }}
      />
    </div>
  );
}



=== FILE: packages\ui\src\components\feedback\Skeleton.tsx ===

import React from 'react';
import { cn } from '../../utils/cn';

export interface SkeletonProps extends React.HTMLAttributes<HTMLDivElement> {
  variant?: 'default' | 'circle' | 'text';
}

export function Skeleton({ className, variant = 'default', ...props }: SkeletonProps) {
  return (
    <div
      className={cn(
        "animate-pulse bg-gray-200 dark:bg-white/[0.03]",
        variant === 'circle' && "rounded-full",
        variant === 'default' && "rounded-2xl",
        variant === 'text' && "rounded h-4 w-full",
        className
      )}
      {...props}
    />
  );
}



=== FILE: packages\ui\src\components\feedback\TextMotion.tsx ===

import React from 'react';
import { useInView } from '../../hooks/useInView';
import { cn } from '../../utils/cn';

interface TextMotionProps extends React.HTMLAttributes<HTMLDivElement> {
  text: string;
  type?: 'char' | 'word';
  stagger?: number;
  delay?: number;
}

export function TextMotion({ 
  text, 
  type = 'char', 
  stagger = 30, 
  delay = 0,
  className,
  ...props 
}: TextMotionProps) {
  const { ref, hasAnimated } = useInView({ threshold: 0.2 });
  
  const items = type === 'char' ? text.split('') : text.split(' ');

  return (
    <div 
      ref={ref} 
      className={cn('flex flex-wrap', className)} 
      aria-label={text}
      {...props}
    >
      {items.map((item, i) => (
        <span
          key={i}
          className={cn(
            'inline-block whitespace-pre transition-all duration-500 ease-out will-change-transform',
            hasAnimated 
              ? 'opacity-100 translate-y-0 blur-0' 
              : 'opacity-0 translate-y-4 blur-sm'
          )}
          style={{ 
            transitionDelay: `${delay + (i * stagger)}ms` 
          }}
        >
          {item}{type === 'word' && i !== items.length - 1 ? ' ' : ''}
        </span>
      ))}
    </div>
  );
}



=== FILE: packages\ui\src\components\feedback\Toast.tsx ===

import React, { useEffect } from 'react';
import { cn } from '../../utils/cn';

export type ToastVariant = 'default' | 'success' | 'error' | 'warning' | 'info' | 'loading';

export interface ToastProps {
  id: string;
  title?: string;
  description?: React.ReactNode;
  variant?: ToastVariant;
  duration?: number;
  onDismiss: (id: string) => void;
}

const Icons = {
  loading: (
    <svg className="animate-spin text-blue-500" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
      <path d="M21 12a9 9 0 1 1-6.219-8.56" />
    </svg>
  ),
  success: (
    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="text-emerald-400">
      <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14" />
      <polyline points="22 4 12 14.01 9 11.01" />
    </svg>
  ),
  error: (
    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="text-rose-400">
      <circle cx="12" cy="12" r="10" />
      <line x1="12" y1="8" x2="12" y2="12" />
      <line x1="12" y1="16" x2="12.01" y2="16" />
    </svg>
  ),
  warning: (
    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="text-amber-400">
      <path d="m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z" />
      <line x1="12" y1="9" x2="12" y2="13" />
      <line x1="12" y1="17" x2="12.01" y2="17" />
    </svg>
  ),
  info: (
    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="text-blue-400">
      <circle cx="12" cy="12" r="10" />
      <line x1="12" y1="16" x2="12" y2="12" />
      <line x1="12" y1="8" x2="12.01" y2="8" />
    </svg>
  ),
};

export const Toast = ({
  id,
  title,
  description,
  variant = 'default',
  duration = 5000,
  onDismiss,
}: ToastProps) => {
  useEffect(() => {
    if (duration === Infinity) return;

    const timer = setTimeout(() => {
      onDismiss(id);
    }, duration);

    return () => clearTimeout(timer);
  }, [duration, id, onDismiss]);

  return (
    <div
      role="alert"
      className={cn(
        "pointer-events-auto relative flex w-full max-w-sm items-start gap-4 overflow-hidden rounded-2xl border p-4 shadow-lg transition-all",
        "animate-in slide-in-from-right-full fade-in duration-300",
        "bg-white dark:bg-[#0A0A0A]/90 backdrop-blur-md border-gray-200 dark:border-white/10",
        variant === 'error' && "border-rose-200 dark:border-rose-500/30 bg-rose-50 dark:bg-rose-500/10",
        variant === 'success' && "border-emerald-200 dark:border-emerald-500/20 bg-emerald-50 dark:bg-emerald-950/10",
        variant === 'warning' && "border-amber-200 dark:border-amber-500/20 bg-amber-50 dark:bg-amber-950/10",
        variant === 'info' && "border-blue-200 dark:border-blue-500/20 bg-blue-50 dark:bg-blue-950/10",
        variant === 'loading' && "border-blue-200 dark:border-blue-500/20 bg-blue-50 dark:bg-blue-950/10"
      )}
    >
      {variant !== 'default' && Icons[variant] && (
        <div className="shrink-0 pt-0.5">
          {Icons[variant]}
        </div>
      )}
      
      <div className="flex-1 gap-1">
        {title && <div className="text-sm font-semibold text-gray-900 dark:text-white">{title}</div>}
        {description && <div className="text-sm text-gray-600 dark:text-white/80">{description}</div>}
      </div>

      <button
        onClick={() => onDismiss(id)}
        className="shrink-0 rounded-md p-1 text-gray-400 dark:text-white/50 opacity-0 transition-opacity hover:text-gray-900 dark:hover:text-white group-hover:opacity-100 focus:opacity-100 focus:outline-none focus:ring-2 focus:ring-gray-400 dark:focus:ring-white/20"
      >
        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
          <line x1="18" y1="6" x2="6" y2="18" />
          <line x1="6" y1="6" x2="18" y2="18" />
        </svg>
      </button>
    </div>
  );
};



=== FILE: packages\ui\src\components\feedback\ToastProvider.tsx ===

import React, { createContext, useState, useCallback, useContext } from 'react';
import type { ToastProps} from './Toast';
import { Toast, ToastVariant } from './Toast';

export type ToastOptions = Omit<ToastProps, 'id' | 'onDismiss'>;

export interface ToastContextType {
  toast: (options: ToastOptions) => string;
  dismiss: (id: string) => void;
  promise: <T>(
    promise: Promise<T>,
    options: {
      loading: string | ToastOptions;
      success: string | ((data: T) => ToastOptions);
      error: string | ((error: any) => ToastOptions);
    }
  ) => Promise<T>;
}

export const ToastContext = createContext<ToastContextType | undefined>(undefined);

export function ToastProvider({ children }: { children: React.ReactNode }) {
  const [toasts, setToasts] = useState<ToastProps[]>([]);

  const dismiss = useCallback((id: string) => {
    setToasts((prev) => prev.filter((toast) => toast.id !== id));
  }, []);

  const toast = useCallback((options: ToastOptions) => {
    const id = Math.random().toString(36).substring(2, 9);
    setToasts((prev) => [...prev, { ...options, id, onDismiss: dismiss }]);
    return id;
  }, [dismiss]);

  const updateToast = useCallback((id: string, options: Partial<ToastOptions>) => {
    setToasts((prev) =>
      prev.map((t) => (t.id === id ? { ...t, ...options } : t))
    );
  }, []);

  const promise = useCallback(
    async <T,>(
      promise: Promise<T>,
      options: {
        loading: string | ToastOptions;
        success: string | ((data: T) => ToastOptions);
        error: string | ((error: any) => ToastOptions);
      }
    ) => {
      const loadingOptions = typeof options.loading === 'string' 
        ? { title: options.loading, variant: 'loading' as const } 
        : { variant: 'loading' as const, ...options.loading };
      
      const id = toast({ ...loadingOptions, duration: Infinity });

      try {
        const data = await promise;
        const successOptions = typeof options.success === 'function'
          ? options.success(data)
          : typeof options.success === 'string'
          ? { title: options.success, variant: 'success' as const }
          : options.success;

        updateToast(id, { ...successOptions, duration: 5000 });
        return data;
      } catch (err) {
        const errorOptions = typeof options.error === 'function'
          ? options.error(err)
          : typeof options.error === 'string'
          ? { title: options.error, variant: 'error' as const }
          : options.error;

        updateToast(id, { ...errorOptions, duration: 5000 });
        throw err;
      }
    },
    [toast, updateToast]
  );

  return (
    <ToastContext.Provider value={{ toast, dismiss, promise }}>
      {children}
      <div className="fixed bottom-0 right-0 z-[150] flex max-h-screen w-full flex-col-reverse gap-2 p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]">
        {toasts.map((toast) => (
          <Toast key={toast.id} {...toast} />
        ))}
      </div>
    </ToastContext.Provider>
  );
}



=== FILE: packages\ui\src\components\form\Checkbox.tsx ===

import React from 'react';
import { cn } from '../../utils/cn';
import { Label } from './Label';

export interface CheckboxProps extends Omit<React.ButtonHTMLAttributes<HTMLButtonElement>, 'onChange'> {
  label?: string;
  error?: string;
  checked?: boolean;
  defaultChecked?: boolean;
  onChange?: (event: { target: { checked: boolean } }) => void;
}

export const Checkbox = React.forwardRef<HTMLButtonElement, CheckboxProps>(
  ({ className, label, error, id, disabled, checked, defaultChecked, onChange, ...props }, ref) => {
    const inputId = id || React.useId();
    const [isChecked, setIsChecked] = React.useState(defaultChecked || checked || false);

    React.useEffect(() => {
      if (checked !== undefined) {
        setIsChecked(checked);
      }
    }, [checked]);

    const handleClick = () => {
      if (disabled) return;
      const newValue = !isChecked;
      setIsChecked(newValue);
      if (onChange) {
        onChange({ target: { checked: newValue } } as any);
      }
    };

    return (
      <div className={cn("flex flex-col gap-1.5", className)}>
        <button
          ref={ref}
          type="button"
          id={inputId}
          role="checkbox"
          aria-checked={isChecked}
          aria-label={label}
          onClick={handleClick}
          disabled={disabled}
          className={cn(
            'flex items-center gap-3 rounded-2xl border border-gray-200 dark:border-white/10 bg-gray-50 dark:bg-white/[0.03] px-4 py-3',
            'hover:bg-gray-100 dark:hover:bg-white/[0.04] transition-colors',
            disabled && 'opacity-50 cursor-not-allowed'
          )}
          {...props}
        >
          <span
            aria-hidden="true"
            className={cn(
              'grid h-6 w-6 place-items-center rounded-lg border',
              isChecked 
                ? 'border-emerald-400/30 bg-emerald-400/15' 
                : 'border-gray-300 dark:border-white/10 bg-white dark:bg-white/[0.02]'
            )}
          >
            {isChecked ? (
              <svg className="h-4 w-4 text-emerald-200" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={3}>
                <path strokeLinecap="round" strokeLinejoin="round" d="M4.5 12.75l6 6 9-13.5" />
              </svg>
            ) : null}
          </span>
          {label && (
            <span className="text-sm text-gray-700 dark:text-white/70">{label}</span>
          )}
        </button>
        {error && (
          <p className="text-xs text-rose-500 mt-1 ml-1">{error}</p>
        )}
      </div>
    );
  }
);

Checkbox.displayName = 'Checkbox';



=== FILE: packages\ui\src\components\form\ColorPicker.tsx ===

import React from 'react';
import { cn } from '../../utils/cn';
import { Label } from './Label';

export interface ColorPickerProps {
  label?: string;
  value: string;
  onChange: (value: string) => void;
  error?: string;
  className?: string;
}

/**
 * A styled color picker component.
 */
export function ColorPicker({
  label,
  value,
  onChange,
  error,
  className,
}: ColorPickerProps) {
  return (
    <div className={cn('flex flex-col gap-1.5', className)}>
      {label && <Label>{label}</Label>}
      
      <div className="flex items-center gap-3">
        <div 
          className="h-10 w-10 rounded-xl border border-gray-200 dark:border-white/10 overflow-hidden relative"
          style={{ backgroundColor: value }}
        >
          <input
            type="color"
            value={value}
            onChange={(e) => onChange(e.target.value)}
            className="absolute inset-0 opacity-0 cursor-pointer w-full h-full"
          />
        </div>
        <input
          type="text"
          value={value}
          onChange={(e) => onChange(e.target.value)}
          className="flex-1 rounded-2xl bg-gray-50 dark:bg-white/[0.04] px-4 py-2 border border-gray-200 dark:border-white/[0.10] text-sm focus:outline-none focus:ring-2 focus:ring-purple-400/30 transition-all"
        />
      </div>

      {error && (
        <p className="text-xs text-rose-400">
          {error}
        </p>
      )}
    </div>
  );
}



=== FILE: packages\ui\src\components\form\Combobox.tsx ===

import React, { createContext, useContext, useState, useMemo, useEffect } from 'react';
import { Popover, PopoverContent, PopoverTrigger } from '../overlay/Popover';
import { cn } from '../../utils/cn';

interface ComboboxContextValue {
  value: string;
  onValueChange: (value: string) => void;
  searchTerm: string;
  setSearchTerm: (term: string) => void;
  isOpen: boolean;
  setIsOpen: (isOpen: boolean) => void;
  registerItem: (id: string, text: string, value: string) => () => void;
  isItemVisible: (id: string, text: string) => boolean;
  hasVisibleItems: boolean;
  activeIndex: number;
  setActiveIndex: React.Dispatch<React.SetStateAction<number>>;
  visibleItems: { id: string, value: string }[];
}

const ComboboxContext = createContext<ComboboxContextValue | undefined>(undefined);

export interface ComboboxProps {
  children: React.ReactNode;
  value?: string;
  defaultValue?: string;
  onValueChange?: (value: string) => void;
  filter?: (value: string, search: string) => boolean;
  usePopover?: boolean;
}

export function Combobox({ 
  children, 
  value: controlledValue, 
  defaultValue = '', 
  onValueChange,
  filter = (text, search) => text.toLowerCase().includes(search.toLowerCase()),
  usePopover = true
}: ComboboxProps) {
  const [internalValue, setInternalValue] = useState(defaultValue);
  const [searchTerm, setSearchTerm] = useState('');
  const [isOpen, setIsOpen] = useState(false);
  const [items, setItems] = useState<Map<string, { text: string, value: string }>>(new Map());
  const [activeIndex, setActiveIndex] = useState(-1);

  const isControlled = controlledValue !== undefined;
  const value = isControlled ? controlledValue : internalValue;

  const handleValueChange = (newValue: string) => {
    if (!isControlled) setInternalValue(newValue);
    onValueChange?.(newValue);
    setIsOpen(false);
    setSearchTerm('');
  };

  const registerItem = React.useCallback((id: string, text: string, value: string) => {
    setItems(prev => {
      const next = new Map(prev);
      next.set(id, { text, value });
      return next;
    });
    return () => {
      setItems(prev => {
        const next = new Map(prev);
        next.delete(id);
        return next;
      });
    };
  }, []);

  const visibleItems = useMemo(() => {
    return Array.from(items.entries())
      .filter(([_, item]) => filter(item.text, searchTerm))
      .map(([id, item]) => ({ id, value: item.value }));
  }, [items, searchTerm, filter]);

  const hasVisibleItems = visibleItems.length > 0;

  useEffect(() => {
    if (isOpen) {
      setActiveIndex(0);
    } else {
      setActiveIndex(-1);
    }
  }, [isOpen]);

  return (
    <ComboboxContext.Provider value={{ 
      value, 
      onValueChange: handleValueChange, 
      searchTerm, 
      setSearchTerm, 
      isOpen, 
      setIsOpen,
      registerItem,
      isItemVisible: (id, text) => filter(text, searchTerm),
      hasVisibleItems,
      activeIndex,
      setActiveIndex,
      visibleItems
    }}>
      {usePopover ? (
        <Popover open={isOpen} onOpenChange={setIsOpen}>
          {children}
        </Popover>
      ) : (
        children
      )}
    </ComboboxContext.Provider>
  );
}

export function ComboboxTrigger({ className, children, ...props }: React.ButtonHTMLAttributes<HTMLButtonElement>) {
  const context = useContext(ComboboxContext);
  return (
    <PopoverTrigger
      role="combobox"
      aria-expanded={context?.isOpen}
      aria-haspopup="listbox"
      className={cn(
        "flex h-10 w-full items-center justify-between rounded-2xl border border-gray-200 bg-gray-50 px-3 py-2 text-sm text-gray-900 placeholder:text-gray-500 focus:border-purple-500 focus:outline-none focus:ring-2 focus:ring-purple-500/20 disabled:cursor-not-allowed disabled:opacity-50 dark:border-white/10 dark:bg-white/[0.03] dark:text-white dark:placeholder:text-white/40 dark:focus:border-white/20 dark:focus:ring-white/10",
        className
      )}
      {...props}
    >
      {children}
      <svg
        xmlns="http://www.w3.org/2000/svg"
        width="16"
        height="16"
        viewBox="0 0 24 24"
        fill="none"
        stroke="currentColor"
        strokeWidth="2"
        strokeLinecap="round"
        strokeLinejoin="round"
        className="ml-2 opacity-50"
      >
        <path d="m6 9 6 6 6-6"/>
      </svg>
    </PopoverTrigger>
  );
}

export function ComboboxContent({ className, children, ...props }: React.HTMLAttributes<HTMLDivElement>) {
  return (
    <PopoverContent className={cn("p-0 w-[200px]", className)} align="start" {...props}>
      {children}
    </PopoverContent>
  );
}

export function ComboboxInput({ className, placeholder = "Search...", ...props }: React.InputHTMLAttributes<HTMLInputElement>) {
  const context = useContext(ComboboxContext);
  if (!context) throw new Error('ComboboxInput must be used within Combobox');

  const handleKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {
    if (e.key === 'ArrowDown') {
      e.preventDefault();
      context.setActiveIndex((prev) => (prev + 1) % context.visibleItems.length);
    } else if (e.key === 'ArrowUp') {
      e.preventDefault();
      context.setActiveIndex((prev) => (prev - 1 + context.visibleItems.length) % context.visibleItems.length);
    } else if (e.key === 'Enter') {
      e.preventDefault();
      if (context.activeIndex !== -1 && context.visibleItems[context.activeIndex]) {
        context.onValueChange(context.visibleItems[context.activeIndex]!.value);
      }
    } else if (e.key === 'Escape') {
      context.setIsOpen(false);
    }
    props.onKeyDown?.(e);
  };

  return (
    <div className="flex items-center border-b border-gray-200 dark:border-white/10 px-3">
      <svg
        className="mr-2 h-4 w-4 shrink-0 opacity-50"
        xmlns="http://www.w3.org/2000/svg"
        width="24"
        height="24"
        viewBox="0 0 24 24"
        fill="none"
        stroke="currentColor"
        strokeWidth="2"
        strokeLinecap="round"
        strokeLinejoin="round"
      >
        <circle cx="11" cy="11" r="8" />
        <path d="m21 21-4.3-4.3" />
      </svg>
      <input
        className={cn(
          "flex h-10 w-full rounded-md bg-transparent py-3 text-sm text-gray-900 dark:text-white outline-none placeholder:text-gray-400 dark:placeholder:text-white/40 disabled:cursor-not-allowed disabled:opacity-50",
          className
        )}
        placeholder={placeholder}
        value={context.searchTerm}
        onChange={(e) => context.setSearchTerm(e.target.value)}
        onKeyDown={handleKeyDown}
        aria-autocomplete="list"
        aria-activedescendant={context.activeIndex !== -1 ? context.visibleItems[context.activeIndex]?.id : undefined}
        {...props}
      />
    </div>
  );
}

export function ComboboxList({ className, children, ...props }: React.HTMLAttributes<HTMLDivElement>) {
  return (
    <div 
      role="listbox"
      className={cn("max-h-[300px] overflow-y-auto overflow-x-hidden p-1", className)} 
      {...props}
    >
      {children}
    </div>
  );
}

export function ComboboxEmpty({ className, children, ...props }: React.HTMLAttributes<HTMLDivElement>) {
  const context = useContext(ComboboxContext);
  if (!context) throw new Error('ComboboxEmpty must be used within Combobox');

  if (context.hasVisibleItems) return null;

  return (
    <div className={cn("py-6 text-center text-sm text-gray-500 dark:text-white/40", className)} {...props}>
      {children}
    </div>
  );
}

export interface ComboboxItemProps extends React.HTMLAttributes<HTMLDivElement> {
  value: string;
  children: React.ReactNode;
  textValue?: string;
}

export function ComboboxItem({ className, value, children, textValue, ...props }: ComboboxItemProps) {
  const context = useContext(ComboboxContext);
  if (!context) throw new Error('ComboboxItem must be used within Combobox');

  const id = React.useId();
  const text = textValue || (typeof children === 'string' ? children : value);
  const isVisible = context.isItemVisible(id, text);
  const isSelected = context.value === value;
  
  const itemIndex = context.visibleItems.findIndex(item => item.id === id);
  const isActive = context.activeIndex === itemIndex;

  useEffect(() => {
    return context.registerItem(id, text, value);
  }, [id, text, value, context.registerItem]);

  if (!isVisible) return null;

  return (
    <div
      id={id}
      role="option"
      aria-selected={isSelected}
      onClick={() => context.onValueChange(value)}
      onMouseEnter={() => context.setActiveIndex(itemIndex)}
      className={cn(
        "relative flex cursor-default select-none items-center rounded-2xl px-3 py-2 text-sm outline-none transition-colors",
        "text-gray-700 dark:text-white/80",
        "aria-selected:bg-gray-100 aria-selected:text-gray-900 dark:aria-selected:bg-white/[0.06] dark:aria-selected:text-white",
        "data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
        "hover:bg-gray-100 hover:text-gray-900 dark:hover:bg-white/[0.06] dark:hover:text-white",
        (isSelected || isActive) && "bg-gray-100 text-gray-900 dark:bg-white/[0.06] dark:text-white",
        className
      )}
      {...props}
    >
      <svg
        className={cn(
          "mr-2 h-4 w-4",
          isSelected ? "opacity-100" : "opacity-0"
        )}
        xmlns="http://www.w3.org/2000/svg"
        width="24"
        height="24"
        viewBox="0 0 24 24"
        fill="none"
        stroke="currentColor"
        strokeWidth="2"
        strokeLinecap="round"
        strokeLinejoin="round"
      >
        <polyline points="20 6 9 17 4 12" />
      </svg>
      {children}
    </div>
  );
}



=== FILE: packages\ui\src\components\form\DatePicker.tsx ===

import React, { useState } from 'react';
import { Popover, PopoverContent, PopoverTrigger } from '../overlay/Popover';
import { Calendar } from '../data-display/Calendar';
import { cn } from '../../utils/cn';
import { Calendar as CalendarIcon } from 'lucide-react';

export interface DatePickerProps {
  value?: Date;
  onChange?: (date: Date) => void;
  placeholder?: string;
  className?: string;
}

export function DatePicker({ value, onChange, placeholder = "Pick a date", className }: DatePickerProps) {
  const [date, setDate] = useState<Date | undefined>(value);
  const [isOpen, setIsOpen] = useState(false);

  const handleSelect = (newDate: Date) => {
    setDate(newDate);
    onChange?.(newDate);
    setIsOpen(false);
  };

  const formatDate = (d: Date) => {
    return d.toLocaleDateString('en-US', {
      month: 'long',
      day: 'numeric',
      year: 'numeric',
    });
  };

  const handleMouseMove = (e: React.MouseEvent<HTMLButtonElement>) => {
    const rect = e.currentTarget.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    e.currentTarget.style.setProperty('--x', `${x}px`);
    e.currentTarget.style.setProperty('--y', `${y}px`);
  };

  return (
    <Popover open={isOpen} onOpenChange={setIsOpen}>
      <PopoverTrigger
        onMouseMove={handleMouseMove}
        className={cn(
          "group relative flex h-11 w-full items-center justify-between rounded-2xl border border-gray-200 dark:border-white/10 bg-gray-50 dark:bg-white/[0.03] px-4 py-2 text-sm text-gray-900 dark:text-white transition-all duration-200 overflow-hidden",
          "hover:bg-gray-100 dark:hover:bg-white/[0.06] focus:outline-none focus:ring-2 focus:ring-gray-400 dark:focus:ring-white/15",
          !date && "text-gray-400 dark:text-white/40",
          className
        )}
      >
        <div className="absolute inset-0 opacity-0 group-hover:opacity-100 transition-opacity duration-500 pointer-events-none"
             style={{
               background: `radial-gradient(600px circle at var(--x) var(--y), rgba(255,255,255,0.06), transparent 40%)`
             }}
        />
        <span className="relative z-10">{date ? formatDate(date) : placeholder}</span>
        <CalendarIcon className="relative z-10 h-4 w-4 text-white/40" />
      </PopoverTrigger>
      <PopoverContent className="w-auto p-0 border-none bg-transparent shadow-none" align="start">
        <Calendar
          value={date}
          onChange={handleSelect}
          className="shadow-2xl shadow-black/50"
        />
      </PopoverContent>
    </Popover>
  );
}



=== FILE: packages\ui\src\components\form\DateTimePicker.tsx ===

import React, { useState, useEffect } from 'react';
import { Popover, PopoverContent, PopoverTrigger } from '../overlay/Popover';
import { Calendar } from '../data-display/Calendar';
import { ScrollArea } from '../data-display/ScrollArea';
import { cn } from '../../utils/cn';
import { Calendar as CalendarIcon, Clock } from 'lucide-react';

export interface DateTimePickerProps {
  value?: Date;
  onChange?: (date: Date) => void;
  placeholder?: string;
  className?: string;
}

export function DateTimePicker({ value, onChange, placeholder = "Pick date & time", className }: DateTimePickerProps) {
  const [date, setDate] = useState<Date | undefined>(value);
  const [isOpen, setIsOpen] = useState(false);
  
  // Time state
  const [hours, setHours] = useState(value ? value.getHours() : 12);
  const [minutes, setMinutes] = useState(value ? value.getMinutes() : 0);

  useEffect(() => {
    if (value) {
      setDate(value);
      setHours(value.getHours());
      setMinutes(value.getMinutes());
    }
  }, [value]);

  const handleDateSelect = (newDate: Date) => {
    const updatedDate = new Date(newDate);
    updatedDate.setHours(hours);
    updatedDate.setMinutes(minutes);
    setDate(updatedDate);
    onChange?.(updatedDate);
  };

  const handleTimeChange = (type: 'hours' | 'minutes', val: string) => {
    let num = parseInt(val, 10);
    if (isNaN(num)) return;

    let newHours = hours;
    let newMinutes = minutes;

    if (type === 'hours') {
      num = Math.max(0, Math.min(23, num));
      setHours(num);
      newHours = num;
    } else {
      num = Math.max(0, Math.min(59, num));
      setMinutes(num);
      newMinutes = num;
    }

    const baseDate = date || new Date();
    const updatedDate = new Date(baseDate);
    updatedDate.setHours(newHours);
    updatedDate.setMinutes(newMinutes);
    setDate(updatedDate);
    onChange?.(updatedDate);
  };

  const formatDateTime = (d: Date) => {
    return d.toLocaleDateString('en-US', {
      month: 'short',
      day: 'numeric',
      year: 'numeric',
      hour: '2-digit',
      minute: '2-digit',
    });
  };

  const handleMouseMove = (e: React.MouseEvent<HTMLButtonElement>) => {
    const rect = e.currentTarget.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    e.currentTarget.style.setProperty('--x', `${x}px`);
    e.currentTarget.style.setProperty('--y', `${y}px`);
  };

  return (
    <Popover open={isOpen} onOpenChange={setIsOpen}>
      <PopoverTrigger
        onMouseMove={handleMouseMove}
        className={cn(
          "group relative flex h-11 w-full items-center justify-between rounded-2xl border border-gray-200 dark:border-white/10 bg-gray-50 dark:bg-white/[0.03] px-4 py-2 text-sm text-gray-900 dark:text-white transition-all duration-200 overflow-hidden",
          "hover:bg-gray-100 dark:hover:bg-white/[0.06] focus:outline-none focus:ring-2 focus:ring-gray-400 dark:focus:ring-white/15",
          !date && "text-gray-400 dark:text-white/40",
          className
        )}
      >
        <div className="absolute inset-0 opacity-0 group-hover:opacity-100 transition-opacity duration-500 pointer-events-none"
             style={{
               background: `radial-gradient(600px circle at var(--x) var(--y), rgba(0,0,0,0.06), transparent 40%)`
             }}
        />
        <span className="relative z-10">{date ? formatDateTime(date) : placeholder}</span>
        <div className="flex items-center gap-2 text-gray-400 dark:text-white/40">
          <CalendarIcon className="h-4 w-4" />
          <Clock className="h-4 w-4" />
        </div>
      </PopoverTrigger>
      <PopoverContent className="w-auto p-0 border-none bg-transparent shadow-none" align="start">
        <div className="flex flex-col rounded-2xl border border-gray-200 dark:border-white/10 bg-white dark:bg-black/40 backdrop-blur-xl shadow-2xl dark:shadow-black/50">
          <div className="flex">
            <div className="p-4 border-r border-gray-200 dark:border-white/10">
              <Calendar
                value={date}
                onChange={handleDateSelect}
                className="border-0 p-0 bg-transparent backdrop-blur-none shadow-none rounded-none"
              />
            </div>
            
            <div className="flex flex-col p-4 w-[160px] h-[340px]">
              <div className="mb-3 text-sm font-medium text-gray-700 dark:text-white/70">Time</div>
              <div className="flex flex-1 gap-2 min-h-0 overflow-hidden">
                <ScrollArea className="flex-1 flex flex-col gap-1" scrollbarSize="sm">
                  <div className="text-xs text-gray-400 dark:text-white/40 text-center mb-1 sticky top-0 bg-white dark:bg-[#0A0A0A] py-1 z-10">Hr</div>
                  <div className="flex flex-col gap-1">
                    {Array.from({ length: 24 }).map((_, i) => (
                      <button
                        key={i}
                        onClick={() => handleTimeChange('hours', i.toString())}
                        className={cn(
                          "w-full rounded-lg px-1 py-1.5 text-sm transition-colors text-center shrink-0",
                          hours === i 
                            ? "bg-emerald-500 dark:bg-emerald-600/80 text-white font-medium" 
                            : "text-gray-700 dark:text-white/70 hover:bg-gray-100 dark:hover:bg-white/[0.06] hover:text-gray-900 dark:hover:text-white"
                        )}
                      >
                        {i.toString().padStart(2, '0')}
                      </button>
                    ))}
                  </div>
                </ScrollArea>
                <div className="w-[1px] bg-gray-200 dark:bg-white/[0.06]" />
                <ScrollArea className="flex-1 flex flex-col gap-1" scrollbarSize="sm">
                  <div className="text-xs text-gray-400 dark:text-white/40 text-center mb-1 sticky top-0 bg-white dark:bg-[#0A0A0A] py-1 z-10">Min</div>
                  <div className="flex flex-col gap-1">
                    {Array.from({ length: 60 }).map((_, i) => (
                      <button
                        key={i}
                        onClick={() => handleTimeChange('minutes', i.toString())}
                        className={cn(
                          "w-full rounded-lg px-1 py-1.5 text-sm transition-colors text-center shrink-0",
                          minutes === i 
                            ? "bg-emerald-500 dark:bg-emerald-600/80 text-white font-medium" 
                            : "text-gray-700 dark:text-white/70 hover:bg-gray-100 dark:hover:bg-white/[0.06] hover:text-gray-900 dark:hover:text-white"
                        )}
                      >
                        {i.toString().padStart(2, '0')}
                      </button>
                    ))}
                  </div>
                </ScrollArea>
              </div>
            </div>
          </div>
        </div>
      </PopoverContent>
    </Popover>
  );
}



=== FILE: packages\ui\src\components\form\FileDropzone.tsx ===

import React, { useState } from 'react';
import { cva, type VariantProps } from 'class-variance-authority';
import { Upload, X, File as FileIcon } from 'lucide-react';
import { cn } from '../../utils/cn';

const dropzoneVariants = cva(
  "relative flex flex-col items-center justify-center rounded-2xl border-2 border-dashed transition-all duration-200 text-center",
  {
    variants: {
      isDragActive: {
        true: "border-blue-500 bg-blue-50 dark:bg-blue-500/10",
        false: "border-gray-200 bg-gray-50 hover:bg-gray-100 dark:border-white/10 dark:bg-white/[0.02] dark:hover:bg-white/[0.05]",
      },
      error: {
        true: "border-rose-500 bg-rose-50 dark:bg-rose-500/10",
        false: "",
      }
    },
    defaultVariants: {
      isDragActive: false,
      error: false,
    },
  }
);

export interface FileDropzoneProps extends Omit<React.HTMLAttributes<HTMLDivElement>, 'onDrop'> {
  onDrop?: (files: File[]) => void;
  accept?: Record<string, string[]>; // e.g. { 'image/*': ['.png', '.jpg'] }
  maxFiles?: number;
  maxSize?: number; // in bytes
  label?: string;
  description?: string;
}

export const FileDropzone = React.forwardRef<HTMLDivElement, FileDropzoneProps>(
  ({ className, onDrop, maxFiles = 1, maxSize, label = "Upload files", description = "Drag & drop or click to upload", ...props }, ref) => {
    const [isDragActive, setIsDragActive] = useState(false);
    const [files, setFiles] = useState<File[]>([]);
    const [error, setError] = useState<string | null>(null);
    const inputRef = React.useRef<HTMLInputElement>(null);

    const handleDragOver = (e: React.DragEvent) => {
      e.preventDefault();
      setIsDragActive(true);
    };

    const handleDragLeave = (e: React.DragEvent) => {
      e.preventDefault();
      setIsDragActive(false);
    };

    const validateFiles = (fileList: File[]) => {
      if (maxFiles && fileList.length > maxFiles) {
        setError(`Max ${maxFiles} files allowed`);
        return false;
      }
      if (maxSize) {
        const oversized = fileList.some(f => f.size > maxSize);
        if (oversized) {
          setError(`File too large (max ${maxSize / 1024 / 1024}MB)`);
          return false;
        }
      }
      setError(null);
      return true;
    };

    const handleDrop = (e: React.DragEvent) => {
      e.preventDefault();
      setIsDragActive(false);
      
      const droppedFiles = Array.from(e.dataTransfer.files);
      if (validateFiles(droppedFiles)) {
        setFiles(droppedFiles);
        onDrop?.(droppedFiles);
      }
    };

    const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
      if (e.target.files) {
        const selectedFiles = Array.from(e.target.files);
        if (validateFiles(selectedFiles)) {
          setFiles(selectedFiles);
          onDrop?.(selectedFiles);
        }
      }
    };

    const removeFile = (index: number, e: React.MouseEvent) => {
      e.stopPropagation();
      const newFiles = files.filter((_, i) => i !== index);
      setFiles(newFiles);
      onDrop?.(newFiles);
    };

    return (
      <div className="w-full space-y-4">
        <div
          ref={ref}
          className={cn(dropzoneVariants({ isDragActive, error: !!error, className }), "p-8 cursor-pointer")}
          onDragOver={handleDragOver}
          onDragLeave={handleDragLeave}
          onDrop={handleDrop}
          onClick={() => inputRef.current?.click()}
          {...props}
        >
          <input 
            ref={inputRef}
            type="file" 
            className="hidden" 
            multiple={maxFiles > 1} 
            onChange={handleChange} 
          />
          
          <div className="mb-4 rounded-full bg-gray-100 p-3 dark:bg-white/[0.06]">
            <Upload className="h-6 w-6 text-gray-500 dark:text-white/70" />
          </div>
          <div className="text-sm font-medium text-gray-900 dark:text-white">
            {label}
          </div>
          <div className="mt-1 text-xs text-gray-500 dark:text-white/50">
            {description}
          </div>
          {error && (
            <div className="mt-2 text-xs font-medium text-rose-500">
              {error}
            </div>
          )}
        </div>

        {files.length > 0 && (
          <div className="grid gap-2">
            {files.map((file, i) => (
              <div key={i} className="flex items-center justify-between rounded-xl border border-gray-200 bg-white p-3 dark:border-white/10 dark:bg-white/[0.03]">
                <div className="flex items-center gap-3">
                  <div className="flex h-8 w-8 items-center justify-center rounded-lg bg-gray-100 dark:bg-white/[0.06]">
                    <FileIcon className="h-4 w-4 text-gray-500 dark:text-white/70" />
                  </div>
                  <div className="flex flex-col">
                    <span className="text-sm font-medium text-gray-900 dark:text-white truncate max-w-[200px]">{file.name}</span>
                    <span className="text-xs text-gray-500 dark:text-white/50">{(file.size / 1024).toFixed(1)} KB</span>
                  </div>
                </div>
                <button 
                  onClick={(e) => removeFile(i, e)}
                  className="rounded-full p-1 hover:bg-gray-100 dark:hover:bg-white/[0.06] text-gray-500 dark:text-white/50"
                >
                  <X className="h-4 w-4" />
                </button>
              </div>
            ))}
          </div>
        )}
      </div>
    );
  }
);
FileDropzone.displayName = 'FileDropzone';



=== FILE: packages\ui\src\components\form\Form.tsx ===

import React from 'react';
import { cn } from '../../utils/cn';
import { Label } from './Label';

type FormItemContextValue = {
  id: string;
};

const FormItemContext = React.createContext<FormItemContextValue>({} as FormItemContextValue);

export const FormItem = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(
  ({ className, ...props }, ref) => {
    const id = React.useId();
    return (
      <FormItemContext.Provider value={{ id }}>
        <div ref={ref} className={cn("space-y-2", className)} {...props} />
      </FormItemContext.Provider>
    );
  }
);
FormItem.displayName = "FormItem";

export const FormLabel = React.forwardRef<React.ElementRef<typeof Label>, React.ComponentPropsWithoutRef<typeof Label>>(
  ({ className, ...props }, ref) => {
    const { id } = React.useContext(FormItemContext);
    return (
      <Label
        ref={ref}
        className={cn("text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70", className)}
        htmlFor={id}
        {...props}
      />
    );
  }
);
FormLabel.displayName = "FormLabel";

export const FormControl = React.forwardRef<React.ElementRef<"div">, React.HTMLAttributes<HTMLDivElement>>(
  ({ ...props }, ref) => {
    const { id } = React.useContext(FormItemContext);
    const { children, ...rest } = props;
    
    if (React.isValidElement(children)) {
        return React.cloneElement(children as React.ReactElement, {
            id,
            "aria-describedby": `${id}-description ${id}-message`,
            ...rest,
            ...(children.props as any)
        });
    }
    return <div ref={ref} {...props} />;
  }
);
FormControl.displayName = "FormControl";

export const FormDescription = React.forwardRef<HTMLParagraphElement, React.HTMLAttributes<HTMLParagraphElement>>(
  ({ className, ...props }, ref) => {
    const { id } = React.useContext(FormItemContext);
    return (
      <p
        ref={ref}
        id={`${id}-description`}
        className={cn("text-xs text-white/50", className)}
        {...props}
      />
    );
  }
);
FormDescription.displayName = "FormDescription";

export const FormMessage = React.forwardRef<HTMLParagraphElement, React.HTMLAttributes<HTMLParagraphElement>>(
  ({ className, children, ...props }, ref) => {
    const { id } = React.useContext(FormItemContext);
    
    if (!children) {
      return null;
    }

    return (
      <p
        ref={ref}
        id={`${id}-message`}
        className={cn("text-xs font-medium text-rose-500", className)}
        {...props}
      >
        {children}
      </p>
    );
  }
);
FormMessage.displayName = "FormMessage";



=== FILE: packages\ui\src\components\form\Label.tsx ===

import React from 'react';
import { cn } from '../../utils/cn';

export interface LabelProps extends React.LabelHTMLAttributes<HTMLLabelElement> {
  required?: boolean;
}

export const Label = React.forwardRef<HTMLLabelElement, LabelProps>(
  ({ className, children, required, ...props }, ref) => {
    return (
      <label
        ref={ref}
        className={cn(
          'text-sm font-medium leading-none text-gray-700 dark:text-white/80 peer-disabled:cursor-not-allowed peer-disabled:opacity-70',
          className
        )}
        {...props}
      >
        {children}
        {required && <span className="ml-1 text-rose-500">*</span>}
      </label>
    );
  }
);

Label.displayName = 'Label';



=== FILE: packages\ui\src\components\form\NumberInput.tsx ===

import React from 'react';
import { cva, type VariantProps } from 'class-variance-authority';
import { Minus, Plus } from 'lucide-react';
import { cn } from '../../utils/cn';
import { Button } from '../button/Button';

const numberInputVariants = cva(
  "flex items-center rounded-2xl border bg-gray-50 dark:bg-white/[0.03] dark:border-white/10",
  {
    variants: {
      size: {
        sm: "h-8",
        md: "h-10",
        lg: "h-12",
      },
      error: {
        true: "border-rose-500",
        false: "border-gray-200",
      }
    },
    defaultVariants: {
      size: "md",
      error: false
    }
  }
);

export interface NumberInputProps extends Omit<React.InputHTMLAttributes<HTMLInputElement>, 'size' | 'onChange'>, VariantProps<typeof numberInputVariants> {
  value?: number;
  onChange?: (value: number) => void;
  min?: number;
  max?: number;
  step?: number;
}

export const NumberInput = React.forwardRef<HTMLInputElement, NumberInputProps>(
  ({ className, size, error, value = 0, onChange, min = -Infinity, max = Infinity, step = 1, disabled, ...props }, ref) => {
    
    const handleDecrement = () => {
      if (value - step >= min) {
        onChange?.(value - step);
      }
    };

    const handleIncrement = () => {
      if (value + step <= max) {
        onChange?.(value + step);
      }
    };

    const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
      const val = parseFloat(e.target.value);
      if (!isNaN(val)) {
        onChange?.(val);
      }
    };

    return (
      <div className={cn(numberInputVariants({ size, error, className }))}>
        <button
          type="button"
          onClick={handleDecrement}
          disabled={disabled || value <= min}
          className="flex h-full items-center justify-center px-3 text-gray-500 hover:text-gray-900 disabled:opacity-50 dark:text-white/50 dark:hover:text-white"
        >
          <Minus className="h-3.5 w-3.5" />
        </button>
        
        <div className="h-full w-px bg-gray-200 dark:bg-white/[0.06]" />
        
        <input
          ref={ref}
          type="number"
          value={value}
          onChange={handleChange}
          disabled={disabled}
          className="h-full w-full min-w-[3rem] bg-transparent text-center text-sm font-medium text-gray-900 focus:outline-none dark:text-white"
          {...props}
        />
        
        <div className="h-full w-px bg-gray-200 dark:bg-white/[0.06]" />
        
        <button
          type="button"
          onClick={handleIncrement}
          disabled={disabled || value >= max}
          className="flex h-full items-center justify-center px-3 text-gray-500 hover:text-gray-900 disabled:opacity-50 dark:text-white/50 dark:hover:text-white"
        >
          <Plus className="h-3.5 w-3.5" />
        </button>
      </div>
    );
  }
);
NumberInput.displayName = "NumberInput";



=== FILE: packages\ui\src\components\form\OTPInput.tsx ===

import React, { useState, useRef, useEffect } from 'react';
import { cva, type VariantProps } from 'class-variance-authority';
import { cn } from '../../utils/cn';

const otpInputVariants = cva(
  "flex items-center gap-2",
  {
    variants: {
      size: {
        sm: "[&>input]:h-8 [&>input]:w-8 [&>input]:text-sm",
        md: "[&>input]:h-10 [&>input]:w-10 [&>input]:text-base",
        lg: "[&>input]:h-12 [&>input]:w-12 [&>input]:text-lg",
      }
    },
    defaultVariants: {
      size: "md"
    }
  }
);

export interface OTPInputProps extends Omit<React.HTMLAttributes<HTMLDivElement>, 'onChange'>, VariantProps<typeof otpInputVariants> {
  length?: number;
  value?: string;
  onChange?: (value: string) => void;
  onComplete?: (value: string) => void;
  disabled?: boolean;
  error?: boolean;
}

export const OTPInput = React.forwardRef<HTMLDivElement, OTPInputProps>(
  ({ className, size, length = 6, value = "", onChange, onComplete, disabled, error, ...props }, ref) => {
    const [localValue, setLocalValue] = useState<string[]>(new Array(length).fill(""));
    const inputsRef = useRef<(HTMLInputElement | null)[]>([]);

    useEffect(() => {
      const val = value.split("").slice(0, length);
      const newVal = [...val, ...new Array(length - val.length).fill("")];
      setLocalValue(newVal);
    }, [value, length]);

    const handleChange = (e: React.ChangeEvent<HTMLInputElement>, index: number) => {
      const val = e.target.value;
      if (isNaN(Number(val))) return;

      const newLocalValue = [...localValue];
      // Take the last character if multiple (paste scenario handled separately usually, but simple here)
      newLocalValue[index] = val.substring(val.length - 1);
      
      setLocalValue(newLocalValue);
      const stringValue = newLocalValue.join("");
      onChange?.(stringValue);

      if (val && index < length - 1) {
        inputsRef.current[index + 1]?.focus();
      }

      if (stringValue.length === length) {
        onComplete?.(stringValue);
      }
    };

    const handleKeyDown = (e: React.KeyboardEvent<HTMLInputElement>, index: number) => {
      if (e.key === "Backspace" && !localValue[index] && index > 0) {
        inputsRef.current[index - 1]?.focus();
      }
    };

    const handlePaste = (e: React.ClipboardEvent) => {
      e.preventDefault();
      const pastedData = e.clipboardData.getData("text/plain").slice(0, length);
      if (!/^\d+$/.test(pastedData)) return;

      const newLocalValue = [...localValue];
      pastedData.split("").forEach((char, i) => {
        newLocalValue[i] = char;
      });
      setLocalValue(newLocalValue);
      const stringValue = newLocalValue.join("");
      onChange?.(stringValue);
      if (stringValue.length === length) onComplete?.(stringValue);
      inputsRef.current[Math.min(pastedData.length, length - 1)]?.focus();
    };

    return (
      <div ref={ref} className={cn(otpInputVariants({ size, className }))} {...props}>
        {localValue.map((digit, index) => (
          <input
            key={index}
            ref={el => inputsRef.current[index] = el}
            type="text"
            inputMode="numeric"
            maxLength={1}
            value={digit}
            disabled={disabled}
            onChange={(e) => handleChange(e, index)}
            onKeyDown={(e) => handleKeyDown(e, index)}
            onPaste={handlePaste}
            className={cn(
              "rounded-2xl border bg-gray-50 text-center font-semibold transition-all duration-200",
              "focus:border-blue-500 focus:ring-2 focus:ring-blue-500/20 focus:outline-none",
              "disabled:opacity-50 disabled:cursor-not-allowed",
              "dark:bg-white/[0.03] dark:text-white",
              error 
                ? "border-rose-500 text-rose-500 focus:border-rose-500 focus:ring-rose-500/20" 
                : "border-gray-200 dark:border-white/10"
            )}
          />
        ))}
      </div>
    );
  }
);
OTPInput.displayName = "OTPInput";



=== FILE: packages\ui\src\components\form\PasswordInput.tsx ===

import React, { useState } from 'react';
import { TextInput, type TextInputProps } from './TextInput';
import { Eye, EyeOff } from 'lucide-react';
import { Button } from '../button/Button';

export interface PasswordInputProps extends Omit<TextInputProps, 'type' | 'rightIcon'> {}

/**
 * A specialized input for passwords with a built-in visibility toggle.
 */
export const PasswordInput = React.forwardRef<HTMLInputElement, PasswordInputProps>(
  (props, ref) => {
    const [showPassword, setShowPassword] = useState(false);

    return (
      <TextInput
        {...props}
        ref={ref}
        type={showPassword ? 'text' : 'password'}
        rightIcon={
          <Button
            type="button"
            variant="ghost"
            size="sm"
            className="h-8 w-8 p-0 hover:bg-white/10"
            onClick={() => setShowPassword(!showPassword)}
            aria-label={showPassword ? 'Hide password' : 'Show password'}
          >
            {showPassword ? (
              <EyeOff className="h-4 w-4 text-gray-400 dark:text-white/35" />
            ) : (
              <Eye className="h-4 w-4 text-gray-400 dark:text-white/35" />
            )}
          </Button>
        }
      />
    );
  }
);

PasswordInput.displayName = 'PasswordInput';



=== FILE: packages\ui\src\components\form\RadioGroup.tsx ===

import React, { createContext, useContext } from 'react';
import { cn } from '../../utils/cn';
import { Label } from './Label';

interface RadioGroupContextValue {
  value?: string;
  onChange?: (value: string) => void;
  name?: string;
  disabled?: boolean;
}

const RadioGroupContext = createContext<RadioGroupContextValue>({});

export interface RadioGroupProps extends Omit<React.HTMLAttributes<HTMLDivElement>, 'onChange'> {
  value?: string;
  onChange?: (value: string) => void;
  name?: string;
  disabled?: boolean;
  label?: string;
}

export const RadioGroup = React.forwardRef<HTMLDivElement, RadioGroupProps>(
  ({ className, value, onChange, name, disabled, label, children, ...props }, ref) => {
    const id = React.useId();
    
    return (
      <div ref={ref} className={cn("flex flex-col gap-2", className)} {...props}>
        {label && (
          <Label className={cn(disabled && "opacity-50 cursor-not-allowed")}>
            {label}
          </Label>
        )}
        <div className="flex flex-col gap-2" role="radiogroup">
          <RadioGroupContext.Provider value={{ value, onChange, name: name || id, disabled }}>
            {children}
          </RadioGroupContext.Provider>
        </div>
      </div>
    );
  }
);

RadioGroup.displayName = 'RadioGroup';

export interface RadioGroupItemProps extends React.InputHTMLAttributes<HTMLInputElement> {
  value: string;
  label?: string;
}

export const RadioGroupItem = React.forwardRef<HTMLInputElement, RadioGroupItemProps>(
  ({ className, value, label, disabled, ...props }, ref) => {
    const context = useContext(RadioGroupContext);
    const isChecked = context.value === value;
    const isDisabled = context.disabled || disabled;
    const id = React.useId();

    return (
      <label
        htmlFor={id}
        className={cn(
          "flex items-center gap-3 cursor-pointer group",
          isDisabled && "cursor-not-allowed opacity-50",
          className
        )}
      >
        <div className="relative flex items-center justify-center">
          <input
            ref={ref}
            id={id}
            type="radio"
            name={context.name}
            value={value}
            checked={isChecked}
            disabled={isDisabled}
            onChange={(e) => {
              if (e.target.checked) {
                context.onChange?.(value);
              }
            }}
            className="peer sr-only"
            {...props}
          />
          <div
            className={cn(
              "h-5 w-5 rounded-full border border-gray-300 dark:border-white/20 bg-gray-50 dark:bg-white/[0.03] transition-all duration-200",
              "peer-focus-visible:ring-2 peer-focus-visible:ring-gray-400 dark:peer-focus-visible:ring-white/20 peer-focus-visible:ring-offset-2 peer-focus-visible:ring-offset-white dark:peer-focus-visible:ring-offset-[#0A0A0A]",
              "group-hover:bg-gray-100 dark:group-hover:bg-white/[0.05]",
              isChecked && "border-gray-900 bg-gray-900 dark:border-white dark:bg-white"
            )}
          >
            {isChecked && (
              <div className="absolute inset-0 flex items-center justify-center">
                <div className="h-2 w-2 rounded-full bg-white dark:bg-black" />
              </div>
            )}
          </div>
        </div>
        {label && (
          <span className="text-sm text-gray-900 dark:text-white/90 select-none font-medium">
            {label}
          </span>
        )}
      </label>
    );
  }
);

RadioGroupItem.displayName = 'RadioGroupItem';



=== FILE: packages\ui\src\components\form\Select.tsx ===

import React, { useState, useRef, useEffect } from 'react';
import { cn } from '../../utils/cn';
import { Label } from './Label';

export interface SelectOption {
  label: string;
  value: string;
}

export interface SelectProps {
  label?: string;
  name?: string;
  options: SelectOption[];
  value?: string;
  defaultValue?: string;
  onChange?: (value: string) => void;
  placeholder?: string;
  error?: string;
  disabled?: boolean;
  className?: string;
}

export const Select = React.forwardRef<HTMLDivElement, SelectProps>(
  ({ label, name, options, value, defaultValue, onChange, placeholder = 'Select an option', error, disabled, className }, ref) => {
    const [isOpen, setIsOpen] = useState(false);
    const [internalValue, setInternalValue] = useState(defaultValue);
    const [activeIndex, setActiveIndex] = useState(-1);
    const containerRef = useRef<HTMLDivElement>(null);
    const id = React.useId();

    const isControlled = value !== undefined;
    const currentValue = isControlled ? value : internalValue;
    const selectedOption = options.find((opt) => opt.value === currentValue);

    useEffect(() => {
      if (isOpen) {
        const index = options.findIndex(opt => opt.value === currentValue);
        setActiveIndex(index !== -1 ? index : 0);
      } else {
        setActiveIndex(-1);
      }
    }, [isOpen, currentValue, options]);

    useEffect(() => {
      const handleClickOutside = (event: MouseEvent) => {
        if (containerRef.current && !containerRef.current.contains(event.target as Node)) {
          setIsOpen(false);
        }
      };

      document.addEventListener('mousedown', handleClickOutside);
      return () => document.removeEventListener('mousedown', handleClickOutside);
    }, []);

    const handleSelect = (optionValue: string) => {
      if (disabled) return;
      if (!isControlled) {
        setInternalValue(optionValue);
      }
      onChange?.(optionValue);
      setIsOpen(false);
    };

    const handleKeyDown = (e: React.KeyboardEvent) => {
      if (disabled) return;
      
      if (e.key === 'Enter' || e.key === ' ') {
        e.preventDefault();
        if (isOpen && activeIndex !== -1) {
          handleSelect(options[activeIndex]!.value);
        } else {
          setIsOpen(true);
        }
      } else if (e.key === 'Escape') {
        setIsOpen(false);
      } else if (e.key === 'ArrowDown') {
        e.preventDefault();
        if (!isOpen) {
          setIsOpen(true);
        } else {
          setActiveIndex((prev) => (prev + 1) % options.length);
        }
      } else if (e.key === 'ArrowUp') {
        e.preventDefault();
        if (!isOpen) {
          setIsOpen(true);
        } else {
          setActiveIndex((prev) => (prev - 1 + options.length) % options.length);
        }
      } else if (e.key === 'Home') {
        e.preventDefault();
        if (isOpen) setActiveIndex(0);
      } else if (e.key === 'End') {
        e.preventDefault();
        if (isOpen) setActiveIndex(options.length - 1);
      }
    };

    return (
      <div 
        ref={containerRef} 
        className={cn("flex flex-col gap-1.5 relative", className)}
      >
        {label && (
          <Label 
            htmlFor={id}
            className={cn(disabled && "opacity-50 cursor-not-allowed")}
          >
            {label}
          </Label>
        )}

        <div
          ref={ref}
          id={id}
          role="combobox"
          aria-expanded={isOpen}
          aria-haspopup="listbox"
          aria-controls={`${id}-listbox`}
          aria-disabled={disabled}
          tabIndex={disabled ? -1 : 0}
          onClick={() => !disabled && setIsOpen(!isOpen)}
          onKeyDown={handleKeyDown}
          className={cn(
            'w-full appearance-none rounded-2xl bg-gray-50 dark:bg-white/[0.04] px-4 py-3',
            'border border-gray-200 dark:border-white/[0.10]',
            'text-gray-900 dark:text-white flex items-center',
            'focus:outline-none focus:ring-2 focus:ring-purple-400/30',
            'hover:bg-gray-100 dark:hover:bg-white/[0.05] cursor-pointer',
            disabled && 'cursor-not-allowed opacity-50 hover:bg-gray-50 dark:hover:bg-white/[0.04]',
            isOpen && 'border-gray-300 dark:border-white/20 ring-2 ring-purple-400/20',
            error && 'border-rose-400/25 focus:ring-rose-300/25'
          )}
        >
          <span className={cn("block truncate", !selectedOption && "text-gray-400 dark:text-white/20")}>
            {selectedOption ? selectedOption.label : placeholder}
          </span>
          <svg
            xmlns="http://www.w3.org/2000/svg"
            width="16"
            height="16"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            strokeWidth="2"
            strokeLinecap="round"
            strokeLinejoin="round"
            className={cn(
              "absolute right-4 top-1/2 -translate-y-1/2 text-gray-400 dark:text-white/40 transition-transform duration-200",
              isOpen && "rotate-180"
            )}
          >
            <path d="m6 9 6 6 6-6"/>
          </svg>
        </div>

        {isOpen && (
          <div className="absolute top-full left-0 z-[110] mt-1 w-full overflow-hidden rounded-2xl border border-gray-200 dark:border-white/10 bg-white dark:bg-[#0A0A0A] p-1 shadow-xl animate-in fade-in zoom-in-95 duration-100">
            <ul
              id={`${id}-listbox`}
              role="listbox"
              aria-activedescendant={activeIndex !== -1 ? `${id}-option-${activeIndex}` : undefined}
              className="max-h-60 overflow-auto p-1 flex flex-col gap-2"
            >
              {options.map((option, index) => (
                <li
                  key={option.value}
                  id={`${id}-option-${index}`}
                  role="option"
                  aria-selected={currentValue === option.value}
                  onClick={() => handleSelect(option.value)}
                  onMouseEnter={() => setActiveIndex(index)}
                  className={cn(
                    'w-full rounded-2xl px-3 py-2 text-left text-sm transition-colors cursor-pointer',
                    'hover:bg-gray-100 dark:hover:bg-white/[0.06] hover:text-gray-900 dark:hover:text-white',
                    (currentValue === option.value || activeIndex === index)
                      ? 'bg-gray-100 dark:bg-white/[0.06] text-gray-900 dark:text-white/90' 
                      : 'text-gray-700 dark:text-white/80'
                  )}
                >
                  <div className="flex items-center justify-between gap-3">
                    <span className="flex-1 truncate">{option.label}</span>
                    {currentValue === option.value && (
                      <svg
                        xmlns="http://www.w3.org/2000/svg"
                        width="14"
                        height="14"
                        viewBox="0 0 24 24"
                        fill="none"
                        stroke="currentColor"
                        strokeWidth="2"
                        strokeLinecap="round"
                        strokeLinejoin="round"
                        className="text-gray-900 dark:text-white"
                      >
                        <polyline points="20 6 9 17 4 12" />
                      </svg>
                    )}
                  </div>
                </li>
              ))}
            </ul>
          </div>
        )}

        {error && (
          <p className="text-xs text-rose-400 animate-in slide-in-from-top-1 fade-in duration-200">
            {error}
          </p>
        )}
        <input type="hidden" name={name} value={currentValue || ''} />
      </div>
    );
  }
);

Select.displayName = 'Select';



=== FILE: packages\ui\src\components\form\Slider.tsx ===

import React, { useState, useRef, useEffect, useCallback } from 'react';
import { cn } from '../../utils/cn';

export interface SliderProps extends Omit<React.HTMLAttributes<HTMLDivElement>, 'onChange'> {
  value?: number;
  defaultValue?: number;
  min?: number;
  max?: number;
  step?: number;
  onChange?: (value: number) => void;
  disabled?: boolean;
}

export const Slider = React.forwardRef<HTMLDivElement, SliderProps>(
  ({ className, value: controlledValue, defaultValue = 0, min = 0, max = 100, step = 1, onChange, disabled, ...props }, ref) => {
    const [internalValue, setInternalValue] = useState(defaultValue);
    const isControlled = controlledValue !== undefined;
    const value = isControlled ? controlledValue : internalValue;
    const trackRef = useRef<HTMLDivElement>(null);

    const percentage = ((value - min) / (max - min)) * 100;

    const handleMove = useCallback((clientX: number) => {
      if (disabled || !trackRef.current) return;

      const rect = trackRef.current.getBoundingClientRect();
      const width = rect.width;
      const left = rect.left;
      
      let newValue = ((clientX - left) / width) * (max - min) + min;
      
      // Clamp
      newValue = Math.min(Math.max(newValue, min), max);
      
      // Step
      const steps = Math.round((newValue - min) / step);
      newValue = min + steps * step;

      // Precision fix
      newValue = Number(newValue.toFixed(10)); // Avoid floating point errors

      if (!isControlled) {
        setInternalValue(newValue);
      }
      onChange?.(newValue);
    }, [disabled, isControlled, max, min, onChange, step]);

    const handleMouseDown = (e: React.MouseEvent) => {
      if (disabled) return;
      handleMove(e.clientX);

      const handleMouseMove = (e: MouseEvent) => {
        handleMove(e.clientX);
      };

      const handleMouseUp = () => {
        document.removeEventListener('mousemove', handleMouseMove);
        document.removeEventListener('mouseup', handleMouseUp);
      };

      document.addEventListener('mousemove', handleMouseMove);
      document.addEventListener('mouseup', handleMouseUp);
    };

    const handleTouchStart = (e: React.TouchEvent) => {
      if (disabled) return;
      const startTouch = e.touches[0];
      if (startTouch) {
        handleMove(startTouch.clientX);
      }

      const handleTouchMove = (e: TouchEvent) => {
        const moveTouch = e.touches[0];
        if (moveTouch) {
          handleMove(moveTouch.clientX);
        }
      };

      const handleTouchEnd = () => {
        document.removeEventListener('touchmove', handleTouchMove);
        document.removeEventListener('touchend', handleTouchEnd);
      };

      document.addEventListener('touchmove', handleTouchMove, { passive: false });
      document.addEventListener('touchend', handleTouchEnd);
    };

    const handleKeyDown = (e: React.KeyboardEvent) => {
      if (disabled) return;

      let newValue = value;
      if (e.key === 'ArrowRight' || e.key === 'ArrowUp') {
        newValue = Math.min(value + step, max);
      } else if (e.key === 'ArrowLeft' || e.key === 'ArrowDown') {
        newValue = Math.max(value - step, min);
      } else if (e.key === 'Home') {
        newValue = min;
      } else if (e.key === 'End') {
        newValue = max;
      } else {
        return;
      }

      e.preventDefault();
      if (newValue !== value) {
        if (!isControlled) {
          setInternalValue(newValue);
        }
        onChange?.(newValue);
      }
    };

    return (
      <div
        ref={ref}
        role="slider"
        aria-valuemin={min}
        aria-valuemax={max}
        aria-valuenow={value}
        aria-disabled={disabled}
        tabIndex={disabled ? -1 : 0}
        onKeyDown={handleKeyDown}
        className={cn(
          "relative flex w-full touch-none select-none items-center py-4 group",
          disabled && "opacity-50 cursor-not-allowed",
          className
        )}
        onMouseDown={handleMouseDown}
        onTouchStart={handleTouchStart}
        {...props}
      >
        <div
          ref={trackRef}
          className="relative h-1.5 w-full grow overflow-hidden rounded-full bg-gray-200 dark:bg-white/[0.06] backdrop-blur-sm border border-gray-200 dark:border-white/5"
        >
          <div
            className="absolute h-full bg-gray-900 dark:bg-white transition-none dark:shadow-[0_0_10px_rgba(255,255,255,0.5)]"
            style={{ width: `${percentage}%` }}
          />
        </div>
        <div
          className="absolute h-5 w-5 rounded-full border-2 border-gray-900 dark:border-white bg-white dark:bg-black shadow-md dark:shadow-[0_0_15px_rgba(255,255,255,0.5)] transition-transform hover:scale-110 focus:scale-110"
          style={{ left: `calc(${percentage}% - 10px)` }}
        />
      </div>
    );
  }
);



=== FILE: packages\ui\src\components\form\Switch.tsx ===

import React from 'react';
import { cn } from '../../utils/cn';
import { Label } from './Label';

export interface SwitchProps extends Omit<React.ButtonHTMLAttributes<HTMLButtonElement>, 'onChange' | 'type'> {
  label?: string;
  error?: string;
  checked?: boolean;
  defaultChecked?: boolean;
  onChange?: (event: { target: { checked: boolean } }) => void;
}

export const Switch = React.forwardRef<HTMLButtonElement, SwitchProps>(
  ({ className, label, error, id, disabled, checked, defaultChecked, onChange, ...props }, ref) => {
    const inputId = id || React.useId();
    const [isChecked, setIsChecked] = React.useState(defaultChecked || checked || false);

    React.useEffect(() => {
      if (checked !== undefined) {
        setIsChecked(checked);
      }
    }, [checked]);

    const handleClick = () => {
      if (disabled) return;
      const newValue = !isChecked;
      setIsChecked(newValue);
      if (onChange) {
        onChange({ target: { checked: newValue } } as any);
      }
    };

    return (
      <div className={cn("flex flex-col gap-1.5", className)}>
        <div className="flex items-center gap-2">
          <button
            type="button"
            id={inputId}
            role="switch"
            aria-checked={isChecked}
            onClick={handleClick}
            disabled={disabled}
            className={cn(
              'peer inline-flex h-6 w-11 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-blue-500 focus-visible:ring-offset-2 focus-visible:ring-offset-white dark:focus-visible:ring-offset-black disabled:cursor-not-allowed disabled:opacity-50',
              isChecked ? 'bg-emerald-500' : 'bg-gray-200 dark:bg-white/[0.06]'
            )}
            {...props}
          >
            <span
              className={cn(
                'pointer-events-none block h-5 w-5 rounded-full bg-white shadow-lg ring-0 transition-transform',
                isChecked ? 'translate-x-5' : 'translate-x-0'
              )}
            />
          </button>
          {label && (
            <Label 
              htmlFor={inputId} 
              className="cursor-pointer select-none text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
              onClick={handleClick}
            >
              {label}
            </Label>
          )}
        </div>
        {error && (
          <p className="text-xs text-rose-500 mt-1 ml-1">{error}</p>
        )}
      </div>
    );
  }
);

Switch.displayName = 'Switch';



=== FILE: packages\ui\src\components\form\TagInput.tsx ===

import React, { useState, KeyboardEvent } from 'react';
import { cn } from '../../utils/cn';
import { X } from 'lucide-react';
import { Badge } from '../../primitives/Badge';
import { Label } from './Label';

export interface TagInputProps {
  label?: string;
  placeholder?: string;
  tags: string[];
  onChange: (tags: string[]) => void;
  error?: string;
  className?: string;
}

/**
 * An input component for managing a list of tags.
 */
export function TagInput({
  label,
  placeholder = 'Add tag...',
  tags,
  onChange,
  error,
  className,
}: TagInputProps) {
  const [inputValue, setInputValue] = useState('');

  const handleKeyDown = (e: KeyboardEvent<HTMLInputElement>) => {
    if (e.key === 'Enter' && inputValue.trim()) {
      e.preventDefault();
      if (!tags.includes(inputValue.trim())) {
        onChange([...tags, inputValue.trim()]);
      }
      setInputValue('');
    } else if (e.key === 'Backspace' && !inputValue && tags.length > 0) {
      onChange(tags.slice(0, -1));
    }
  };

  const removeTag = (tagToRemove: string) => {
    onChange(tags.filter((tag) => tag !== tagToRemove));
  };

  return (
    <div className={cn('flex flex-col gap-1.5', className)}>
      {label && <Label>{label}</Label>}
      
      <div className={cn(
        "flex flex-wrap gap-2 rounded-2xl bg-gray-50 dark:bg-white/[0.04] px-3 py-2 border border-gray-200 dark:border-white/[0.10] focus-within:ring-2 focus-within:ring-purple-400/30 transition-all duration-200",
        error && "border-rose-400/25"
      )}>
        {tags.map((tag) => (
          <Badge key={tag} variant="default" className="gap-1 pr-1">
            {tag}
            <button
              type="button"
              onClick={() => removeTag(tag)}
              className="rounded-full p-0.5 hover:bg-black/10 dark:hover:bg-white/10 transition-colors"
            >
              <X className="h-3 w-3" />
            </button>
          </Badge>
        ))}
        
        <input
          type="text"
          value={inputValue}
          onChange={(e) => setInputValue(e.target.value)}
          onKeyDown={handleKeyDown}
          placeholder={tags.length === 0 ? placeholder : ''}
          className="flex-1 bg-transparent py-1 text-sm outline-none placeholder:text-gray-400 dark:placeholder:text-white/30 min-w-[120px]"
        />
      </div>

      {error && (
        <p className="text-xs text-rose-400 animate-in slide-in-from-top-1 fade-in duration-200">
          {error}
        </p>
      )}
    </div>
  );
}



=== FILE: packages\ui\src\components\form\Textarea.tsx ===

import React from 'react';
import { cn } from '../../utils/cn';
import { Label } from './Label';

export interface TextareaProps extends React.TextareaHTMLAttributes<HTMLTextAreaElement> {
  label?: string;
  error?: string;
}

export const Textarea = React.forwardRef<HTMLTextAreaElement, TextareaProps>(
  ({ className, label, error, id, disabled, ...props }, ref) => {
    const generatedId = React.useId();
    const inputId = id || generatedId;

    return (
      <div className="flex flex-col gap-1.5">
        {label && (
          <Label 
            htmlFor={inputId}
            className={cn(disabled && "opacity-50 cursor-not-allowed")}
          >
            {label}
          </Label>
        )}
        
        <textarea
          ref={ref}
          id={inputId}
          disabled={disabled}
          className={cn(
            'w-full rounded-2xl bg-gray-50 dark:bg-white/[0.04] px-4 py-3',
            'border border-gray-200 dark:border-white/[0.10]',
            'text-gray-900 dark:text-white placeholder:text-gray-400 dark:placeholder:text-white/30',
            'focus:outline-none focus:ring-2 focus:ring-purple-400/30',
            'resize-none',
            'disabled:cursor-not-allowed disabled:opacity-50',
            error && 'border-rose-400/25 focus:ring-rose-300/25',
            className
          )}
          {...props}
        />

        {error && (
          <p className="text-xs text-rose-400 animate-in slide-in-from-top-1 fade-in duration-200">
            {error}
          </p>
        )}
      </div>
    );
  }
);

Textarea.displayName = 'Textarea';



=== FILE: packages\ui\src\components\form\TextInput.tsx ===

import React from 'react';
import { cva, type VariantProps } from 'class-variance-authority';
import { cn } from '../../utils/cn';
import { Label } from './Label';

const inputVariants = cva(
  "w-full rounded-2xl bg-gray-50 dark:bg-white/[0.04] px-4 py-3 border border-gray-200 dark:border-white/[0.10] text-gray-900 dark:text-white placeholder:text-gray-400 dark:placeholder:text-white/30 focus:outline-none focus:ring-2 focus:ring-purple-400/30 disabled:cursor-not-allowed disabled:opacity-50 transition-all duration-200",
  {
    variants: {
      hasError: {
        true: "border-rose-400/25 focus:ring-rose-300/25",
        false: "",
      },
      hasLeftIcon: {
        true: "pl-10",
        false: "",
      },
      hasRightIcon: {
        true: "pr-10",
        false: "",
      },
    },
    defaultVariants: {
      hasError: false,
      hasLeftIcon: false,
      hasRightIcon: false,
    },
  }
);

export interface TextInputProps 
  extends Omit<React.InputHTMLAttributes<HTMLInputElement>, 'size'>,
    Omit<VariantProps<typeof inputVariants>, 'hasError'> {
  /** Label text displayed above the input */
  label?: string;
  /** Error message displayed below the input. If provided, the input will show an error state. */
  error?: string;
  /** Icon to display on the left side inside the input */
  leftIcon?: React.ReactNode;
  /** Icon to display on the right side inside the input */
  rightIcon?: React.ReactNode;
  /** Additional CSS classes for the container div */
  containerClassName?: string;
}

/**
 * A styled text input component with support for labels, error messages, and icons.
 * Follows the library's glassmorphic design system.
 */
export const TextInput = React.forwardRef<HTMLInputElement, TextInputProps>(
  ({ className, containerClassName, label, error: errorMsg, leftIcon, rightIcon, id, ...props }, ref) => {
    const inputId = id || React.useId();
    const hasError = !!errorMsg;

    return (
      <div className={cn('flex flex-col gap-1.5', containerClassName)}>
        {label && <Label htmlFor={inputId} required={props.required}>{label}</Label>}
        
        <div className="relative flex items-center">
          {leftIcon && (
            <div className="pointer-events-none absolute left-3 top-1/2 -translate-y-1/2 text-gray-400 dark:text-white/35">
              {leftIcon}
            </div>
          )}
          
          <input
            ref={ref}
            id={inputId}
            className={cn(inputVariants({ 
              hasError: hasError, 
              hasLeftIcon: !!leftIcon, 
              hasRightIcon: !!rightIcon, 
              className 
            }))}
            {...props}
          />

          {rightIcon && (
            <div className="absolute right-2 top-1/2 -translate-y-1/2">
              {rightIcon}
            </div>
          )}
        </div>

        {errorMsg && (
          <p className="text-xs text-rose-400 animate-in slide-in-from-top-1 fade-in duration-200">
            {errorMsg}
          </p>
        )}
      </div>
    );
  }
);

TextInput.displayName = 'TextInput';



=== FILE: packages\ui\src\components\form\ToggleGroup.tsx ===

import React from 'react';
import { cva, type VariantProps } from 'class-variance-authority';
import { cn } from '../../utils/cn';

const toggleGroupVariants = cva(
  "inline-flex items-center rounded-2xl border border-gray-200 bg-gray-50 p-1 dark:border-white/10 dark:bg-white/[0.03]",
  {
    variants: {
      size: {
        sm: "h-8",
        md: "h-10",
        lg: "h-12",
      },
      fullWidth: {
        true: "w-full flex",
        false: "",
      }
    },
    defaultVariants: {
      size: "md",
      fullWidth: false
    }
  }
);

const toggleItemVariants = cva(
  "inline-flex items-center justify-center whitespace-nowrap rounded-2xl px-3 py-1.5 text-sm font-medium ring-offset-white transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-gray-950 focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 dark:ring-offset-gray-950 dark:focus-visible:ring-gray-300",
  {
    variants: {
      selected: {
        true: "bg-white text-gray-950 shadow-sm dark:bg-gray-800 dark:text-gray-50",
        false: "text-gray-500 hover:text-gray-900 dark:text-gray-400 dark:hover:text-gray-50",
      },
      fullWidth: {
        true: "flex-1",
        false: "",
      }
    },
    defaultVariants: {
      selected: false,
      fullWidth: false
    }
  }
);

export interface ToggleGroupProps extends Omit<React.HTMLAttributes<HTMLDivElement>, 'onChange'>, VariantProps<typeof toggleGroupVariants> {
  value?: string;
  onChange?: (value: string) => void;
  options: { label: string; value: string; icon?: React.ReactNode }[];
}

export const ToggleGroup = React.forwardRef<HTMLDivElement, ToggleGroupProps>(
  ({ className, size, fullWidth, value, onChange, options, ...props }, ref) => {
    return (
      <div ref={ref} className={cn(toggleGroupVariants({ size, fullWidth, className }))} {...props}>
        {options.map((option) => (
          <button
            key={option.value}
            type="button"
            onClick={() => onChange?.(option.value)}
            className={cn(toggleItemVariants({ selected: value === option.value, fullWidth }))}
          >
            {option.icon && <span className="mr-2">{option.icon}</span>}
            {option.label}
          </button>
        ))}
      </div>
    );
  }
);
ToggleGroup.displayName = "ToggleGroup";



=== FILE: packages\ui\src\components\layout\Background.tsx ===

import React from 'react';
import { cn } from '../../utils/cn';

export interface BackgroundProps extends React.HTMLAttributes<HTMLDivElement> {
  /**
   * The pattern variant to display
   * @default 'none'
   */
  variant?: 'dots' | 'grid' | 'mesh' | 'gradient' | 'beams' | 'none';
  /**
   * Add a subtle noise/grain texture
   * @default false
   */
  noise?: boolean;
  /**
   * The color of the pattern (CSS color or variable)
   * @default 'rgba(255,255,255,0.08)'
   */
  patternColor?: string;
  /**
   * The size of the pattern (spacing between dots/lines)
   * @default 24
   */
  size?: number;
  /**
   * Apply a radial mask to fade the edges
   * @default 'none'
   */
  mask?: 'fade' | 'none';
  /**
   * Enable subtle animations for mesh or gradient variants
   * @default false
   */
  animate?: boolean;
  /**
   * Make the background follow the mouse (requires relative parent)
   * @default false
   */
  followMouse?: boolean;
  /**
   * The background color of the container. 
   * Can be a Tailwind class (e.g., 'bg-zinc-950') or a CSS color.
   */
  bgColor?: string;
}

export const Background = React.forwardRef<HTMLDivElement, BackgroundProps>(
  ({ 
    variant = 'none', 
    noise = false,
    patternColor, 
    size = 24, 
    mask = 'none', 
    animate = false,
    followMouse = false,
    bgColor,
    className, 
    children,
    style,
    ...props 
  }, ref) => {
    const containerRef = React.useRef<HTMLDivElement>(null);

    React.useEffect(() => {
      if (!followMouse) return;

      const handleMouseMove = (e: MouseEvent) => {
        const el = containerRef.current;
        if (!el) return;
        const rect = el.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        el.style.setProperty('--mouse-x', `${x}px`);
        el.style.setProperty('--mouse-y', `${y}px`);
      };

      window.addEventListener('mousemove', handleMouseMove);
      return () => window.removeEventListener('mousemove', handleMouseMove);
    }, [followMouse]);
    
    const getBackgroundStyle = (): React.CSSProperties => {
      const baseStyle: React.CSSProperties = {};
      
      // Use CSS variables for ultra-performance (no React re-renders)
      const effectiveColor = patternColor || 'var(--pattern-color, rgba(255,255,255,0.08))';

      if (variant === 'dots') {
        return {
          ...baseStyle,
          backgroundImage: `radial-gradient(${effectiveColor} 1px, transparent 1px)`,
          backgroundSize: `${size}px ${size}px`,
          transform: followMouse ? 'translate3d(calc((var(--mouse-x, 0) - 24px) / 40), calc((var(--mouse-y, 0) - 24px) / 40), 0)' : undefined,
        };
      }
      if (variant === 'grid') {
        return {
          ...baseStyle,
          backgroundImage: `
            linear-gradient(to right, ${effectiveColor} 1px, transparent 1px),
            linear-gradient(to bottom, ${effectiveColor} 1px, transparent 1px)
          `,
          backgroundSize: `${size}px ${size}px`,
          transform: followMouse ? 'translate3d(calc((var(--mouse-x, 0) - 24px) / 40), calc((var(--mouse-y, 0) - 24px) / 40), 0)' : undefined,
        };
      }
      if (variant === 'gradient') {
        return {
          ...baseStyle,
          background: followMouse 
            ? `radial-gradient(circle at var(--mouse-x, center) var(--mouse-y, center), ${effectiveColor}, transparent)`
            : `radial-gradient(circle at center, ${effectiveColor}, transparent)`,
        };
      }
      if (variant === 'beams') {
        return {
          ...baseStyle,
          background: `radial-gradient(60% 40% at 50% 0%, ${effectiveColor} 0%, transparent 100%)`,
        };
      }
      return baseStyle;
    };

    const maskStyle: React.CSSProperties = mask === 'fade' ? {
      maskImage: 'radial-gradient(ellipse at center, black, transparent 90%)',
      WebkitMaskImage: 'radial-gradient(ellipse at center, black, transparent 90%)',
    } : {};

    return (
      <div
        ref={(node) => {
          if (node) {
            (containerRef as React.MutableRefObject<HTMLDivElement>).current = node;
          }
          if (typeof ref === 'function') ref(node);
          else if (ref) (ref as React.MutableRefObject<HTMLDivElement | null>).current = node;
        }}
        className={cn(
          'absolute inset-0 overflow-hidden pointer-events-none transition-transform duration-300 ease-out',
          'z-0',
          '[--pattern-color:rgba(0,0,0,0.05)] dark:[--pattern-color:rgba(255,255,255,0.08)]',
          bgColor?.startsWith('bg-') ? bgColor : '',
          className
        )}
        style={{ 
          ...getBackgroundStyle(), 
          ...maskStyle, 
          ...style,
          backgroundColor: bgColor && !bgColor.startsWith('bg-') ? bgColor : undefined 
        }}
        {...props}
      >
        {noise && (
          <div 
            className="absolute inset-0 opacity-[0.03] pointer-events-none brightness-100 contrast-150" 
            style={{ backgroundImage: `url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.65' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)'/%3E%3C/svg%3E")` }} 
          />
        )}

        {variant === 'beams' && (
          <div className="absolute inset-0 overflow-hidden">
            <div className="absolute top-0 left-1/4 w-px h-full bg-gradient-to-b from-transparent via-white/10 to-transparent" />
            <div className="absolute top-0 right-1/4 w-px h-full bg-gradient-to-b from-transparent via-white/10 to-transparent" />
          </div>
        )}

        {variant === 'mesh' && (
          <div className={cn(
            "absolute inset-0 opacity-30 blur-[100px]",
            animate && "animate-pulse"
          )}>
            <div className="absolute top-[-10%] left-[-10%] w-[50%] h-[50%] rounded-full bg-blue-500/20" />
            <div className="absolute bottom-[-10%] right-[-10%] w-[50%] h-[50%] rounded-full bg-purple-500/20" />
            <div className="absolute top-[20%] right-[10%] w-[40%] h-[40%] rounded-full bg-indigo-500/10" />
          </div>
        )}
        {children}
      </div>
    );
  }
);

Background.displayName = 'Background';



=== FILE: packages\ui\src\components\layout\Container.tsx ===

import React from 'react';
import { cn } from '../../utils/cn';

export interface ContainerProps extends React.HTMLAttributes<HTMLDivElement> {
  size?: 'sm' | 'md' | 'lg' | 'xl' | 'full';
}

export const Container = React.forwardRef<HTMLDivElement, ContainerProps>(
  ({ className, size = 'lg', ...props }, ref) => {
    const sizes = {
      sm: 'max-w-screen-sm',
      md: 'max-w-screen-md',
      lg: 'max-w-screen-lg',
      xl: 'max-w-screen-xl',
      full: 'max-w-full',
    };

    return (
      <div
        ref={ref}
        className={cn('mx-auto w-full px-4', sizes[size], className)}
        {...props}
      />
    );
  }
);
Container.displayName = 'Container';



=== FILE: packages\ui\src\components\layout\Grid.tsx ===

import React from 'react';
import { cn } from '../../utils/cn';

export interface GridProps extends React.HTMLAttributes<HTMLDivElement> {
  cols?: number;
  sm?: number;
  md?: number;
  lg?: number;
  xl?: number;
  gap?: number | string;
}

const colMap: Record<number, string> = {
  1: 'grid-cols-1',
  2: 'grid-cols-2',
  3: 'grid-cols-3',
  4: 'grid-cols-4',
  5: 'grid-cols-5',
  6: 'grid-cols-6',
  7: 'grid-cols-7',
  8: 'grid-cols-8',
  9: 'grid-cols-9',
  10: 'grid-cols-10',
  11: 'grid-cols-11',
  12: 'grid-cols-12',
};

const smMap: Record<number, string> = {
  1: 'sm:grid-cols-1', 2: 'sm:grid-cols-2', 3: 'sm:grid-cols-3', 4: 'sm:grid-cols-4',
  5: 'sm:grid-cols-5', 6: 'sm:grid-cols-6', 7: 'sm:grid-cols-7', 8: 'sm:grid-cols-8',
  9: 'sm:grid-cols-9', 10: 'sm:grid-cols-10', 11: 'sm:grid-cols-11', 12: 'sm:grid-cols-12',
};

const mdMap: Record<number, string> = {
  1: 'md:grid-cols-1', 2: 'md:grid-cols-2', 3: 'md:grid-cols-3', 4: 'md:grid-cols-4',
  5: 'md:grid-cols-5', 6: 'md:grid-cols-6', 7: 'md:grid-cols-7', 8: 'md:grid-cols-8',
  9: 'md:grid-cols-9', 10: 'md:grid-cols-10', 11: 'md:grid-cols-11', 12: 'md:grid-cols-12',
};

const lgMap: Record<number, string> = {
  1: 'lg:grid-cols-1', 2: 'lg:grid-cols-2', 3: 'lg:grid-cols-3', 4: 'lg:grid-cols-4',
  5: 'lg:grid-cols-5', 6: 'lg:grid-cols-6', 7: 'lg:grid-cols-7', 8: 'lg:grid-cols-8',
  9: 'lg:grid-cols-9', 10: 'lg:grid-cols-10', 11: 'lg:grid-cols-11', 12: 'lg:grid-cols-12',
};

const xlMap: Record<number, string> = {
  1: 'xl:grid-cols-1', 2: 'xl:grid-cols-2', 3: 'xl:grid-cols-3', 4: 'xl:grid-cols-4',
  5: 'xl:grid-cols-5', 6: 'xl:grid-cols-6', 7: 'xl:grid-cols-7', 8: 'xl:grid-cols-8',
  9: 'xl:grid-cols-9', 10: 'xl:grid-cols-10', 11: 'xl:grid-cols-11', 12: 'xl:grid-cols-12',
};

export const Grid = React.forwardRef<HTMLDivElement, GridProps>(
  ({ className, cols, sm, md, lg, xl, gap = 4, style, ...props }, ref) => {
    return (
      <div
        ref={ref}
        className={cn(
          'grid',
          cols && colMap[cols],
          sm && smMap[sm],
          md && mdMap[md],
          lg && lgMap[lg],
          xl && xlMap[xl],
          className
        )}
        style={{
            gridTemplateColumns: (cols && !colMap[cols]) ? `repeat(${cols}, minmax(0, 1fr))` : undefined,
            gap: typeof gap === 'number' ? `${gap * 0.25}rem` : gap,
            ...style
        }}
        {...props}
      />
    );
  }
);
Grid.displayName = 'Grid';



=== FILE: packages\ui\src\components\layout\Spotlight.tsx ===

import React, { useState, useRef, useEffect } from 'react';
import { cn } from '../../utils/cn';

export interface SpotlightProps extends React.HTMLAttributes<HTMLDivElement> {
  children?: React.ReactNode;
  size?: number;
  color?: string;
  fill?: string;
}

export const Spotlight = ({ 
  children, 
  className, 
  size = 300, 
  color,
  fill,
  ...props 
}: SpotlightProps) => {
  const divRef = useRef<HTMLDivElement>(null);
  const effectiveColor = fill || color || "rgba(255, 255, 255, 0.1)";

  const handleMouseMove = (e: React.MouseEvent<HTMLDivElement>) => {
    const el = divRef.current;
    if (!el) return;

    const rect = el.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    el.style.setProperty('--mouse-x', `${x}px`);
    el.style.setProperty('--mouse-y', `${y}px`);
  };

  const handleMouseEnter = () => {
    divRef.current?.style.setProperty('--opacity', '1');
  };

  const handleMouseLeave = () => {
    divRef.current?.style.setProperty('--opacity', '0');
  };

  return (
    <div
      ref={divRef}
      onMouseMove={handleMouseMove}
      onMouseEnter={handleMouseEnter}
      onMouseLeave={handleMouseLeave}
      className={cn(
        "relative overflow-hidden rounded-2xl border border-gray-200 bg-white dark:border-white/10 dark:bg-black",
        className
      )}
      {...props}
    >
      <div
        className="pointer-events-none absolute -inset-px transition-opacity duration-300"
        style={{
          opacity: 'var(--opacity, 0)',
          background: `radial-gradient(${size}px circle at var(--mouse-x, center) var(--mouse-y, center), ${effectiveColor}, transparent 80%)`,
        }}
      />
      {children && <div className="relative h-full">{children}</div>}
    </div>
  );
};



=== FILE: packages\ui\src\components\layout\Stack.tsx ===

import React from 'react';
import { cn } from '../../utils/cn';

export interface StackProps extends React.HTMLAttributes<HTMLDivElement> {
  direction?: 'row' | 'col' | 'row-reverse' | 'col-reverse';
  gap?: number | string;
  align?: 'start' | 'end' | 'center' | 'baseline' | 'stretch';
  justify?: 'start' | 'end' | 'center' | 'between' | 'around' | 'evenly';
  wrap?: boolean;
}

export const Stack = React.forwardRef<HTMLDivElement, StackProps>(
  ({ className, direction = 'col', gap = 4, align, justify, wrap, style, ...props }, ref) => {
    return (
      <div
        ref={ref}
        className={cn(
          'flex',
          {
            'flex-row': direction === 'row',
            'flex-col': direction === 'col',
            'flex-row-reverse': direction === 'row-reverse',
            'flex-col-reverse': direction === 'col-reverse',
            'flex-wrap': wrap,
            'items-start': align === 'start',
            'items-end': align === 'end',
            'items-center': align === 'center',
            'items-baseline': align === 'baseline',
            'items-stretch': align === 'stretch',
            'justify-start': justify === 'start',
            'justify-end': justify === 'end',
            'justify-center': justify === 'center',
            'justify-between': justify === 'between',
            'justify-around': justify === 'around',
            'justify-evenly': justify === 'evenly',
          },
          className
        )}
        style={{
            gap: typeof gap === 'number' ? `${gap * 0.25}rem` : gap,
            ...style
        }}
        {...props}
      />
    );
  }
);
Stack.displayName = 'Stack';



=== FILE: packages\ui\src\components\navigation\Breadcrumb.tsx ===

import React from 'react';
import { cn } from '../../utils/cn';

const Breadcrumb = React.forwardRef<
  HTMLElement,
  React.ComponentPropsWithoutRef<"nav"> & {
    separator?: React.ReactNode
  }
>(({ ...props }, ref) => <nav ref={ref} aria-label="breadcrumb" {...props} />)
Breadcrumb.displayName = "Breadcrumb"

const BreadcrumbList = React.forwardRef<
  HTMLOListElement,
  React.ComponentPropsWithoutRef<"ol">
>(({ className, ...props }, ref) => (
  <ol
    ref={ref}
    className={cn(
      "flex flex-wrap items-center gap-1.5 break-words text-sm text-gray-500 dark:text-white/50 sm:gap-2.5",
      className
    )}
    {...props}
  />
))
BreadcrumbList.displayName = "BreadcrumbList"

const BreadcrumbItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentPropsWithoutRef<"li">
>(({ className, ...props }, ref) => (
  <li
    ref={ref}
    className={cn("inline-flex items-center gap-1.5", className)}
    {...props}
  />
))
BreadcrumbItem.displayName = "BreadcrumbItem"

const BreadcrumbLink = React.forwardRef<
  HTMLAnchorElement,
  React.ComponentPropsWithoutRef<"a"> & {
    asChild?: boolean
  }
>(({ className, ...props }, ref) => {
  return (
    <a
      ref={ref}
      className={cn("transition-colors hover:text-gray-900 dark:hover:text-white", className)}
      {...props}
    />
  )
})
BreadcrumbLink.displayName = "BreadcrumbLink"

const BreadcrumbPage = React.forwardRef<
  HTMLSpanElement,
  React.ComponentPropsWithoutRef<"span">
>(({ className, ...props }, ref) => (
  <span
    ref={ref}
    role="link"
    aria-disabled="true"
    aria-current="page"
    className={cn("font-normal text-gray-900 dark:text-white", className)}
    {...props}
  />
))
BreadcrumbPage.displayName = "BreadcrumbPage"

const BreadcrumbSeparator = ({
  children,
  className,
  ...props
}: React.ComponentProps<"li">) => (
  <li
    role="presentation"
    aria-hidden="true"
    className={cn("[&>svg]:size-3.5", className)}
    {...props}
  >
    {children ?? (
      <svg
        xmlns="http://www.w3.org/2000/svg"
        width="24"
        height="24"
        viewBox="0 0 24 24"
        fill="none"
        stroke="currentColor"
        strokeWidth="2"
        strokeLinecap="round"
        strokeLinejoin="round"
        className="h-4 w-4"
      >
        <path d="m9 18 6-6-6-6" />
      </svg>
    )}
  </li>
)
BreadcrumbSeparator.displayName = "BreadcrumbSeparator"

const BreadcrumbEllipsis = ({
  className,
  ...props
}: React.ComponentProps<"span">) => (
  <span
    role="presentation"
    aria-hidden="true"
    className={cn("flex h-9 w-9 items-center justify-center", className)}
    {...props}
  >
    <svg
      xmlns="http://www.w3.org/2000/svg"
      width="24"
      height="24"
      viewBox="0 0 24 24"
      fill="none"
      stroke="currentColor"
      strokeWidth="2"
      strokeLinecap="round"
      strokeLinejoin="round"
      className="h-4 w-4"
    >
      <circle cx="12" cy="12" r="1" />
      <circle cx="19" cy="12" r="1" />
      <circle cx="5" cy="12" r="1" />
    </svg>
    <span className="sr-only">More</span>
  </span>
)
BreadcrumbEllipsis.displayName = "BreadcrumbElipssis"

export {
  Breadcrumb,
  BreadcrumbList,
  BreadcrumbItem,
  BreadcrumbLink,
  BreadcrumbPage,
  BreadcrumbSeparator,
  BreadcrumbEllipsis,
}



=== FILE: packages\ui\src\components\navigation\Navbar.tsx ===

import React, { useState, useEffect } from 'react';
import { cn } from '../../utils/cn';
import { Surface } from '../../primitives/Surface';
import { Button } from '../button/Button';
import { Menu, X } from 'lucide-react';

interface NavbarProps {
  logo?: React.ReactNode;
  links?: { label: string; href: string }[];
  actions?: React.ReactNode;
  className?: string;
  maxWidth?: 'sm' | 'md' | 'lg' | 'xl' | '2xl' | 'full';
}

const maxWidthClasses = {
  sm: 'max-w-screen-sm',
  md: 'max-w-screen-md',
  lg: 'max-w-screen-lg',
  xl: 'max-w-screen-xl',
  '2xl': 'max-w-screen-2xl',
  full: 'max-w-full',
};

export function Navbar({
  logo,
  links = [],
  actions,
  className,
  maxWidth = 'xl',
}: NavbarProps) {
  const [isScrolled, setIsScrolled] = useState(false);
  const [isMobileMenuOpen, setIsMobileMenuOpen] = useState(false);

  useEffect(() => {
    const handleScroll = () => {
      setIsScrolled(window.scrollY > 20);
    };
    window.addEventListener('scroll', handleScroll);
    return () => window.removeEventListener('scroll', handleScroll);
  }, []);

  return (
    <nav
      className={cn(
        'fixed top-0 left-0 right-0 z-50 transition-all duration-300 px-4 py-4',
        isScrolled ? 'py-3' : 'py-6',
        className
      )}
    >
      <div className={cn('mx-auto transition-all duration-300', maxWidthClasses[maxWidth])}>
        <Surface
          className={cn(
            'flex items-center justify-between px-6 py-3 transition-all duration-300',
            isScrolled 
              ? 'rounded-2xl border-white/10 bg-white/70 dark:bg-zinc-900/70 backdrop-blur-xl shadow-lg' 
              : 'rounded-2xl border-transparent bg-transparent dark:bg-transparent backdrop-blur-none shadow-none'
          )}
        >
          {/* Logo */}
          <div className="flex items-center gap-2">
            {logo || <span className="text-xl font-bold tracking-tighter">PIXON</span>}
          </div>

          {/* Desktop Links */}
          <div className="hidden md:flex items-center gap-8">
            {links.map((link) => (
              <a
                key={link.label}
                href={link.href}
                className="text-sm font-medium text-zinc-600 hover:text-zinc-900 dark:text-zinc-400 dark:hover:text-white transition-colors"
              >
                {link.label}
              </a>
            ))}
          </div>

          {/* Actions & Mobile Toggle */}
          <div className="flex items-center gap-4">
            <div className="hidden md:flex items-center gap-2">
              {actions}
            </div>
            
            <button
              className="md:hidden p-2 text-zinc-600 dark:text-zinc-400 hover:bg-zinc-100 dark:hover:bg-white/[0.03] rounded-2xl transition-colors"
              onClick={() => setIsMobileMenuOpen(!isMobileMenuOpen)}
            >
              {isMobileMenuOpen ? <X size={20} /> : <Menu size={20} />}
            </button>
          </div>
        </Surface>

        {/* Mobile Menu */}
        <div
          className={cn(
            'md:hidden absolute top-full left-4 right-4 mt-2 transition-all duration-300 origin-top',
            isMobileMenuOpen 
              ? 'opacity-100 scale-100 translate-y-0' 
              : 'opacity-0 scale-95 -translate-y-4 pointer-events-none'
          )}
        >
          <Surface className="p-4 flex flex-col gap-4 shadow-2xl border-white/10 bg-white/90 dark:bg-zinc-900/90 backdrop-blur-2xl">
            {links.map((link) => (
              <a
                key={link.label}
                href={link.href}
                className="text-base font-medium px-4 py-2 rounded-2xl hover:bg-zinc-100 dark:hover:bg-white/[0.03] text-zinc-600 hover:text-zinc-900 dark:text-zinc-400 dark:hover:text-white transition-all"
                onClick={() => setIsMobileMenuOpen(false)}
              >
                {link.label}
              </a>
            ))}
            <div className="pt-4 border-t border-zinc-200 dark:border-white/10 flex flex-col gap-2">
              {actions}
            </div>
          </Surface>
        </div>
      </div>
    </nav>
  );
}



=== FILE: packages\ui\src\components\navigation\Pagination.tsx ===

import React from 'react';
import { cn } from '../../utils/cn';
import { PrimaryButton } from '../button/PrimaryButton';

const Pagination = ({ className, ...props }: React.ComponentProps<"nav">) => (
  <nav
    role="navigation"
    aria-label="pagination"
    className={cn("mx-auto flex w-full justify-center", className)}
    {...props}
  />
)
Pagination.displayName = "Pagination"

const PaginationContent = React.forwardRef<
  HTMLUListElement,
  React.ComponentProps<"ul">
>(({ className, ...props }, ref) => (
  <ul
    ref={ref}
    className={cn("flex flex-row items-center gap-1", className)}
    {...props}
  />
))
PaginationContent.displayName = "PaginationContent"

const PaginationItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentProps<"li">
>(({ className, ...props }, ref) => (
  <li ref={ref} className={cn("", className)} {...props} />
))
PaginationItem.displayName = "PaginationItem"

type PaginationLinkProps = {
  isActive?: boolean
} & React.ComponentProps<"a">

const PaginationLink = ({
  className,
  isActive,
  ...props
}: PaginationLinkProps) => (
  <a
    aria-current={isActive ? "page" : undefined}
    className={cn(
      "inline-flex h-9 w-9 items-center justify-center rounded-2xl text-sm font-medium transition-colors",
      "hover:bg-gray-100 dark:hover:bg-white/[0.03] hover:text-gray-900 dark:hover:text-white",
      isActive ? "bg-gray-100 text-gray-900 dark:bg-white/[0.06] dark:text-white" : "text-gray-500 dark:text-white/60",
      className
    )}
    {...props}
  />
)
PaginationLink.displayName = "PaginationLink"

const PaginationPrevious = ({
  className,
  ...props
}: React.ComponentProps<typeof PaginationLink>) => (
  <PaginationLink
    aria-label="Go to previous page"
    className={cn("w-auto gap-1 px-2.5", className)}
    {...props}
  >
    <svg
      xmlns="http://www.w3.org/2000/svg"
      width="24"
      height="24"
      viewBox="0 0 24 24"
      fill="none"
      stroke="currentColor"
      strokeWidth="2"
      strokeLinecap="round"
      strokeLinejoin="round"
      className="h-4 w-4"
    >
      <path d="m15 18-6-6 6-6" />
    </svg>
    <span>Previous</span>
  </PaginationLink>
)
PaginationPrevious.displayName = "PaginationPrevious"

const PaginationNext = ({
  className,
  ...props
}: React.ComponentProps<typeof PaginationLink>) => (
  <PaginationLink
    aria-label="Go to next page"
    className={cn("w-auto gap-1 px-2.5", className)}
    {...props}
  >
    <span>Next</span>
    <svg
      xmlns="http://www.w3.org/2000/svg"
      width="24"
      height="24"
      viewBox="0 0 24 24"
      fill="none"
      stroke="currentColor"
      strokeWidth="2"
      strokeLinecap="round"
      strokeLinejoin="round"
      className="h-4 w-4"
    >
      <path d="m9 18 6-6-6-6" />
    </svg>
  </PaginationLink>
)
PaginationNext.displayName = "PaginationNext"

const PaginationEllipsis = ({
  className,
  ...props
}: React.ComponentProps<"span">) => (
  <span
    aria-hidden
    className={cn("flex h-9 w-9 items-center justify-center", className)}
    {...props}
  >
    <svg
      xmlns="http://www.w3.org/2000/svg"
      width="24"
      height="24"
      viewBox="0 0 24 24"
      fill="none"
      stroke="currentColor"
      strokeWidth="2"
      strokeLinecap="round"
      strokeLinejoin="round"
      className="h-4 w-4"
    >
      <circle cx="12" cy="12" r="1" />
      <circle cx="19" cy="12" r="1" />
      <circle cx="5" cy="12" r="1" />
    </svg>
    <span className="sr-only">More pages</span>
  </span>
)
PaginationEllipsis.displayName = "PaginationEllipsis"

export {
  Pagination,
  PaginationContent,
  PaginationEllipsis,
  PaginationItem,
  PaginationLink,
  PaginationNext,
  PaginationPrevious,
}



=== FILE: packages\ui\src\components\navigation\Sidebar.tsx ===

import React from 'react';
import { cn } from '../../utils/cn';

export interface SidebarProps extends React.HTMLAttributes<HTMLDivElement> {
  children: React.ReactNode;
}

export const Sidebar = React.forwardRef<HTMLDivElement, SidebarProps>(
  ({ className, children, ...props }, ref) => {
    return (
      <aside
        ref={ref}
        className={cn(
          "flex h-full w-64 flex-col border-r backdrop-blur-xl transition-colors duration-200",
          "border-zinc-200 bg-white/80",
          "dark:border-white/10 dark:bg-black/20",
          className
        )}
        {...props}
      >
        {children}
      </aside>
    );
  }
);

export interface SidebarHeaderProps extends React.HTMLAttributes<HTMLDivElement> {}

export const SidebarHeader = React.forwardRef<HTMLDivElement, SidebarHeaderProps>(
  ({ className, children, ...props }, ref) => {
    return (
      <div
        ref={ref}
        className={cn("flex h-16 items-center px-6 border-b border-gray-200 dark:border-white/5", className)}
        {...props}
      >
        {children}
      </div>
    );
  }
);

export interface SidebarContentProps extends React.HTMLAttributes<HTMLDivElement> {}

export const SidebarContent = React.forwardRef<HTMLDivElement, SidebarContentProps>(
  ({ className, children, ...props }, ref) => {
    return (
      <div
        ref={ref}
        className={cn("flex-1 overflow-y-auto py-4 px-3 space-y-1", className)}
        {...props}
      >
        {children}
      </div>
    );
  }
);

export interface SidebarFooterProps extends React.HTMLAttributes<HTMLDivElement> {}

export const SidebarFooter = React.forwardRef<HTMLDivElement, SidebarFooterProps>(
  ({ className, children, ...props }, ref) => {
    return (
      <div
        ref={ref}
        className={cn("p-4 border-t border-gray-200 dark:border-white/5", className)}
        {...props}
      >
        {children}
      </div>
    );
  }
);

export interface SidebarItemProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  active?: boolean;
  icon?: React.ReactNode;
  badge?: React.ReactNode;
}

export const SidebarItem = React.forwardRef<HTMLButtonElement, SidebarItemProps>(
  ({ className, children, active, icon, badge, ...props }, ref) => {
    return (
      <button
        ref={ref}
        className={cn(
          "flex w-full items-center gap-3 rounded-2xl px-3 py-2 text-sm font-medium transition-colors",
          "hover:bg-gray-100 hover:text-gray-900 dark:hover:bg-white/[0.03] dark:hover:text-white",
          active 
            ? "bg-gray-200 text-gray-900 dark:bg-white/[0.06] dark:text-white" 
            : "text-gray-600 dark:text-white/60",
          className
        )}
        {...props}
      >
        {icon && <span className={cn("flex h-4 w-4 items-center justify-center", active ? "text-gray-900 dark:text-white" : "text-gray-500 dark:text-white/60")}>{icon}</span>}
        <span className="flex-1 text-left">{children}</span>
        {badge && (
          <span className="flex h-5 min-w-5 items-center justify-center rounded-full bg-gray-200 dark:bg-white/[0.06] px-1.5 text-[10px] font-bold text-gray-900 dark:text-white">
            {badge}
          </span>
        )}
      </button>
    );
  }
);

export interface SidebarGroupProps extends React.HTMLAttributes<HTMLDivElement> {
  label?: string;
}

export const SidebarGroup = React.forwardRef<HTMLDivElement, SidebarGroupProps>(
  ({ className, children, label, ...props }, ref) => {
    return (
      <div ref={ref} className={cn("mb-6", className)} {...props}>
        {label && (
          <div className="mb-2 px-3 text-xs font-semibold uppercase tracking-wider text-gray-500 dark:text-white/40">
            {label}
          </div>
        )}
        <div className="space-y-1">{children}</div>
      </div>
    );
  }
);



=== FILE: packages\ui\src\components\navigation\SkipToContent.tsx ===

import React from 'react';
import { cn } from '../../utils/cn';

export interface SkipToContentProps {
  contentId?: string;
  className?: string;
  children?: React.ReactNode;
}

/**
 * A component that allows keyboard users to skip navigation and jump to the main content.
 * It is hidden by default and becomes visible on focus.
 */
export function SkipToContent({
  contentId = 'main-content',
  className,
  children = 'Skip to content',
}: SkipToContentProps) {
  return (
    <a
      href={`#${contentId}`}
      className={cn(
        "sr-only focus:not-sr-only focus:fixed focus:top-4 focus:left-4 focus:z-[100] focus:px-4 focus:py-2 focus:bg-purple-600 focus:text-white focus:rounded-xl focus:shadow-2xl focus:outline-none focus:ring-2 focus:ring-white/20 transition-all",
        className
      )}
    >
      {children}
    </a>
  );
}



=== FILE: packages\ui\src\components\navigation\Stepper.tsx ===

import React from 'react';
import { Check } from 'lucide-react';
import { cn } from '../../utils/cn';

export interface StepperProps {
  steps: { title: string; description?: string }[];
  currentStep: number;
  className?: string;
  onStepClick?: (step: number) => void;
}

export const Stepper = ({ steps, currentStep, className, onStepClick }: StepperProps) => {
  return (
    <div className={cn("flex w-full flex-col gap-4 md:flex-row", className)}>
      {steps.map((step, index) => {
        const isCompleted = currentStep > index;
        const isCurrent = currentStep === index;
        const isClickable = !!onStepClick;

        return (
          <div 
            key={index} 
            className={cn(
              "flex flex-1 flex-col gap-2 md:flex-row md:items-center md:gap-4",
              isClickable && "cursor-pointer"
            )}
            onClick={() => isClickable && onStepClick(index)}
          >
            <div className="flex items-center gap-4 md:flex-col md:gap-2">
              <div className="flex items-center">
                <div
                  className={cn(
                    "flex h-8 w-8 items-center justify-center rounded-full border-2 text-sm font-semibold transition-colors",
                    isCompleted
                      ? "border-blue-600 bg-blue-600 text-white dark:border-blue-500 dark:bg-blue-500"
                      : isCurrent
                      ? "border-blue-600 text-blue-600 dark:border-blue-500 dark:text-blue-500"
                      : "border-gray-300 text-gray-500 dark:border-white/20 dark:text-white/40"
                  )}
                >
                  {isCompleted ? <Check className="h-4 w-4" /> : index + 1}
                </div>
                {/* Connector Line (Mobile: Right of circle, Desktop: Right of content) */}
                {index < steps.length - 1 && (
                  <div 
                    className={cn(
                      "ml-4 h-px flex-1 bg-gray-200 md:hidden dark:bg-white/[0.03]",
                      isCompleted && "bg-blue-600 dark:bg-blue-500"
                    )} 
                  />
                )}
              </div>
              
              <div className="flex flex-col">
                <span className={cn(
                  "text-sm font-medium",
                  isCurrent || isCompleted ? "text-gray-900 dark:text-white" : "text-gray-500 dark:text-white/50"
                )}>
                  {step.title}
                </span>
                {step.description && (
                  <span className="text-xs text-gray-500 dark:text-white/40 hidden md:block">
                    {step.description}
                  </span>
                )}
              </div>
            </div>

            {/* Connector Line (Desktop) */}
            {index < steps.length - 1 && (
              <div 
                className={cn(
                  "hidden h-px flex-1 bg-gray-200 md:block dark:bg-white/[0.03]",
                  isCompleted && "bg-blue-600 dark:bg-blue-500"
                )} 
              />
            )}
          </div>
        );
      })}
    </div>
  );
};



=== FILE: packages\ui\src\components\navigation\Tabs.tsx ===

import React, { createContext, useContext, useState } from 'react';
import { cn } from '../../utils/cn';

interface TabsContextValue {
  value: string;
  onValueChange: (value: string) => void;
}

const TabsContext = createContext<TabsContextValue | undefined>(undefined);

export interface TabsProps extends React.HTMLAttributes<HTMLDivElement> {
  defaultValue: string;
  value?: string;
  onValueChange?: (value: string) => void;
  children: React.ReactNode;
}

export function Tabs({
  defaultValue,
  value,
  onValueChange,
  className,
  children,
  ...props
}: TabsProps) {
  const [internalValue, setInternalValue] = useState(defaultValue);

  const handleValueChange = (newValue: string) => {
    if (value === undefined) {
      setInternalValue(newValue);
    }
    onValueChange?.(newValue);
  };

  const currentValue = value !== undefined ? value : internalValue;

  return (
    <TabsContext.Provider value={{ value: currentValue, onValueChange: handleValueChange }}>
      <div className={cn("w-full", className)} {...props}>
        {children}
      </div>
    </TabsContext.Provider>
  );
}

export interface TabsListProps extends React.HTMLAttributes<HTMLDivElement> {
  children: React.ReactNode;
}

export function TabsList({ className, children, ...props }: TabsListProps) {
  return (
    <div
      role="tablist"
      className={cn(
        "inline-flex h-10 items-center justify-center rounded-2xl bg-gray-100 p-1 text-gray-500 dark:bg-white/[0.03] dark:text-white/60",
        className
      )}
      {...props}
    >
      {children}
    </div>
  );
}

export interface TabsTriggerProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  value: string;
  children: React.ReactNode;
}

export function TabsTrigger({ className, value, children, ...props }: TabsTriggerProps) {
  const context = useContext(TabsContext);
  if (!context) throw new Error('TabsTrigger must be used within Tabs');

  const isActive = context.value === value;

  return (
    <button
      type="button"
      role="tab"
      aria-selected={isActive}
      aria-controls={`tabs-content-${value}`}
      id={`tabs-trigger-${value}`}
      onClick={() => context.onValueChange(value)}
      className={cn(
        "inline-flex items-center justify-center whitespace-nowrap rounded-2xl px-3 py-1.5 text-sm font-medium ring-offset-white transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-gray-400 focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 dark:ring-offset-zinc-950 dark:focus-visible:ring-white/20",
        isActive
          ? "bg-white text-gray-900 shadow-sm dark:bg-white/[0.06] dark:text-white dark:backdrop-blur-sm"
          : "hover:bg-gray-200 hover:text-gray-900 dark:hover:bg-white/[0.03] dark:hover:text-white",
        className
      )}
      {...props}
    >
      {children}
    </button>
  );
}

export interface TabsContentProps extends React.HTMLAttributes<HTMLDivElement> {
  value: string;
  children: React.ReactNode;
}

export function TabsContent({ className, value, children, ...props }: TabsContentProps) {
  const context = useContext(TabsContext);
  if (!context) throw new Error('TabsContent must be used within Tabs');

  if (context.value !== value) return null;

  return (
    <div
      role="tabpanel"
      id={`tabs-content-${value}`}
      aria-labelledby={`tabs-trigger-${value}`}
      tabIndex={0}
      className={cn(
        "mt-2 ring-offset-white focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-white/20 focus-visible:ring-offset-2",
        className
      )}
      {...props}
    >
      {children}
    </div>
  );
}



=== FILE: packages\ui\src\components\navigation\UserMenu.tsx ===

import React from 'react';
import { Settings, LogOut, User } from 'lucide-react';
import { Avatar } from '../data-display/Avatar';
import { 
  DropdownMenu, 
  DropdownMenuTrigger, 
  DropdownMenuContent, 
  DropdownMenuItem, 
  DropdownMenuSeparator,
  DropdownMenuLabel
} from '../overlay/DropdownMenu';
import { cn } from '../../utils/cn';

export interface UserMenuProps {
  name: string;
  description?: string;
  avatarSrc?: string;
  avatarFallback?: string;
  className?: string;
  side?: 'top' | 'bottom' | 'left' | 'right';
  align?: 'start' | 'end' | 'center';
}

export function UserMenu({ 
  name, 
  description, 
  avatarSrc, 
  avatarFallback,
  className,
  side = 'top',
  align = 'start'
}: UserMenuProps) {
  return (
    <DropdownMenu>
      <DropdownMenuTrigger className={cn("w-full outline-none", className)}>
        <div className="group flex w-full items-center gap-3 rounded-2xl border border-gray-200 dark:border-white/5 bg-white dark:bg-white/[0.03] p-3 transition-colors hover:bg-gray-50 dark:hover:bg-white/[0.06]">
          <Avatar src={avatarSrc} fallback={avatarFallback || name.charAt(0)} size="sm" />
          <div className="flex flex-1 flex-col items-start text-left">
            <span className="text-xs font-medium text-gray-900 dark:text-white">{name}</span>
            {description && <span className="text-[10px] text-gray-500 dark:text-white/50">{description}</span>}
          </div>
          <Settings className="h-4 w-4 text-gray-400 dark:text-white/50 transition-colors group-hover:text-gray-900 dark:group-hover:text-white" />
        </div>
      </DropdownMenuTrigger>
      <DropdownMenuContent className="w-56" align={align} side={side}>
        <DropdownMenuLabel>My Account</DropdownMenuLabel>
        <DropdownMenuSeparator />
        <DropdownMenuItem>
          <User className="mr-2 h-4 w-4" />
          <span>Profile</span>
        </DropdownMenuItem>
        <DropdownMenuItem>
          <Settings className="mr-2 h-4 w-4" />
          <span>Settings</span>
        </DropdownMenuItem>
        <DropdownMenuSeparator />
        <DropdownMenuItem className="text-rose-400 focus:text-rose-400">
          <LogOut className="mr-2 h-4 w-4" />
          <span>Log out</span>
        </DropdownMenuItem>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}



=== FILE: packages\ui\src\components\overlay\Command.tsx ===

import React, { useEffect, useRef, useState } from 'react';
import { createPortal } from 'react-dom';
import { cn } from '../../utils/cn';
import type { ComboboxProps } from '../form/Combobox';
import { Combobox, ComboboxInput, ComboboxList, ComboboxItem, ComboboxEmpty } from '../form/Combobox';
import { Search } from 'lucide-react';

export interface CommandDialogProps extends ComboboxProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
}

export function Command({ children, ...props }: ComboboxProps) {
  return (
    <div className="flex h-full w-full flex-col overflow-hidden rounded-2xl bg-white dark:bg-black/90 text-gray-900 dark:text-white">
      <Combobox usePopover={false} {...props}>
        {children}
      </Combobox>
    </div>
  );
}

export function CommandDialog({ 
  children, 
  open, 
  onOpenChange,
  ...props 
}: CommandDialogProps) {
  const overlayRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    const handleEscape = (e: KeyboardEvent) => {
      if (e.key === 'Escape') onOpenChange(false);
    };

    if (open) {
      document.addEventListener('keydown', handleEscape);
      document.body.style.overflow = 'hidden';
    }

    return () => {
      document.removeEventListener('keydown', handleEscape);
      document.body.style.overflow = 'unset';
    };
  }, [open, onOpenChange]);

  const handleBackdropClick = (e: React.MouseEvent) => {
    if (e.target === overlayRef.current) {
      onOpenChange(false);
    }
  };

  if (!open) return null;

  return createPortal(
    <div
      ref={overlayRef}
      onClick={handleBackdropClick}
      className="fixed inset-0 z-[100] flex items-start justify-center bg-black/60 backdrop-blur-sm animate-in fade-in duration-200 pt-[20vh]"
    >
      <div className="relative w-full max-w-lg overflow-hidden rounded-2xl border border-gray-200 dark:border-white/10 bg-white dark:bg-black/90 shadow-2xl animate-in zoom-in-95 duration-200">
        <Combobox usePopover={false} {...props}>
          {children}
        </Combobox>
      </div>
    </div>,
    document.body
  );
}

export function CommandInput({ className, ...props }: React.InputHTMLAttributes<HTMLInputElement>) {
  return (
    <div className="flex items-center border-b border-gray-200 dark:border-white/10 px-3" cmdk-input-wrapper="">
      <Search className="mr-2 h-4 w-4 shrink-0 opacity-50" />
      <ComboboxInput 
        className={cn(
          "flex h-12 w-full rounded-md bg-transparent py-3 text-sm text-gray-900 dark:text-white outline-none placeholder:text-gray-400 dark:placeholder:text-white/50 disabled:cursor-not-allowed disabled:opacity-50 border-none focus:ring-0 px-0",
          className
        )}
        {...props}
      />
    </div>
  );
}

export function CommandList({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) {
  return (
    <ComboboxList 
      className={cn("max-h-[300px] overflow-y-auto overflow-x-hidden p-2", className)} 
      {...props} 
    />
  );
}

export function CommandEmpty(props: React.HTMLAttributes<HTMLDivElement>) {
  return <ComboboxEmpty className="py-6 text-center text-sm" {...props} />;
}

export function CommandGroup({ 
  children, 
  heading, 
  className, 
  ...props 
}: React.HTMLAttributes<HTMLDivElement> & { heading?: React.ReactNode }) {
  return (
    <div className={cn("overflow-hidden p-1 text-gray-900 dark:text-white", className)} {...props}>
      {heading && (
        <div className="px-2 py-1.5 text-xs font-medium text-gray-500 dark:text-white/50">
          {heading}
        </div>
      )}
      {children}
    </div>
  );
}

export function CommandItem({ 
  className, 
  ...props 
}: React.ComponentProps<typeof ComboboxItem>) {
  return (
    <ComboboxItem 
      className={cn(
        "relative flex cursor-default select-none items-center rounded-2xl px-2 py-1.5 text-sm outline-none text-gray-900 dark:text-white aria-selected:bg-gray-100 dark:aria-selected:bg-white/[0.06] aria-selected:text-gray-900 dark:aria-selected:text-white data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
        className
      )} 
      {...props} 
    />
  );
}

export function CommandShortcut({ className, ...props }: React.HTMLAttributes<HTMLSpanElement>) {
  return (
    <span
      className={cn(
        "ml-auto text-xs tracking-widest text-gray-400 dark:text-white/50",
        className
      )}
      {...props}
    />
  );
}



=== FILE: packages\ui\src\components\overlay\ConfirmDialog.tsx ===

import React from 'react';
import { Modal, ModalHeader, ModalFooter } from './Modal';
import { Heading } from '../typography/Heading';
import { Text } from '../typography/Text';
import { Button } from '../button/Button';
import { AlertTriangle } from 'lucide-react';
import { cn } from '../../utils/cn';

export interface ConfirmDialogProps {
  isOpen: boolean;
  onClose: () => void;
  onConfirm: () => void;
  title: string;
  description: string;
  confirmText?: string;
  cancelText?: string;
  variant?: 'danger' | 'primary';
  isLoading?: boolean;
}

/**
 * A specialized modal for confirming destructive or important actions.
 */
export function ConfirmDialog({
  isOpen,
  onClose,
  onConfirm,
  title,
  description,
  confirmText = 'Confirm',
  cancelText = 'Cancel',
  variant = 'primary',
  isLoading = false,
}: ConfirmDialogProps) {
  return (
    <Modal isOpen={isOpen} onClose={onClose}>
      <ModalHeader>
        <div className="flex items-center gap-3">
          {variant === 'danger' && (
            <div className="flex h-10 w-10 items-center justify-center rounded-full bg-rose-500/10 text-rose-500">
              <AlertTriangle className="h-5 w-5" />
            </div>
          )}
          <Heading as="h3">{title}</Heading>
        </div>
      </ModalHeader>
      
      <div className="py-2">
        <Text className="text-gray-500 dark:text-white/60">
          {description}
        </Text>
      </div>

      <ModalFooter>
        <Button variant="ghost" onClick={onClose} disabled={isLoading}>
          {cancelText}
        </Button>
        <Button 
          variant={variant === 'danger' ? 'danger' : 'primary'} 
          onClick={onConfirm}
          isLoading={isLoading}
        >
          {confirmText}
        </Button>
      </ModalFooter>
    </Modal>
  );
}



=== FILE: packages\ui\src\components\overlay\Dialog.tsx ===

import React, { useEffect, useRef } from 'react';
import { createPortal } from 'react-dom';
import { cn } from '../../utils/cn';
import { Heading } from '../typography/Heading';

export interface DialogProps {
  isOpen: boolean;
  onClose: () => void;
  children: React.ReactNode;
  className?: string;
}

export function Dialog({ isOpen, onClose, children, className }: DialogProps) {
  const dialogRef = useRef<HTMLDialogElement>(null);

  const [mounted, setMounted] = React.useState(false);

  useEffect(() => {
    setMounted(true);
  }, []);

  useEffect(() => {
    const dialog = dialogRef.current;
    if (!dialog) return;

    if (isOpen) {
      if (!dialog.open) {
        dialog.showModal();
      }
    } else {
      if (dialog.open) {
        dialog.close();
      }
    }
  }, [isOpen, mounted]);

  useEffect(() => {
    const dialog = dialogRef.current;
    if (!dialog) return;

    const handleCancel = (e: Event) => {
      e.preventDefault();
      onClose();
    };

    dialog.addEventListener('cancel', handleCancel);
    return () => dialog.removeEventListener('cancel', handleCancel);
  }, [onClose, mounted]);

  const handleBackdropClick = (e: React.MouseEvent) => {
    if (e.target === dialogRef.current) {
      onClose();
    }
  };

  if (!mounted) return null;

  return createPortal(
    <dialog
      ref={dialogRef}
      onClick={handleBackdropClick}
      className={cn(
        "fixed inset-0 z-[100] m-auto bg-transparent p-0 backdrop:bg-black/60 backdrop:backdrop-blur-sm open:flex open:items-center open:justify-center",
        "open:animate-in open:fade-in open:duration-200",
        className
      )}
    >
      <div
        className={cn(
          "relative w-full max-w-lg scale-100 gap-4 border border-zinc-200 dark:border-white/10 bg-white dark:bg-[#0A0A0A]/90 p-6 shadow-2xl backdrop-blur-xl transition-all sm:rounded-2xl",
          "animate-in fade-in zoom-in-95 duration-200 slide-in-from-bottom-2"
        )}
      >
        {children}
        <button
          onClick={onClose}
          className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-gray-400 dark:focus:ring-white/20 disabled:pointer-events-none"
        >
          <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="text-gray-900 dark:text-white">
            <line x1="18" y1="6" x2="6" y2="18" />
            <line x1="6" y1="6" x2="18" y2="18" />
          </svg>
          <span className="sr-only">Close</span>
        </button>
      </div>
    </dialog>,
    document.body
  );
}

export function DialogHeader({ className, children }: React.HTMLAttributes<HTMLDivElement>) {
  return (
    <div className={cn("flex flex-col space-y-1.5 text-center sm:text-left mb-4", className)}>
      {children}
    </div>
  );
}

export function DialogFooter({ className, children }: React.HTMLAttributes<HTMLDivElement>) {
  return (
    <div className={cn("flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2 mt-6", className)}>
      {children}
    </div>
  );
}

export function DialogTitle({ className, children }: React.HTMLAttributes<HTMLHeadingElement>) {
  return (
    <Heading as="h2" className={cn("text-lg font-semibold leading-none tracking-tight", className)}>
      {children}
    </Heading>
  );
}

export function DialogDescription({ className, children }: React.HTMLAttributes<HTMLParagraphElement>) {
  return (
    <p className={cn("text-sm text-gray-500 dark:text-gray-400", className)}>
      {children}
    </p>
  );
}



=== FILE: packages\ui\src\components\overlay\Drawer.tsx ===

import React, { useEffect, useState, useRef } from 'react';
import { createPortal } from 'react-dom';
import { cn } from '../../utils/cn';
import { Heading } from '../typography/Heading';
import { Text } from '../typography/Text';

export interface DrawerProps {
  isOpen: boolean;
  onClose: () => void;
  position?: 'left' | 'right' | 'bottom';
  children: React.ReactNode;
  className?: string;
}

export function Drawer({ 
  isOpen, 
  onClose, 
  position = 'right', 
  children, 
  className 
}: DrawerProps) {
  const [isVisible, setIsVisible] = useState(false);
  const [shouldRender, setShouldRender] = useState(false);
  const overlayRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    if (isOpen) {
      setShouldRender(true);
      // Small delay to allow render before animating in
      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          setIsVisible(true);
        });
      });
      document.body.style.overflow = 'hidden';
    } else {
      setIsVisible(false);
      const timer = setTimeout(() => {
        setShouldRender(false);
        document.body.style.overflow = 'unset';
      }, 300); // Match transition duration
      return () => clearTimeout(timer);
    }
  }, [isOpen]);

  useEffect(() => {
    const handleEscape = (e: KeyboardEvent) => {
      if (e.key === 'Escape') onClose();
    };

    if (isOpen) {
      document.addEventListener('keydown', handleEscape);
    }

    return () => {
      document.removeEventListener('keydown', handleEscape);
    };
  }, [isOpen, onClose]);

  const handleBackdropClick = (e: React.MouseEvent) => {
    if (e.target === overlayRef.current) {
      onClose();
    }
  };

  if (!shouldRender) return null;

  const positionClasses = {
    left: "left-0 h-full w-3/4 max-w-sm border-r",
    right: "right-0 h-full w-3/4 max-w-sm border-l",
    bottom: "bottom-0 w-full h-auto max-h-[90vh] border-t rounded-t-2xl",
  };

  const translateClasses = {
    left: isVisible ? "translate-x-0" : "-translate-x-full",
    right: isVisible ? "translate-x-0" : "translate-x-full",
    bottom: isVisible ? "translate-y-0" : "translate-y-full",
  };

  return createPortal(
    <div
      ref={overlayRef}
      onClick={handleBackdropClick}
      className={cn(
        "fixed inset-0 z-[100] flex bg-black/60 backdrop-blur-sm transition-opacity duration-300",
        isVisible ? "opacity-100" : "opacity-0"
      )}
      role="dialog"
      aria-modal="true"
    >
      <div
        className={cn(
          "absolute bg-white dark:bg-[#0A0A0A] border-gray-200 dark:border-white/10 p-6 shadow-2xl transition-transform duration-300 ease-in-out",
          positionClasses[position],
          translateClasses[position],
          className
        )}
      >
        {children}
      </div>
    </div>,
    document.body
  );
}

export function DrawerHeader({ className, children, ...props }: React.HTMLAttributes<HTMLDivElement>) {
  return (
    <div className={cn("flex flex-col space-y-1.5 text-center sm:text-left mb-6", className)} {...props}>
      {children}
    </div>
  );
}

export function DrawerFooter({ className, children, ...props }: React.HTMLAttributes<HTMLDivElement>) {
  return (
    <div className={cn("flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2 mt-auto pt-6", className)} {...props}>
      {children}
    </div>
  );
}

export function DrawerTitle({ className, children, ...props }: React.HTMLAttributes<HTMLHeadingElement>) {
  return (
    <Heading as="h2" className={cn("text-lg font-semibold leading-none tracking-tight", className)} {...props}>
      {children}
    </Heading>
  );
}

export function DrawerDescription({ className, children, ...props }: React.HTMLAttributes<HTMLParagraphElement>) {
  return (
    <Text variant="muted" className={cn("text-sm", className)} {...props}>
      {children}
    </Text>
  );
}



=== FILE: packages\ui\src\components\overlay\DropdownMenu.tsx ===

import React, { createContext, useContext, useState, useRef, useEffect, useLayoutEffect } from 'react';
import { createPortal } from 'react-dom';
import { cn } from '../../utils/cn';import { useFloating } from '../../hooks/useFloating';
interface DropdownMenuContextValue {
  isOpen: boolean;
  setIsOpen: (isOpen: boolean) => void;
  triggerRef: React.RefObject<HTMLElement>;
}

const DropdownMenuContext = createContext<DropdownMenuContextValue | undefined>(undefined);

export interface DropdownMenuProps {
  children: React.ReactNode;
}

export function DropdownMenu({ children }: DropdownMenuProps) {
  const [isOpen, setIsOpen] = useState(false);
  const triggerRef = useRef<HTMLElement>(null);

  return (
    <DropdownMenuContext.Provider value={{ isOpen, setIsOpen, triggerRef }}>
      <div className="relative inline-block text-left">
        {children}
      </div>
    </DropdownMenuContext.Provider>
  );
}

export interface DropdownMenuTriggerProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  children: React.ReactNode;
}

export function DropdownMenuTrigger({ className, children, ...props }: DropdownMenuTriggerProps) {
  const context = useContext(DropdownMenuContext);
  if (!context) throw new Error('DropdownMenuTrigger must be used within DropdownMenu');

  const handleClick = (e: React.MouseEvent) => {
    context.setIsOpen(!context.isOpen);
    props.onClick?.(e as any);
  };

  return (
    <button
      ref={context.triggerRef as any}
      type="button"
      aria-haspopup="menu"
      aria-expanded={context.isOpen ? "true" : "false"}
      onClick={handleClick}
      className={cn("inline-flex items-center justify-center", className)}
      {...props}
    >
      {children}
    </button>
  );
}

export interface DropdownMenuContentProps extends React.HTMLAttributes<HTMLDivElement> {
  children: React.ReactNode;
  align?: 'start' | 'end' | 'center';
  side?: 'top' | 'bottom' | 'left' | 'right';
}

export function DropdownMenuContent({ className, children, align = 'start', side = 'bottom', ...props }: DropdownMenuContentProps) {
  const context = useContext(DropdownMenuContext);
  if (!context) throw new Error('DropdownMenuContent must be used within DropdownMenu');

  const contentRef = useRef<HTMLDivElement>(null);
  const { position, isPositioned } = useFloating(context.triggerRef, contentRef, {
    side,
    align,
    isOpen: context.isOpen,
  });

  useEffect(() => {
    if (context.isOpen) {
      const handleOutsideClick = (e: MouseEvent) => {
        if (
          contentRef.current &&
          !contentRef.current.contains(e.target as Node) &&
          context.triggerRef.current &&
          !context.triggerRef.current.contains(e.target as Node)
        ) {
          context.setIsOpen(false);
        }
      };

      const handleKeyDown = (e: KeyboardEvent) => {
        if (e.key === 'Escape') {
          context.setIsOpen(false);
          context.triggerRef.current?.focus();
        }
        
        if (e.key === 'ArrowDown' || e.key === 'ArrowUp') {
          e.preventDefault();
          const items = contentRef.current?.querySelectorAll('[role="menuitem"]') as NodeListOf<HTMLElement>;
          if (!items.length) return;
          
          const currentIndex = Array.from(items).indexOf(document.activeElement as HTMLElement);
          let nextIndex = 0;
          
          if (e.key === 'ArrowDown') {
            nextIndex = (currentIndex + 1) % items.length;
          } else {
            nextIndex = (currentIndex - 1 + items.length) % items.length;
          }
          
          items[nextIndex]?.focus();
        }
      };

      document.addEventListener('mousedown', handleOutsideClick);
      document.addEventListener('keydown', handleKeyDown);
      return () => {
        document.removeEventListener('mousedown', handleOutsideClick);
        document.removeEventListener('keydown', handleKeyDown);
      };
    }
  }, [context.isOpen, context.setIsOpen, context.triggerRef]);

  if (!context.isOpen) return null;

  const getTransformOrigin = () => {
    if (side === 'bottom') {
      if (align === 'start') return 'top left';
      if (align === 'end') return 'top right';
      return 'top center';
    }
    if (side === 'top') {
      if (align === 'start') return 'bottom left';
      if (align === 'end') return 'bottom right';
      return 'bottom center';
    }
    if (side === 'left') {
      if (align === 'start') return 'top right';
      if (align === 'end') return 'bottom right';
      return 'center right';
    }
    if (side === 'right') {
      if (align === 'start') return 'top left';
      if (align === 'end') return 'bottom left';
      return 'center left';
    }
    return 'center center';
  };

  return createPortal(
    <div
      ref={contentRef}
      role="menu"
      aria-orientation="vertical"
      style={{ 
        top: position.top, 
        left: position.left,
        transformOrigin: getTransformOrigin(),
      }}
      className={cn(
        "fixed z-[110] min-w-[8rem] overflow-hidden rounded-2xl border border-gray-200 dark:border-white/10 bg-white/80 dark:bg-white/[0.03] backdrop-blur-xl p-1 shadow-md duration-100",
        isPositioned ? "animate-in fade-in zoom-in-95 opacity-100" : "opacity-0",
        className
      )}
      {...props}
    >
      {children}
    </div>,
    document.body
  );
}

export interface DropdownMenuItemProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  children: React.ReactNode;
}

export function DropdownMenuItem({ className, children, ...props }: DropdownMenuItemProps) {
  const context = useContext(DropdownMenuContext);
  
  const handleClick = (e: React.MouseEvent) => {
    context?.setIsOpen(false);
    props.onClick?.(e as any);
  };

  return (
    <button
      type="button"
      role="menuitem"
      onClick={handleClick}
      className={cn(
        "relative flex w-full cursor-pointer select-none items-center rounded-2xl px-3 py-2 text-sm outline-none transition-colors",
        "text-gray-700 dark:text-white/80",
        "hover:bg-gray-100 hover:text-gray-900 dark:hover:bg-white/[0.06] dark:hover:text-white",
        "focus:bg-gray-100 focus:text-gray-900 dark:focus:bg-white/[0.06] dark:focus:text-white",
        "data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
        className
      )}
      {...props}
    >
      {children}
    </button>
  );
}

export function DropdownMenuLabel({ className, children, ...props }: React.HTMLAttributes<HTMLDivElement>) {
  return (
    <div className={cn("px-2 py-1.5 text-sm font-semibold text-gray-900 dark:text-white", className)} {...props}>
      {children}
    </div>
  );
}

export function DropdownMenuSeparator({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) {
  return (
    <div className={cn("-mx-1 my-1 h-px bg-gray-200 dark:bg-white/[0.03]", className)} {...props} />
  );
}



=== FILE: packages\ui\src\components\overlay\Modal.tsx ===

import React, { useEffect, useRef } from 'react';
import { createPortal } from 'react-dom';
import { cn } from '../../utils/cn';
import { Heading } from '../typography/Heading';
import { Text } from '../typography/Text';

export interface ModalProps {
  isOpen: boolean;
  onClose: () => void;
  children: React.ReactNode;
  className?: string;
}

export function Modal({ isOpen, onClose, children, className }: ModalProps) {
  const dialogRef = useRef<HTMLDialogElement>(null);

  const [mounted, setMounted] = React.useState(false);

  useEffect(() => {
    setMounted(true);
  }, []);

  useEffect(() => {
    const dialog = dialogRef.current;
    if (!dialog) return;

    if (isOpen) {
      if (!dialog.open) {
        dialog.showModal();
        document.body.style.overflow = 'hidden';
      }
    } else {
      if (dialog.open) {
        dialog.close();
        document.body.style.overflow = 'unset';
      }
    }
  }, [isOpen, mounted]);

  useEffect(() => {
    const dialog = dialogRef.current;
    if (!dialog) return;

    const handleCancel = (e: Event) => {
      e.preventDefault();
      onClose();
    };

    dialog.addEventListener('cancel', handleCancel);
    return () => dialog.removeEventListener('cancel', handleCancel);
  }, [onClose, mounted]);

  const handleBackdropClick = (e: React.MouseEvent) => {
    if (e.target === dialogRef.current) {
      onClose();
    }
  };

  if (!mounted) return null;

  return createPortal(
    <dialog
      ref={dialogRef}
      onClick={handleBackdropClick}
      className={cn(
        "fixed inset-0 z-[100] m-auto bg-transparent p-0 backdrop:bg-black/60 backdrop:backdrop-blur-sm open:flex open:items-center open:justify-center",
        "animate-in fade-in duration-200",
        className
      )}
    >
      <div
        className={cn(
          "relative w-full max-w-lg scale-100 gap-4 border border-zinc-200 dark:border-white/10 bg-white dark:bg-[#0A0A0A]/90 p-6 shadow-2xl backdrop-blur-xl transition-all sm:rounded-2xl",
          "animate-in fade-in zoom-in-95 duration-200 slide-in-from-bottom-2"
        )}
      >
        {children}
        <button
          onClick={onClose}
          className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-gray-400 dark:focus:ring-white/20 disabled:pointer-events-none"
        >
          <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="text-gray-900 dark:text-white">
            <line x1="18" y1="6" x2="6" y2="18" />
            <line x1="6" y1="6" x2="18" y2="18" />
          </svg>
          <span className="sr-only">Close</span>
        </button>
      </div>
    </dialog>,
    document.body
  );
}

export function ModalHeader({ className, children }: React.HTMLAttributes<HTMLDivElement>) {
  return (
    <div className={cn("flex flex-col space-y-1.5 text-center sm:text-left mb-4", className)}>
      {children}
    </div>
  );
}

export function ModalFooter({ className, children }: React.HTMLAttributes<HTMLDivElement>) {
  return (
    <div className={cn("flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2 mt-6", className)}>
      {children}
    </div>
  );
}

export function ModalTitle({ className, children }: React.HTMLAttributes<HTMLHeadingElement>) {
  return (
    <Heading as="h2" className={cn("text-lg font-semibold leading-none tracking-tight", className)}>
      {children}
    </Heading>
  );
}

export function ModalDescription({ className, children }: React.HTMLAttributes<HTMLParagraphElement>) {
  return (
    <Text variant="muted" className={cn("text-sm", className)}>
      {children}
    </Text>
  );
}



=== FILE: packages\ui\src\components\overlay\Popover.tsx ===

import React, { createContext, useContext, useState, useRef, useEffect, useLayoutEffect } from 'react';
import { createPortal } from 'react-dom';
import { cn } from '../../utils/cn';
import { useFloating } from '../../hooks/useFloating';

interface PopoverContextValue {
  isOpen: boolean;
  setIsOpen: (isOpen: boolean) => void;
  triggerRef: React.RefObject<HTMLElement>;
}

const PopoverContext = createContext<PopoverContextValue | undefined>(undefined);

export interface PopoverProps {
  children: React.ReactNode;
  open?: boolean;
  onOpenChange?: (open: boolean) => void;
}

export function Popover({ children, open, onOpenChange }: PopoverProps) {
  const [internalOpen, setInternalOpen] = useState(false);
  const triggerRef = useRef<HTMLElement>(null);

  const isControlled = open !== undefined;
  const isOpen = isControlled ? open : internalOpen;
  const setIsOpen = (newOpen: boolean) => {
    if (!isControlled) {
      setInternalOpen(newOpen);
    }
    onOpenChange?.(newOpen);
  };

  return (
    <PopoverContext.Provider value={{ isOpen, setIsOpen, triggerRef }}>
      <div className="relative inline-block">
        {children}
      </div>
    </PopoverContext.Provider>
  );
}

export interface PopoverTriggerProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  children: React.ReactNode;
}

export function PopoverTrigger({ className, children, ...props }: PopoverTriggerProps) {
  const context = useContext(PopoverContext);
  if (!context) throw new Error('PopoverTrigger must be used within Popover');

  const handleClick = (e: React.MouseEvent) => {
    context.setIsOpen(!context.isOpen);
    props.onClick?.(e as any);
  };

  return (
    <button
      ref={context.triggerRef as any}
      type="button"
      aria-haspopup="dialog"
      aria-expanded={context.isOpen ? "true" : "false"}
      onClick={handleClick}
      className={cn("inline-flex items-center justify-center", className)}
      {...props}
    >
      {children}
    </button>
  );
}

export interface PopoverContentProps extends React.HTMLAttributes<HTMLDivElement> {
  children: React.ReactNode;
  align?: 'start' | 'end' | 'center';
  sideOffset?: number;
}

export function PopoverContent({ className, children, align = 'center', sideOffset = 4, ...props }: PopoverContentProps) {
  const context = useContext(PopoverContext);
  if (!context) throw new Error('PopoverContent must be used within Popover');

  const contentRef = useRef<HTMLDivElement>(null);
  const { position, isPositioned } = useFloating(context.triggerRef, contentRef, {
    side: 'bottom',
    align,
    sideOffset,
    isOpen: context.isOpen,
  });

  useEffect(() => {
    if (context.isOpen) {
      const handleOutsideClick = (e: MouseEvent) => {
        if (
          contentRef.current &&
          !contentRef.current.contains(e.target as Node) &&
          context.triggerRef.current &&
          !context.triggerRef.current.contains(e.target as Node)
        ) {
          context.setIsOpen(false);
        }
      };

      document.addEventListener('mousedown', handleOutsideClick);
      return () => {
        document.removeEventListener('mousedown', handleOutsideClick);
      };
    }
  }, [context.isOpen, context.setIsOpen, context.triggerRef]);

  if (!context.isOpen) return null;

  const getTransformOrigin = () => {
    // Popover currently only supports top/bottom in its logic, but let's make it robust
    const side = position.top > (context.triggerRef.current?.getBoundingClientRect().top || 0) ? 'bottom' : 'top';
    
    if (side === 'bottom') {
      if (align === 'start') return 'top left';
      if (align === 'end') return 'top right';
      return 'top center';
    }
    if (side === 'top') {
      if (align === 'start') return 'bottom left';
      if (align === 'end') return 'bottom right';
      return 'bottom center';
    }
    return 'center center';
  };

  return createPortal(
    <div
      ref={contentRef}
      style={{ 
        top: position.top, 
        left: position.left,
        transformOrigin: getTransformOrigin(),
      }}
      className={cn(
        "fixed z-[110] min-w-[12rem] rounded-2xl border border-gray-200 dark:border-white/10 bg-white/80 dark:bg-white/[0.03] backdrop-blur-xl p-4 shadow-xl outline-none duration-200",
        isPositioned ? "animate-in fade-in zoom-in-95 opacity-100" : "opacity-0",
        className
      )}
      {...props}
    >
      {children}
    </div>,
    document.body
  );
}



=== FILE: packages\ui\src\components\overlay\Tooltip.tsx ===

import React, { useState, useRef, useEffect } from 'react';
import { createPortal } from 'react-dom';
import { cn } from '../../utils/cn';
import { useFloating } from '../../hooks/useFloating';

export type TooltipPosition = 'top' | 'bottom' | 'left' | 'right';

export interface TooltipProps {
  content: React.ReactNode;
  children: React.ReactNode;
  position?: TooltipPosition;
  delay?: number;
  className?: string;
}

export function Tooltip({ 
  content, 
  children, 
  position = 'top', 
  delay = 200,
  className 
}: TooltipProps) {
  const [isVisible, setIsVisible] = useState(false);
  const timeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null);
  const triggerRef = useRef<HTMLDivElement>(null);
  const contentRef = useRef<HTMLDivElement>(null);

  const { position: floatingPosition, isPositioned } = useFloating(triggerRef, contentRef, {
    side: position,
    align: 'center',
    sideOffset: 8,
    isOpen: isVisible,
  });

  const showTooltip = () => {
    if (timeoutRef.current) clearTimeout(timeoutRef.current);
    timeoutRef.current = setTimeout(() => setIsVisible(true), delay);
  };

  const hideTooltip = () => {
    if (timeoutRef.current) clearTimeout(timeoutRef.current);
    setIsVisible(false);
  };

  useEffect(() => {
    return () => {
      if (timeoutRef.current) clearTimeout(timeoutRef.current);
    };
  }, []);

  const animationClasses = {
    top: 'slide-in-from-bottom-2',
    bottom: 'slide-in-from-top-2',
    left: 'slide-in-from-right-2',
    right: 'slide-in-from-left-2',
  };

  return (
    <div 
      ref={triggerRef}
      className="relative inline-flex" 
      onMouseEnter={showTooltip} 
      onMouseLeave={hideTooltip}
      onFocus={showTooltip}
      onBlur={hideTooltip}
    >
      {children}
      {isVisible && createPortal(
        <div
          ref={contentRef}
          role="tooltip"
          style={{
            top: floatingPosition.top,
            left: floatingPosition.left,
          }}
          className={cn(
            "fixed z-[120] min-w-max max-w-xs rounded-2xl border border-gray-200 dark:border-white/10 bg-white dark:bg-[#0A0A0A]/90 px-3 py-1.5 text-xs text-gray-900 dark:text-white shadow-xl backdrop-blur-md",
            "duration-200",
            isPositioned ? "animate-in fade-in opacity-100" : "opacity-0",
            animationClasses[position],
            className
          )}
        >
          {content}
        </div>,
        document.body
      )}
    </div>
  );
}



=== FILE: packages\ui\src\components\shared\BulkActionBar.tsx ===

import React from 'react';
import { cn } from '../../utils/cn';
import { X, Trash2, Forward, CheckSquare, MessageSquare, Copy } from 'lucide-react';
import { motion, AnimatePresence } from 'framer-motion';

interface BulkActionBarProps {
  isVisible: boolean;
  selectedCount: number;
  onClose: () => void;
  onDelete?: () => void;
  onForward?: () => void;
  onMarkRead?: () => void;
  onCopyAll?: () => void;
}

export function BulkActionBar({ 
  isVisible, 
  selectedCount, 
  onClose, 
  onDelete, 
  onForward, 
  onMarkRead,
  onCopyAll
}: BulkActionBarProps) {
  return (
    <AnimatePresence>
      {isVisible && (
        <motion.div 
          initial={{ y: 100, opacity: 0 }}
          animate={{ y: 0, opacity: 1 }}
          exit={{ y: 100, opacity: 0 }}
          className="fixed bottom-24 left-1/2 -translate-x-1/2 z-[100] w-full max-w-lg px-4"
        >
          <div className="bg-[#1a1a1a]/90 backdrop-blur-2xl border border-white/10 rounded-2xl shadow-2xl p-3 flex items-center justify-between gap-4">
            <div className="flex items-center gap-3 pl-2">
              <button 
                onClick={onClose}
                className="p-1.5 rounded-lg hover:bg-white/5 text-white/40 hover:text-white transition-all"
              >
                <X size={18} />
              </button>
              <div className="flex flex-col">
                <span className="text-white font-bold text-sm">{selectedCount} selecionados</span>
                <span className="text-white/40 text-[10px] font-bold uppercase tracking-widest">A√ß√µes em massa</span>
              </div>
            </div>

            <div className="flex items-center gap-1">
              <ActionButton 
                icon={<Forward size={18} />} 
                label="Encaminhar" 
                onClick={onForward} 
                variant="ghost"
              />
              <ActionButton 
                icon={<Copy size={18} />} 
                label="Copiar" 
                onClick={onCopyAll} 
                variant="ghost"
              />
              <ActionButton 
                icon={<MessageSquare size={18} />} 
                label="Lido" 
                onClick={onMarkRead} 
                variant="ghost"
              />
              <div className="w-px h-8 bg-white/10 mx-1" />
              <ActionButton 
                icon={<Trash2 size={18} />} 
                label="Excluir" 
                onClick={onDelete} 
                variant="danger"
              />
            </div>
          </div>
        </motion.div>
      )}
    </AnimatePresence>
  );
}

function ActionButton({ 
  icon, 
  label, 
  onClick, 
  variant = 'ghost' 
}: { 
  icon: React.ReactNode; 
  label: string; 
  onClick?: () => void;
  variant?: 'ghost' | 'danger';
}) {
  return (
    <button 
      onClick={onClick}
      className={cn(
        "flex flex-col items-center justify-center w-14 h-14 rounded-xl transition-all group active:scale-95",
        variant === 'ghost' 
          ? "text-white/60 hover:text-white hover:bg-white/5" 
          : "text-rose-500 hover:text-rose-400 hover:bg-rose-500/10"
      )}
    >
      {icon}
      <span className="text-[10px] mt-1 font-medium scale-90 group-hover:scale-100 transition-transform">
        {label}
      </span>
    </button>
  );
}



=== FILE: packages\ui\src\components\shared\ConnectionStatusBanner.tsx ===

import React from 'react';
import { cn } from '../../utils/cn';
import { WifiOff, RefreshCcw, AlertTriangle } from 'lucide-react';
import { motion, AnimatePresence } from 'framer-motion';

interface ConnectionStatusBannerProps {
  status: 'disconnected' | 'connecting' | 'reconnecting' | 'error';
  onRetry?: () => void;
  message?: string;
}

export function ConnectionStatusBanner({ status, onRetry, message }: ConnectionStatusBannerProps) {
  const config = {
    disconnected: {
      bg: 'bg-rose-500/10',
      border: 'border-rose-500/20',
      text: 'text-rose-400',
      icon: <WifiOff size={14} />,
      label: 'Telefone Desconectado'
    },
    connecting: {
      bg: 'bg-amber-500/10',
      border: 'border-amber-500/20',
      text: 'text-amber-400',
      icon: <RefreshCcw size={14} className="animate-spin" />,
      label: 'Conectando...'
    },
    reconnecting: {
      bg: 'bg-blue-500/10',
      border: 'border-blue-500/20',
      text: 'text-blue-400',
      icon: <RefreshCcw size={14} className="animate-spin" />,
      label: 'Tentando reconectar...'
    },
    error: {
      bg: 'bg-rose-500/10',
      border: 'border-rose-500/20',
      text: 'text-rose-400',
      icon: <AlertTriangle size={14} />,
      label: 'Erro na conex√£o'
    }
  }[status];

  return (
    <AnimatePresence>
      <motion.div
        initial={{ y: -20, opacity: 0 }}
        animate={{ y: 0, opacity: 1 }}
        exit={{ y: -20, opacity: 0 }}
        className={cn(
          "flex items-center justify-center gap-4 py-2 px-4 border-b backdrop-blur-md z-50",
          config.bg,
          config.border
        )}
      >
        <div className={cn("flex items-center gap-2 text-xs font-bold uppercase tracking-widest", config.text)}>
          {config.icon}
          {message || config.label}
        </div>
        
        {onRetry && (status === 'disconnected' || status === 'error') && (
          <button 
            onClick={onRetry}
            className="flex items-center gap-1.5 px-3 py-1 rounded-full bg-white/5 hover:bg-white/10 border border-white/5 text-[10px] font-bold text-white transition-all active:scale-95"
          >
            Tentar agora
            <RefreshCcw size={10} />
          </button>
        )}
      </motion.div>
    </AnimatePresence>
  );
}



=== FILE: packages\ui\src\components\theme\ThemeProvider.tsx ===

import React, { createContext, useContext, useEffect, useState } from "react"

type Theme = "dark" | "light" | "system"

type ThemeProviderProps = {
  children: React.ReactNode
  defaultTheme?: Theme
  storageKey?: string
}

type ThemeProviderState = {
  theme: Theme
  setTheme: (theme: Theme) => void
}

const initialState: ThemeProviderState = {
  theme: "system",
  setTheme: () => null,
}

const ThemeProviderContext = createContext<ThemeProviderState>(initialState)

export function ThemeProvider({
  children,
  defaultTheme = "system",
  storageKey = "pixonui-ui-theme",
  ...props
}: ThemeProviderProps) {
  const [theme, setTheme] = useState<Theme>(
    () => (localStorage.getItem(storageKey) as Theme) || defaultTheme
  )

  useEffect(() => {
    const root = window.document.documentElement

    root.classList.remove("light", "dark")

    if (theme === "system") {
      const systemTheme = window.matchMedia("(prefers-color-scheme: dark)")
        .matches
        ? "dark"
        : "light"

      root.classList.add(systemTheme)
      return
    }

    root.classList.add(theme)
  }, [theme])

  const value = {
    theme,
    setTheme: (theme: Theme) => {
      localStorage.setItem(storageKey, theme)
      setTheme(theme)
    },
  }

  return (
    <ThemeProviderContext.Provider {...props} value={value}>
      {children}
    </ThemeProviderContext.Provider>
  )
}

export const useTheme = () => {
  const context = useContext(ThemeProviderContext)

  if (context === undefined)
    throw new Error("useTheme must be used within a ThemeProvider")

  return context
}



=== FILE: packages\ui\src\components\theme\ThemeToggle.tsx ===

import React from "react"
import { Moon, Sun } from "lucide-react"
import { Button } from "../button/Button"
import { useTheme } from "./ThemeProvider"

export function ThemeToggle() {
  const { setTheme, theme } = useTheme()

  return (
    <Button
      variant="ghost"
      size="icon"
      onClick={() => setTheme(theme === "light" ? "dark" : "light")}
      className="relative"
    >
      <Sun className="h-[1.2rem] w-[1.2rem] rotate-0 scale-100 transition-all dark:-rotate-90 dark:scale-0 text-gray-900 dark:text-white" />
      <Moon className="absolute h-[1.2rem] w-[1.2rem] rotate-90 scale-0 transition-all dark:rotate-0 dark:scale-100 text-gray-900 dark:text-white" />
      <span className="sr-only">Toggle theme</span>
    </Button>
  )
}



=== FILE: packages\ui\src\components\typography\Heading.tsx ===

import React from 'react';
import { cn } from '../../utils/cn';

export interface HeadingProps extends React.HTMLAttributes<HTMLHeadingElement> {
  as?: 'h1' | 'h2' | 'h3' | 'h4' | 'h5' | 'h6';
  weight?: 'normal' | 'medium' | 'semibold' | 'bold' | 'extrabold' | 'black';
  children: React.ReactNode;
}

export const Heading = React.forwardRef<HTMLHeadingElement, HeadingProps>(
  ({ as: Component = 'h2', weight = 'bold', className, children, ...props }, ref) => {
    return (
      <Component
        ref={ref}
        className={cn(
          'tracking-tight text-zinc-900 dark:text-white transition-colors duration-200',
          {
            'text-4xl md:text-5xl lg:text-6xl': Component === 'h1',
            'text-3xl md:text-4xl': Component === 'h2',
            'text-2xl md:text-3xl': Component === 'h3',
            'text-xl md:text-2xl': Component === 'h4',
            'text-lg md:text-xl': Component === 'h5',
            'text-base md:text-lg': Component === 'h6',
          },
          {
            'font-normal': weight === 'normal',
            'font-medium': weight === 'medium',
            'font-semibold': weight === 'semibold',
            'font-bold': weight === 'bold',
            'font-extrabold': weight === 'extrabold',
            'font-black': weight === 'black',
          },
          className
        )}
        {...props}
      >
        {children}
      </Component>
    );
  }
);

Heading.displayName = 'Heading';



=== FILE: packages\ui\src\components\typography\HeroText.tsx ===

import React from 'react';
import { cn } from '../../utils/cn';
import { Reveal } from '../feedback/Reveal';

export interface HeroTextProps extends React.HTMLAttributes<HTMLDivElement> {
  /**
   * The main title text
   */
  title: string;
  /**
   * Text to be highlighted with a gradient
   */
  highlight?: string;
  /**
   * Subtitle text below the main title
   */
  subtitle?: string;
  /**
   * Tailwind gradient classes for the highlight
   * @default 'from-blue-400 via-indigo-500 to-purple-600'
   */
  gradient?: string;
  /**
   * Enable entrance animation
   * @default true
   */
  animate?: boolean;
  /**
   * Add a subtle glow effect behind the highlighted text
   * @default true
   */
  glow?: boolean;
}

export const HeroText = ({
  title,
  highlight,
  subtitle,
  gradient = 'from-blue-400 via-indigo-500 to-purple-600',
  animate = true,
  glow = true,
  className,
  ...props
}: HeroTextProps) => {
  const content = (
    <div className={cn("flex flex-col items-center text-center space-y-6", className)} {...props}>
      <h1 className="text-5xl md:text-7xl font-bold tracking-tight text-white leading-tight">
        {title}{' '}
        {highlight && (
          <span className="relative inline-block">
            <span className={cn("bg-clip-text text-transparent bg-gradient-to-r", gradient)}>
              {highlight}
            </span>
            {glow && (
              <span className={cn(
                "absolute inset-0 blur-3xl opacity-40 -z-10 bg-gradient-to-r",
                gradient
              )} aria-hidden="true">
                {highlight}
              </span>
            )}
          </span>
        )}
      </h1>
      {subtitle && (
        <p className="text-lg md:text-xl text-white/50 max-w-2xl mx-auto leading-relaxed">
          {subtitle}
        </p>
      )}
    </div>
  );

  if (animate) {
    return (
      <Reveal direction="up" duration={1}>
        {content}
      </Reveal>
    );
  }

  return content;
};

HeroText.displayName = 'HeroText';



=== FILE: packages\ui\src\components\typography\LetterPullup.tsx ===

import React from 'react';
import { cn } from '../../utils/cn';

export interface LetterPullupProps extends React.HTMLAttributes<HTMLDivElement> {
  /**
   * The text to animate
   */
  text: string;
  /**
   * Delay between each letter animation in seconds
   * @default 0.05
   */
  delay?: number;
}

export const LetterPullup = ({ text, delay = 0.05, className, ...props }: LetterPullupProps) => {
  const letters = text.split('');
  
  return (
    <div className={cn('flex flex-wrap justify-center overflow-hidden py-2', className)} {...props}>
      {letters.map((letter, i) => (
        <span
          key={i}
          className="inline-block animate-pullup opacity-0"
          style={{ 
            animation: `pullup 0.6s cubic-bezier(0.2, 0.8, 0.2, 1) forwards`,
            animationDelay: `${i * delay}s`,
            whiteSpace: letter === ' ' ? 'pre' : 'normal'
          }}
        >
          {letter}
        </span>
      ))}
      <style>{`
        @keyframes pullup {
          from { 
            opacity: 0; 
            transform: translateY(100%); 
          }
          to { 
            opacity: 1; 
            transform: translateY(0); 
          }
        }
      `}</style>
    </div>
  );
};

LetterPullup.displayName = 'LetterPullup';



=== FILE: packages\ui\src\components\typography\ShinyText.tsx ===

import React from 'react';
import { cn } from '../../utils/cn';

export interface ShinyTextProps extends React.HTMLAttributes<HTMLSpanElement> {
  /**
   * The color of the shimmer effect
   * @default 'rgba(255,255,255,0.3)'
   */
  shimmerColor?: string;
  /**
   * Duration of the animation
   * @default '2s'
   */
  duration?: string;
  /**
   * Base text color
   * @default 'currentColor'
   */
  baseColor?: string;
}

export const ShinyText = React.forwardRef<HTMLSpanElement, ShinyTextProps>(
  ({ 
    shimmerColor = 'rgba(255,255,255,0.3)', 
    duration = '2s', 
    baseColor = 'currentColor',
    className, 
    children, 
    ...props 
  }, ref) => {
    return (
      <span
        ref={ref}
        className={cn(
          'inline-block bg-clip-text text-transparent animate-shimmer will-change-[background-position]',
          className
        )}
        style={{
          backgroundImage: `linear-gradient(90deg, ${baseColor} 0%, ${baseColor} 40%, ${shimmerColor} 50%, ${baseColor} 60%, ${baseColor} 100%)`,
          backgroundSize: '200% 100%',
          animationDuration: duration,
          animationIterationCount: 'infinite',
          animationTimingFunction: 'linear',
        }}
        {...props}
      >
        {children}
      </span>
    );
  }
);

ShinyText.displayName = 'ShinyText';



=== FILE: packages\ui\src\components\typography\Text.tsx ===

import React from 'react';
import { cn } from '../../utils/cn';

interface TextProps extends React.HTMLAttributes<HTMLElement> {
  as?: 'p' | 'span' | 'div' | 'label' | 'code';
  variant?: 'default' | 'muted' | 'subtle' | 'lead' | 'error' | 'success' | 'warning' | 'info';
  size?: 'xs' | 'sm' | 'base' | 'lg' | 'xl' | '2xl';
  weight?: 'light' | 'normal' | 'medium' | 'semibold' | 'bold';
  code?: boolean;
  children: React.ReactNode;
}

export const Text = React.forwardRef<HTMLElement, TextProps>(
  ({ 
    as: Component = 'p', 
    variant = 'default', 
    size = 'base', 
    weight = 'normal',
    code = false,
    className, 
    children, 
    ...props 
  }, ref) => {
    return (
      <Component
        ref={ref as React.Ref<any>}
        className={cn(
          'leading-relaxed transition-colors duration-200',
          code && 'font-mono bg-zinc-100 dark:bg-white/[0.03] px-1.5 py-0.5 rounded text-[0.9em]',
          {
            // Variants
            'text-zinc-900 dark:text-white': variant === 'default',
            'text-zinc-500 dark:text-zinc-400': variant === 'muted',
            'text-zinc-400 dark:text-zinc-500': variant === 'subtle',
            'text-lg md:text-xl text-zinc-600 dark:text-zinc-300 font-light': variant === 'lead',
            'text-rose-600 dark:text-rose-400': variant === 'error',
            'text-emerald-600 dark:text-emerald-400': variant === 'success',
            'text-amber-600 dark:text-amber-400': variant === 'warning',
            'text-sky-600 dark:text-sky-400': variant === 'info',
            
            // Sizes
            'text-xs': size === 'xs',
            'text-sm': size === 'sm',
            'text-base': size === 'base',
            'text-lg': size === 'lg',
            'text-xl': size === 'xl',
            'text-2xl': size === '2xl',

            // Weights
            'font-light': weight === 'light',
            'font-normal': weight === 'normal',
            'font-medium': weight === 'medium',
            'font-semibold': weight === 'semibold',
            'font-bold': weight === 'bold',
          },
          className
        )}
        {...props}
      >
        {children}
      </Component>
    );
  }
);

Text.displayName = 'Text';



=== FILE: packages\ui\src\components\typography\TextGradient.tsx ===

import React from 'react';
import { cn } from '../../utils/cn';

export interface TextGradientProps extends React.HTMLAttributes<HTMLSpanElement> {
  /**
   * Starting color (Tailwind class)
   * @default 'from-blue-500'
   */
  from?: string;
  /**
   * Ending color (Tailwind class)
   * @default 'to-purple-500'
   */
  to?: string;
  /**
   * Middle color (Tailwind class)
   */
  via?: string;
  /**
   * Gradient direction
   * @default 'r'
   */
  direction?: 'r' | 'l' | 't' | 'b' | 'tr' | 'tl' | 'br' | 'bl';
  /**
   * Enable animated gradient shift
   * @default false
   */
  animate?: boolean;
}

export const TextGradient = React.forwardRef<HTMLSpanElement, TextGradientProps>(
  ({ 
    from = 'from-blue-500', 
    to = 'to-purple-500', 
    via, 
    direction = 'r', 
    animate = false, 
    className, 
    children, 
    ...props 
  }, ref) => {
    return (
      <span
        ref={ref}
        className={cn(
          'bg-clip-text text-transparent bg-gradient-to-' + direction,
          from,
          to,
          via,
          animate && 'animate-gradient bg-[length:200%_auto]',
          className
        )}
        {...props}
      >
        {children}
      </span>
    );
  }
);

TextGradient.displayName = 'TextGradient';



=== FILE: packages\ui\src\hooks\index.ts ===

export * from './useAsync';
export * from './useChat';
export * from './useChatMessages';
export * from './useChatSearch';
export * from './useClickOutside';
export * from './useClipboard';
export * from './useDebounce';
export * from './useDrag';
export * from './useElementScroll';
export * from './useFlip';
export * from './useFloating';
export * from './useForm';
export * from './useHistory';
export * from './useIdle';
export * from './useInfiniteScroll';
export * from './useIntersection';
export * from './useInView';
export * from './useKanban';
export * from './useKeyboardShortcuts';
export * from './useLifecycle';
export * from './useLocalStorage';
export * from './useMousePosition';
export * from './useOrientation';
export * from './usePrevious';
export * from './useReadReceipts';
export * from './useReducedMotion';
export * from './useResponsive';
export * from './useScroll';
export * from './useScrollDirection';
export * from './useScrollLock';
export * from './useScrollTransform';
export * from './useScrollVelocity';
export * from './useSearch';
export * from './useSessionStorage';
export * from './useSpring';
export * from './useStagger';
export * from './useTextScramble';
export * from './useThrottle';
export * from './useTimer';
export * from './useToast';
export * from './useToggle';
export * from './useTypingIndicator';
export * from './useViewTransition';
export * from './useVirtualList';
export * from './useVoiceRecorder';



=== FILE: packages\ui\src\hooks\useAsync.ts ===

import { useState, useCallback, useEffect } from 'react';

interface AsyncState<T> {
  data: T | null;
  error: Error | null;
  isLoading: boolean;
}

/**
 * A hook for managing asynchronous operations.
 */
export function useAsync<T>(asyncFunction: () => Promise<T>, immediate = true) {
  const [state, setState] = useState<AsyncState<T>>({
    data: null,
    error: null,
    isLoading: false,
  });

  const execute = useCallback(async () => {
    setState({ data: null, error: null, isLoading: true });
    try {
      const response = await asyncFunction();
      setState({ data: response, error: null, isLoading: false });
      return response;
    } catch (error: any) {
      setState({ data: null, error: error as Error, isLoading: false });
      throw error;
    }
  }, [asyncFunction]);

  useEffect(() => {
    if (immediate) {
      execute();
    }
  }, [execute, immediate]);

  return { ...state, execute };
}

/**
 * A hook for fetching data from a URL.
 */
export function useFetch<T>(url: string, options?: RequestInit) {
  const fetcher = useCallback(() => fetch(url, options).then((res) => res.json()), [url, options]);
  return useAsync<T>(fetcher);
}



=== FILE: packages\ui\src\hooks\useBaileysSync.ts ===

import { useEffect } from 'react';
import { chatStore } from './useChatStore';
import { useSocket } from './useSocket';
import type { Message, Conversation, PresenceStatus } from '../components/chat/types';

/**
 * Hook to synchronize Baileys/WhatsApp events from a Socket.io server into the ChatStore.
 */
export function useBaileysSync(socketUrl: string, token?: string) {
  const { on, emit, isConnected } = useSocket({ url: socketUrl, token });

  useEffect(() => {
    // Sync initial state
    on('chats.set', (chats: Conversation[]) => {
      chatStore.setConversations(chats);
    });

    // Upsert chat (new or updated)
    on('chats.upsert', (chats: Conversation[]) => {
      chats.forEach(chat => chatStore.upsertConversation(chat));
    });

    // Update chat properties
    on('chats.update', (updates: Partial<Conversation>[]) => {
      updates.forEach(update => {
        if (update.id) chatStore.upsertConversation(update as any);
      });
    });

    // New messages
    on('messages.upsert', ({ chatId, messages }: { chatId: string, messages: Message[] }) => {
      messages.forEach(msg => chatStore.addMessage(chatId, msg));
    });

    // Message status updates (sent, delivered, read)
    on('messages.update', ({ chatId, messageId, status }: { chatId: string, messageId: string, status: Message['status'] }) => {
      chatStore.updateMessageStatus(chatId, messageId, status);
    });

    // Presence updates (typing, recording, online)
    on('presence.update', ({ userId, status }: { userId: string, status: PresenceStatus }) => {
      chatStore.setUserPresence(userId, status);
    });

    // Group metadata updates
    on('groups.update', (updates: any[]) => {
      updates.forEach(update => {
        chatStore.upsertConversation({ id: update.id, group: update });
      });
    });

  }, [on]);

  return { isConnected, emit };
}

/**
 * Hook for managing "is typing" or "is recording" status with debouncing.
 */
export function useChatPresence(chatId: string, userId: string) {
  const { emit } = useSocket({ url: '' }); // Assumes global socket or passed via context

  const setPresence = (status: PresenceStatus) => {
    emit('presence.send', { chatId, userId, status });
  };

  return { setPresence };
}

/**
 * Hook for handling media uploads with progress.
 */
export function useChatMedia() {
  const uploadMedia = async (file: File, onProgress?: (p: number) => void) => {
    // Implementation for enterprise-grade media upload
    // Could use S3 presigned URLs or direct socket stream
    return { url: '...', thumbnail: '...', blurhash: '...' };
  };

  return { uploadMedia };
}

/**
 * Hook for searching messages across thousands of entries using a Web Worker.
 */
export function useChatSearchWorker(messages: Message[]) {
  // In a real app, this would use a Web Worker to avoid blocking the UI thread
  const search = (query: string) => {
    if (!query) return messages;
    return messages.filter(m => m.content.toLowerCase().includes(query.toLowerCase()));
  };

  return { search };
}



=== FILE: packages\ui\src\hooks\useChat.ts ===

import { useState, useCallback, useRef, useEffect } from 'react';

export interface ChatMessage {
  id: string;
  content: string;
  senderId: string;
  timestamp: Date;
  status: 'sending' | 'sent' | 'error';
  metadata?: Record<string, any>;
}

export interface UseChatOptions {
  /** Initial messages to populate the chat */
  initialMessages?: ChatMessage[];
  /** Callback function to handle sending messages to a backend */
  onSendMessage?: (content: string) => Promise<void>;
  /** Threshold in pixels to trigger auto-scroll */
  scrollThreshold?: number;
}

/**
 * A comprehensive hook for managing chat state, optimistic updates, and scroll behavior.
 * 
 * @example
 * const { messages, sendMessage, scrollRef } = useChat({
 *   onSendMessage: async (content) => await api.post('/messages', { content })
 * });
 */
export function useChat({ 
  initialMessages = [], 
  onSendMessage,
  scrollThreshold = 100 
}: UseChatOptions = {}) {
  const [messages, setMessages] = useState<ChatMessage[]>(initialMessages);
  const [isTyping, setIsTyping] = useState(false);
  const [isLoading, setIsLoading] = useState(false);
  const scrollRef = useRef<HTMLDivElement>(null);
  const isAtBottom = useRef(true);

  const scrollToBottom = useCallback((behavior: ScrollBehavior = 'smooth') => {
    if (scrollRef.current) {
      scrollRef.current.scrollTo({
        top: scrollRef.current.scrollHeight,
        behavior,
      });
    }
  }, []);

  // Handle scroll events to detect if user is at bottom
  const handleScroll = useCallback(() => {
    if (scrollRef.current) {
      const { scrollTop, scrollHeight, clientHeight } = scrollRef.current;
      isAtBottom.current = scrollHeight - scrollTop - clientHeight < scrollThreshold;
    }
  }, [scrollThreshold]);

  // Auto-scroll when new messages arrive if user was already at bottom
  useEffect(() => {
    if (isAtBottom.current) {
      scrollToBottom();
    }
  }, [messages, scrollToBottom]);

  /**
   * Sends a message with optimistic update support.
   */
  const sendMessage = useCallback(async (content: string, senderId: string) => {
    if (!content.trim()) return;

    const tempId = crypto.randomUUID();
    const newMessage: ChatMessage = {
      id: tempId,
      content,
      senderId,
      timestamp: new Date(),
      status: 'sending',
    };

    setMessages((prev) => [...prev, newMessage]);

    try {
      if (onSendMessage) {
        await onSendMessage(content);
      }
      setMessages((prev) =>
        prev.map((msg) => (msg.id === tempId ? { ...msg, status: 'sent' } : msg))
      );
    } catch (error) {
      setMessages((prev) =>
        prev.map((msg) => (msg.id === tempId ? { ...msg, status: 'error' } : msg))
      );
    }
  }, [onSendMessage]);

  /**
   * Clears all messages from the state.
   */
  const clearMessages = useCallback(() => {
    setMessages([]);
  }, []);

  return {
    messages,
    setMessages,
    sendMessage,
    clearMessages,
    isTyping,
    setIsTyping,
    isLoading,
    setIsLoading,
    scrollRef,
    handleScroll,
    scrollToBottom,
  };
}



=== FILE: packages\ui\src\hooks\useChatMessages.ts ===

import { useState, useCallback, useMemo } from 'react';
import type { Message, MessageStatus } from '../components/chat/types';

export function useChatMessages(initialMessages: Message[] = []) {
  const [messages, setMessages] = useState<Message[]>(initialMessages);

  const addMessage = useCallback((message: Message) => {
    setMessages(prev => [...prev, message]);
  }, []);

  const updateMessageStatus = useCallback((id: string, status: MessageStatus) => {
    setMessages(prev => prev.map(m => m.id === id ? { ...m, status } : m));
  }, []);

  const deleteMessage = useCallback((id: string) => {
    setMessages(prev => prev.filter(m => m.id !== id));
  }, []);

  const editMessage = useCallback((id: string, content: string) => {
    setMessages(prev => prev.map(m => m.id === id ? { ...m, content, isEdited: true } : m));
  }, []);

  const addReaction = useCallback((messageId: string, emoji: string, userId: string) => {
    setMessages(prev => prev.map(m => {
      if (m.id !== messageId) return m;
      
      const reactions = { ...(m.reactions || {}) };
      const users = reactions[emoji] || [];
      
      if (users.includes(userId)) {
        reactions[emoji] = users.filter(id => id !== userId);
        if (reactions[emoji].length === 0) delete reactions[emoji];
      } else {
        reactions[emoji] = [...users, userId];
      }
      
      return { ...m, reactions };
    }));
  }, []);

  const clearMessages = useCallback(() => {
    setMessages([]);
  }, []);

  return {
    messages,
    setMessages,
    addMessage,
    updateMessageStatus,
    deleteMessage,
    editMessage,
    addReaction,
    clearMessages
  };
}



=== FILE: packages\ui\src\hooks\useChatSearch.ts ===

import { useState, useMemo } from 'react';
import type { Message } from '../components/chat/types';

export function useChatSearch(messages: Message[]) {
  const [query, setQuery] = useState("");

  const results = useMemo(() => {
    if (!query.trim()) return [];
    const lowerQuery = query.toLowerCase();
    return messages.filter(m => 
      m.content.toLowerCase().includes(lowerQuery)
    );
  }, [messages, query]);

  return {
    query,
    setQuery,
    results
  };
}



=== FILE: packages\ui\src\hooks\useChatStore.ts ===

import { useSyncExternalStore, useMemo, useCallback } from 'react';
import type { Conversation, Message, PresenceStatus } from '../components/chat/types';

interface ChatState {
  conversations: Map<string, Conversation>;
  messages: Map<string, Message[]>; // chatId -> messages
  activeChatId: string | null;
  presence: Map<string, PresenceStatus>; // userId -> status
}

class ChatStore {
  private state: ChatState = {
    conversations: new Map(),
    messages: new Map(),
    activeChatId: null,
    presence: new Map(),
  };

  private listeners = new Set<() => void>();

  getState = () => this.state;

  subscribe = (listener: () => void) => {
    this.listeners.add(listener);
    return () => this.listeners.delete(listener);
  };

  private emitChange(newState: ChatState) {
    this.state = newState;
    for (const listener of this.listeners) {
      listener();
    }
  }

  // Actions
  setConversations(conversations: Conversation[]) {
    this.emitChange({
      ...this.state,
      conversations: new Map(conversations.map(c => [c.id, c]))
    });
  }

  upsertConversation(conversation: Partial<Conversation> & { id: string }) {
    const conversations = new Map(this.state.conversations);
    const existing = conversations.get(conversation.id);
    conversations.set(conversation.id, {
      ...(existing || { unreadCount: 0 }),
      ...conversation,
    } as Conversation);
    
    this.emitChange({
      ...this.state,
      conversations
    });
  }

  setMessages(chatId: string, messages: Message[]) {
    const allMessages = new Map(this.state.messages);
    allMessages.set(chatId, messages);
    this.emitChange({
      ...this.state,
      messages: allMessages
    });
  }

  addMessage(chatId: string, message: Message) {
    const current = this.state.messages.get(chatId) || [];
    if (current.some(m => m.id === message.id)) return;
    
    const allMessages = new Map(this.state.messages);
    allMessages.set(chatId, [...current, message]);
    
    let newState = {
      ...this.state,
      messages: allMessages
    };

    // Update last message in conversation
    const conv = this.state.conversations.get(chatId);
    if (conv) {
      const conversations = new Map(this.state.conversations);
      conversations.set(chatId, {
        ...conv,
        lastMessage: message,
        unreadCount: this.state.activeChatId === chatId ? 0 : (conv.unreadCount || 0) + 1
      });
      newState.conversations = conversations;
    }
    
    this.emitChange(newState);
  }

  updateMessageStatus(chatId: string, messageId: string, status: Message['status']) {
    const current = this.state.messages.get(chatId);
    if (!current) return;

    const index = current.findIndex(m => m.id === messageId);
    if (index !== -1) {
      const updated = [...current];
      const msg = updated[index];
      if (msg) {
        updated[index] = { ...msg, status } as Message;
        const allMessages = new Map(this.state.messages);
        allMessages.set(chatId, updated);
        this.emitChange({
          ...this.state,
          messages: allMessages
        });
      }
    }
  }

  updateMessage(chatId: string, messageId: string, updates: Partial<Message>) {
    const current = this.state.messages.get(chatId);
    if (!current) return;

    const index = current.findIndex(m => m.id === messageId);
    if (index !== -1) {
      const updated = [...current];
      updated[index] = { ...updated[index], ...updates } as Message;
      const allMessages = new Map(this.state.messages);
      allMessages.set(chatId, updated);
      this.emitChange({
        ...this.state,
        messages: allMessages
      });
    }
  }

  addReaction(chatId: string, messageId: string, emoji: string, userId: string) {
    const current = this.state.messages.get(chatId);
    if (!current) return;

    const index = current.findIndex(m => m.id === messageId);
    if (index !== -1) {
      const updated = [...current];
      const msg = { ...updated[index] };
      const reactions = { ...(msg.reactions || {}) };
      const users = [...(reactions[emoji] || [])];
      
      if (!users.includes(userId)) {
        users.push(userId);
        reactions[emoji] = users;
        msg.reactions = reactions;
        updated[index] = msg as Message;
        
        const allMessages = new Map(this.state.messages);
        allMessages.set(chatId, updated);
        this.emitChange({ ...this.state, messages: allMessages });
      }
    }
  }

  removeReaction(chatId: string, messageId: string, emoji: string, userId: string) {
    const current = this.state.messages.get(chatId);
    if (!current) return;

    const index = current.findIndex(m => m.id === messageId);
    if (index !== -1) {
      const updated = [...current];
      const msg = { ...updated[index] };
      const reactions = { ...(msg.reactions || {}) };
      
      if (reactions[emoji]) {
        reactions[emoji] = reactions[emoji].filter(id => id !== userId);
        if (reactions[emoji].length === 0) {
          delete reactions[emoji];
        }
        msg.reactions = reactions;
        updated[index] = msg as Message;
        
        const allMessages = new Map(this.state.messages);
        allMessages.set(chatId, updated);
        this.emitChange({ ...this.state, messages: allMessages });
      }
    }
  }

  deleteMessage(chatId: string, messageId: string) {
    const current = this.state.messages.get(chatId);
    if (!current) return;

    const index = current.findIndex(m => m.id === messageId);
    if (index !== -1) {
      const updated = [...current];
      updated[index] = {
        ...updated[index],
        type: 'revoked',
        content: 'Esta mensagem foi apagada',
        attachments: [],
        reactions: {},
      } as Message;
      
      const allMessages = new Map(this.state.messages);
      allMessages.set(chatId, updated);
      this.emitChange({ ...this.state, messages: allMessages });
    }
  }

  setActiveChat(chatId: string | null) {
    let newState = {
      ...this.state,
      activeChatId: chatId
    };

    if (chatId) {
      const conv = this.state.conversations.get(chatId);
      if (conv && conv.unreadCount > 0) {
        const conversations = new Map(this.state.conversations);
        conversations.set(chatId, { ...conv, unreadCount: 0 });
        newState.conversations = conversations;
      }
    }
    
    this.emitChange(newState);
  }

  setUserPresence(userId: string, status: PresenceStatus) {
    const presence = new Map(this.state.presence);
    presence.set(userId, status);
    this.emitChange({
      ...this.state,
      presence
    });
  }
}

export const chatStore = new ChatStore();

export function useChatStore<T>(selector: (state: ChatState) => T): T {
  const state = useSyncExternalStore(
    chatStore.subscribe,
    chatStore.getState
  );
  
  // We use a stable selector if possible, but since users pass anonymous functions,
  // we should at least ensure we don't loop.
  return useMemo(() => selector(state), [state, selector]);
}

const conversationsSelector = (state: ChatState) => 
  Array.from(state.conversations.values())
    .sort((a, b) => {
      if (a.isPinned && !b.isPinned) return -1;
      if (!a.isPinned && b.isPinned) return 1;
      const timeA = a.lastMessage?.timestamp.getTime() || 0;
      const timeB = b.lastMessage?.timestamp.getTime() || 0;
      return timeB - timeA;
    });

export function useConversations() {
  return useChatStore(conversationsSelector);
}

export function useMessages(chatId: string | null) {
  const selector = useCallback((state: ChatState) => 
    chatId ? state.messages.get(chatId) || [] : [], 
  [chatId]);
  
  return useChatStore(selector);
}

export function useActiveChat() {
  const selector = useCallback((state: ChatState) => 
    state.activeChatId ? state.conversations.get(state.activeChatId) : null,
  []);
  
  return useChatStore(selector);
}

export function useUserPresence(userId: string) {
  const selector = useCallback((state: ChatState) => 
    state.presence.get(userId) || 'unavailable',
  [userId]);
  
  return useChatStore(selector);
}



=== FILE: packages\ui\src\hooks\useClickOutside.ts ===

import { useEffect, useRef } from 'react';

/**
 * Hook that alerts when clicks happen outside of the passed ref.
 */
export function useClickOutside<T extends HTMLElement = HTMLElement>(
  handler: (event: MouseEvent | TouchEvent) => void
): React.RefObject<T> {
  const ref = useRef<T>(null);

  useEffect(() => {
    const listener = (event: MouseEvent | TouchEvent) => {
      const el = ref.current;
      if (!el || el.contains((event?.target as Node) || null)) {
        return;
      }

      handler(event);
    };

    document.addEventListener('mousedown', listener);
    document.addEventListener('touchstart', listener);

    return () => {
      document.removeEventListener('mousedown', listener);
      document.removeEventListener('touchstart', listener);
    };
  }, [handler]);

  return ref;
}



=== FILE: packages\ui\src\hooks\useClipboard.ts ===

import { useState, useCallback } from 'react';

export interface UseClipboardOptions {
  /** Time in ms to reset the 'copied' state */
  timeout?: number;
}

/**
 * A hook to interact with the system clipboard.
 * 
 * @example
 * const { copy, copied } = useClipboard();
 * return <button onClick={() => copy('Hello')}> {copied ? 'Copied!' : 'Copy'} </button>;
 */
export function useClipboard({ timeout = 2000 }: UseClipboardOptions = {}) {
  const [copied, setCopied] = useState(false);
  const [error, setError] = useState<Error | null>(null);

  const copy = useCallback(async (text: string) => {
    if (!navigator?.clipboard) {
      setError(new Error('Clipboard API not supported'));
      return;
    }

    try {
      await navigator.clipboard.writeText(text);
      setCopied(true);
      setTimeout(() => setCopied(false), timeout);
    } catch (err) {
      setError(err instanceof Error ? err : new Error('Failed to copy'));
    }
  }, [timeout]);

  return { copy, copied, error };
}



=== FILE: packages\ui\src\hooks\useDebounce.ts ===

import { useState, useEffect } from 'react';

/**
 * A hook that returns a debounced version of the provided value.
 * Useful for search inputs or any value that changes frequently.
 */
export function useDebounce<T>(value: T, delay: number): T {
  const [debouncedValue, setDebouncedValue] = useState<T>(value);

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);

  return debouncedValue;
}



=== FILE: packages\ui\src\hooks\useDrag.ts ===

import { useState, useEffect, useRef, useCallback } from 'react';

export interface DragState {
  isDragging: boolean;
  offset: { x: number; y: number };
  velocity: { x: number; y: number };
}

/**
 * Hook to provide basic drag gesture support.
 * Zero dependencies, works with mouse and touch.
 */
export function useDrag(onDrag?: (state: DragState) => void) {
  const [isDragging, setIsDragging] = useState(false);
  const [offset, setOffset] = useState({ x: 0, y: 0 });
  
  const startPos = useRef({ x: 0, y: 0 });
  const lastPos = useRef({ x: 0, y: 0 });
  const lastTime = useRef(Date.now());
  const velocity = useRef({ x: 0, y: 0 });

  const handleStart = useCallback((x: number, y: number) => {
    setIsDragging(true);
    startPos.current = { x: x - offset.x, y: y - offset.y };
    lastPos.current = { x, y };
    lastTime.current = Date.now();
  }, [offset]);

  const handleMove = useCallback((x: number, y: number) => {
    if (!isDragging) return;

    const newX = x - startPos.current.x;
    const newY = y - startPos.current.y;
    
    const currentTime = Date.now();
    const deltaTime = currentTime - lastTime.current;
    
    if (deltaTime > 0) {
      velocity.current = {
        x: (x - lastPos.current.x) / deltaTime,
        y: (y - lastPos.current.y) / deltaTime,
      };
    }

    setOffset({ x: newX, y: newY });
    lastPos.current = { x, y };
    lastTime.current = currentTime;

    onDrag?.({ isDragging: true, offset: { x: newX, y: newY }, velocity: velocity.current });
  }, [isDragging, onDrag]);

  const handleEnd = useCallback(() => {
    setIsDragging(false);
    onDrag?.({ isDragging: false, offset, velocity: velocity.current });
  }, [offset, onDrag]);

  useEffect(() => {
    const onMouseMove = (e: MouseEvent) => handleMove(e.clientX, e.clientY);
    const onTouchMove = (e: TouchEvent) => {
      if (e.touches[0]) handleMove(e.touches[0].clientX, e.touches[0].clientY);
    };
    const onMouseUp = () => handleEnd();
    const onTouchEnd = () => handleEnd();

    if (isDragging) {
      window.addEventListener('mousemove', onMouseMove);
      window.addEventListener('mouseup', onMouseUp);
      window.addEventListener('touchmove', onTouchMove);
      window.addEventListener('touchend', onTouchEnd);
    }

    return () => {
      window.removeEventListener('mousemove', onMouseMove);
      window.removeEventListener('mouseup', onMouseUp);
      window.removeEventListener('touchmove', onTouchMove);
      window.removeEventListener('touchend', onTouchEnd);
    };
  }, [isDragging, handleMove, handleEnd]);

  return {
    isDragging,
    offset,
    dragProps: {
      onMouseDown: (e: React.MouseEvent) => handleStart(e.clientX, e.clientY),
      onTouchStart: (e: React.TouchEvent) => {
        if (e.touches[0]) handleStart(e.touches[0].clientX, e.touches[0].clientY);
      },
      style: { cursor: isDragging ? 'grabbing' : 'grab', touchAction: 'none' }
    }
  };
}



=== FILE: packages\ui\src\hooks\useElementScroll.ts ===

import { useState, useEffect, useRef } from 'react';

export interface ElementScrollValues {
  progress: number; // 0 to 1
  scrollY: number;
  isIntersecting: boolean;
}

/**
 * Hook to track the scroll progress of a specific element relative to the viewport.
 * Perfect for parallax effects on specific sections.
 */
export function useElementScroll(ref: React.RefObject<HTMLElement>): ElementScrollValues {
  const [values, setValues] = useState<ElementScrollValues>({
    progress: 0,
    scrollY: 0,
    isIntersecting: false,
  });

  const ticking = useRef(false);

  useEffect(() => {
    const element = ref.current;
    if (!element) return;

    const updateScroll = () => {
      if (!ticking.current) {
        window.requestAnimationFrame(() => {
          const rect = element.getBoundingClientRect();
          const windowHeight = window.innerHeight;
          
          // Calculate how much of the element has passed through the viewport
          // 0 = element top is at window bottom
          // 1 = element bottom is at window top
          const totalDistance = windowHeight + rect.height;
          const currentDistance = windowHeight - rect.top;
          const progress = Math.max(0, Math.min(1, currentDistance / totalDistance));

          setValues({
            progress,
            scrollY: window.scrollY,
            isIntersecting: rect.top < windowHeight && rect.bottom > 0,
          });
          
          ticking.current = false;
        });
        ticking.current = true;
      }
    };

    window.addEventListener('scroll', updateScroll, { passive: true });
    window.addEventListener('resize', updateScroll);
    updateScroll();

    return () => {
      window.removeEventListener('scroll', updateScroll);
      window.removeEventListener('resize', updateScroll);
    };
  }, [ref]);

  return values;
}



=== FILE: packages\ui\src\hooks\useFlip.ts ===

import { useLayoutEffect, useRef } from 'react';

/**
 * Hook to implement the FLIP (First, Last, Invert, Play) technique.
 * Enables smooth layout transitions when elements change position or size.
 */
export function useFlip(id: string, dependencies: any[]) {
  const lastRectRef = useRef<DOMRect | null>(null);

  useLayoutEffect(() => {
    const element = document.querySelector(`[data-flip-id="${id}"]`) as HTMLElement;
    if (!element) return;

    const first = lastRectRef.current;
    const last = element.getBoundingClientRect();

    if (first) {
      const deltaX = first.left - last.left;
      const deltaY = first.top - last.top;
      const deltaW = first.width / last.width;
      const deltaH = first.height / last.height;

      // Only animate if there's a significant change
      if (Math.abs(deltaX) > 0.5 || Math.abs(deltaY) > 0.5 || Math.abs(deltaW - 1) > 0.01 || Math.abs(deltaH - 1) > 0.01) {
        element.animate([
          {
            transformOrigin: 'top left',
            transform: `translate(${deltaX}px, ${deltaY}px) scale(${deltaW}, ${deltaH})`
          },
          {
            transformOrigin: 'top left',
            transform: 'none'
          }
        ], {
          duration: 400,
          easing: 'cubic-bezier(0.2, 0.8, 0.2, 1)',
        });
      }
    }

    lastRectRef.current = last;
  }, dependencies);

  return { 'data-flip-id': id };
}



=== FILE: packages\ui\src\hooks\useFloating.test.ts ===

/// <reference types="node" />
import { renderHook, act } from '@testing-library/react';
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { useFloating } from './useFloating';

describe('useFloating', () => {
  beforeEach(() => {
    // Mock ResizeObserver
    (globalThis as any).ResizeObserver = vi.fn().mockImplementation(function(this: any) {
      this.observe = vi.fn();
      this.unobserve = vi.fn();
      this.disconnect = vi.fn();
    });
  });

  it('should initialize with default position', () => {
    const triggerRef = { current: document.createElement('div') };
    const contentRef = { current: document.createElement('div') };

    const { result } = renderHook(() => useFloating(triggerRef, contentRef));

    expect(result.current.position).toEqual({ top: 0, left: 0 });
    expect(result.current.isPositioned).toBe(false);
  });

  it('should calculate position when open', () => {
    const trigger = document.createElement('div');
    const content = document.createElement('div');

    vi.spyOn(trigger, 'getBoundingClientRect').mockReturnValue({
      top: 100,
      bottom: 150,
      left: 100,
      right: 200,
      width: 100,
      height: 50,
    } as DOMRect);

    vi.spyOn(content, 'getBoundingClientRect').mockReturnValue({
      width: 80,
      height: 40,
    } as DOMRect);

    const triggerRef = { current: trigger };
    const contentRef = { current: content };

    const { result } = renderHook(() => useFloating(triggerRef, contentRef, { isOpen: true }));

    // Default side is 'bottom', align is 'center'
    // top = trigger.bottom + sideOffset(4) = 150 + 4 = 154
    // left = trigger.left + (trigger.width/2) - (content.width/2) = 100 + 50 - 40 = 110
    expect(result.current.position).toEqual({ top: 154, left: 110 });
    expect(result.current.isPositioned).toBe(true);
  });
});



=== FILE: packages\ui\src\hooks\useFloating.ts ===

import type { RefObject } from 'react';
import { useState, useLayoutEffect, useCallback } from 'react';

export type Side = 'top' | 'bottom' | 'left' | 'right';
export type Align = 'start' | 'center' | 'end';

interface UseFloatingOptions {
  side?: Side;
  align?: Align;
  sideOffset?: number;
  alignOffset?: number;
  isOpen?: boolean;
}

interface Position {
  top: number;
  left: number;
}

export function useFloating(
  triggerRef: RefObject<HTMLElement>,
  contentRef: RefObject<HTMLElement>,
  options: UseFloatingOptions = {}
) {
  const {
    side = 'bottom',
    align = 'center',
    sideOffset = 4,
    alignOffset = 0,
    isOpen = false,
  } = options;

  const [position, setPosition] = useState<Position>({ top: 0, left: 0 });
  const [isPositioned, setIsPositioned] = useState(false);

  const updatePosition = useCallback(() => {
    if (!triggerRef.current || !contentRef.current || !isOpen) return;

    const triggerRect = triggerRef.current.getBoundingClientRect();
    const contentRect = contentRef.current.getBoundingClientRect();
    
    let top = 0;
    let left = 0;

    // Calculate base position based on side
    switch (side) {
      case 'top':
        top = triggerRect.top - contentRect.height - sideOffset;
        break;
      case 'bottom':
        top = triggerRect.bottom + sideOffset;
        break;
      case 'left':
        left = triggerRect.left - contentRect.width - sideOffset;
        break;
      case 'right':
        left = triggerRect.right + sideOffset;
        break;
    }

    // Calculate alignment
    if (side === 'top' || side === 'bottom') {
      switch (align) {
        case 'start':
          left = triggerRect.left + alignOffset;
          break;
        case 'center':
          left = triggerRect.left + (triggerRect.width / 2) - (contentRect.width / 2) + alignOffset;
          break;
        case 'end':
          left = triggerRect.right - contentRect.width + alignOffset;
          break;
      }
    } else {
      switch (align) {
        case 'start':
          top = triggerRect.top + alignOffset;
          break;
        case 'center':
          top = triggerRect.top + (triggerRect.height / 2) - (contentRect.height / 2) + alignOffset;
          break;
        case 'end':
          top = triggerRect.bottom - contentRect.height + alignOffset;
          break;
      }
    }

    // Boundary checks (simple viewport containment)
    const padding = 8;
    const viewportWidth = window.innerWidth;
    const viewportHeight = window.innerHeight;

    if (left < padding) left = padding;
    if (left + contentRect.width > viewportWidth - padding) {
      left = viewportWidth - contentRect.width - padding;
    }
    if (top < padding) top = padding;
    if (top + contentRect.height > viewportHeight - padding) {
      top = viewportHeight - contentRect.height - padding;
    }

    setPosition({ top, left });
    setIsPositioned(true);
  }, [triggerRef, contentRef, side, align, sideOffset, alignOffset, isOpen]);

  useLayoutEffect(() => {
    if (!isOpen) {
      if (isPositioned) setIsPositioned(false);
      return;
    }

    updatePosition();

    // Use ResizeObserver for more robust updates
    const resizeObserver = new ResizeObserver(() => updatePosition());
    if (triggerRef.current) resizeObserver.observe(triggerRef.current);
    if (contentRef.current) resizeObserver.observe(contentRef.current);

    window.addEventListener('resize', updatePosition);
    window.addEventListener('scroll', updatePosition, true);

    return () => {
      resizeObserver.disconnect();
      window.removeEventListener('resize', updatePosition);
      window.removeEventListener('scroll', updatePosition, true);
    };
  }, [isOpen, updatePosition, triggerRef, contentRef]);

  return {
    position,
    isPositioned,
    updatePosition,
  };
}



=== FILE: packages\ui\src\hooks\useForm.test.ts ===

import { renderHook, act } from '@testing-library/react';
import { describe, it, expect, vi } from 'vitest';
import { useForm } from './useForm';

describe('useForm', () => {
  const initialValues = {
    username: '',
    email: '',
  };

  it('should initialize with initial values', () => {
    const { result } = renderHook(() => useForm({
      initialValues,
      onSubmit: vi.fn(),
    }));

    expect(result.current.values).toEqual(initialValues);
    expect(result.current.errors).toEqual({});
    expect(result.current.isSubmitting).toBe(false);
  });

  it('should update values on change', () => {
    const { result } = renderHook(() => useForm({
      initialValues,
      onSubmit: vi.fn(),
    }));

    act(() => {
      result.current.handleChange({
        target: { name: 'username', value: 'johndoe', type: 'text' }
      } as any);
    });

    expect(result.current.values.username).toBe('johndoe');
  });

  it('should handle form submission', async () => {
    const onSubmit = vi.fn();
    const { result } = renderHook(() => useForm({
      initialValues: { username: 'test' },
      onSubmit,
    }));

    const mockEvent = {
      preventDefault: vi.fn(),
      currentTarget: {
        checkValidity: () => true,
      },
    } as any;

    await act(async () => {
      await result.current.handleSubmit(mockEvent);
    });

    expect(onSubmit).toHaveBeenCalledWith({ username: 'test' });
    expect(result.current.isSubmitting).toBe(false);
  });

  it('should handle validation errors', async () => {
    const { result } = renderHook(() => useForm({
      initialValues: { username: '' },
      onSubmit: vi.fn(),
    }));

    const mockEvent = {
      preventDefault: vi.fn(),
      currentTarget: {
        checkValidity: () => false,
        elements: [
          {
            name: 'username',
            validity: { valid: false },
            validationMessage: 'Username is required',
          },
        ],
      },
    } as any;

    await act(async () => {
      await result.current.handleSubmit(mockEvent);
    });

    expect(result.current.errors.username).toBe('Username is required');
  });
});



=== FILE: packages\ui\src\hooks\useForm.ts ===

import type { FormEvent } from 'react';
import { useState, useCallback } from 'react';

interface UseFormOptions<T> {
  initialValues: T;
  onSubmit: (values: T) => void | Promise<void>;
}

export function useForm<T extends Record<string, unknown>>({
  initialValues,
  onSubmit,
}: UseFormOptions<T>) {
  const [values, setValues] = useState<T>(initialValues);
  const [errors, setErrors] = useState<Partial<Record<keyof T, string>>>({});
  const [isSubmitting, setIsSubmitting] = useState(false);

  const handleChange = useCallback((
    e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>
  ) => {
    const { name, value, type } = e.target;
    const val = type === 'checkbox' ? (e.target as HTMLInputElement).checked : value;

    setValues((prev) => ({ ...prev, [name]: val }));
    
    // Clear error when user starts typing
    if (errors[name as keyof T]) {
      setErrors((prev) => ({ ...prev, [name]: '' }));
    }
  }, [errors]);

  const handleSubmit = useCallback(async (e: FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    const form = e.currentTarget;
    
    if (!form.checkValidity()) {
      const newErrors: Partial<Record<keyof T, string>> = {};
      Array.from(form.elements).forEach((element) => {
        const input = element as HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement;
        if (input.name && !input.validity.valid) {
          newErrors[input.name as keyof T] = input.validationMessage;
        }
      });
      setErrors(newErrors);
      return;
    }

    setIsSubmitting(true);
    try {
      await onSubmit(values);
    } finally {
      setIsSubmitting(false);
    }
  }, [values, onSubmit]);

  const register = useCallback((name: keyof T) => ({
    name: name as string,
    value: values[name] as string | number | readonly string[] | undefined,
    onChange: handleChange,
    error: errors[name],
  }), [values, errors, handleChange]);

  return {
    values,
    errors,
    isSubmitting,
    handleChange,
    handleSubmit,
    register,
    setValues,
    setErrors,
  };
}



=== FILE: packages\ui\src\hooks\useHistory.ts ===

import { useState, useCallback, useMemo } from 'react';

export interface HistoryState<T> {
  past: T[];
  present: T;
  future: T[];
}

/**
 * A generic hook for managing state with Undo and Redo capabilities.
 * 
 * @example
 * const { state, set, undo, redo, canUndo, canRedo } = useHistory(initialData);
 */
export function useHistory<T>(initialState: T) {
  const [history, setHistory] = useState<HistoryState<T>>({
    past: [],
    present: initialState,
    future: [],
  });

  const canUndo = history.past.length > 0;
  const canRedo = history.future.length > 0;

  const undo = useCallback(() => {
    if (!canUndo) return;

    setHistory((prev) => {
      const previous = prev.past[prev.past.length - 1];
      if (previous === undefined) return prev;
      
      const newPast = prev.past.slice(0, prev.past.length - 1);

      return {
        past: newPast,
        present: previous,
        future: [prev.present, ...prev.future],
      };
    });
  }, [canUndo]);

  const redo = useCallback(() => {
    if (!canRedo) return;

    setHistory((prev) => {
      const next = prev.future[0];
      if (next === undefined) return prev;

      const newFuture = prev.future.slice(1);

      return {
        past: [...prev.past, prev.present],
        present: next,
        future: newFuture,
      };
    });
  }, [canRedo]);

  const set = useCallback((newPresent: T | ((prev: T) => T)) => {
    setHistory((prev) => {
      const resolved = typeof newPresent === 'function' 
        ? (newPresent as (p: T) => T)(prev.present) 
        : newPresent;

      if (prev.present === resolved) return prev;

      return {
        past: [...prev.past, prev.present],
        present: resolved,
        future: [],
      };
    });
  }, []);

  const clear = useCallback(() => {
    setHistory({
      past: [],
      present: initialState,
      future: [],
    });
  }, [initialState]);

  return {
    state: history.present,
    set,
    undo,
    redo,
    clear,
    canUndo,
    canRedo,
    history,
  };
}



=== FILE: packages\ui\src\hooks\useIdle.ts ===

import { useState, useEffect, useRef } from 'react';

/**
 * Hook to detect user inactivity.
 * Useful for dimming UI or triggering ambient animations.
 */
export function useIdle(timeout: number = 3000): boolean {
  const [isIdle, setIsIdle] = useState(false);
  const timeoutId = useRef<NodeJS.Timeout>();

  useEffect(() => {
    const handleActivity = () => {
      setIsIdle(false);
      if (timeoutId.current) clearTimeout(timeoutId.current);
      
      timeoutId.current = setTimeout(() => {
        setIsIdle(true);
      }, timeout);
    };

    const events = ['mousemove', 'mousedown', 'keydown', 'touchstart', 'scroll'];
    
    events.forEach(event => {
      window.addEventListener(event, handleActivity);
    });

    handleActivity(); // Initialize

    return () => {
      events.forEach(event => {
        window.removeEventListener(event, handleActivity);
      });
      if (timeoutId.current) clearTimeout(timeoutId.current);
    };
  }, [timeout]);

  return isIdle;
}



=== FILE: packages\ui\src\hooks\useInfiniteScroll.ts ===

import { useEffect, useRef, useCallback } from 'react';

export interface UseInfiniteScrollOptions {
  /** Callback function to load more data */
  onLoadMore: () => void;
  /** Whether more data is currently being loaded */
  isLoading: boolean;
  /** Whether there is more data to load */
  hasMore: boolean;
  /** Distance from the bottom in pixels to trigger loading */
  threshold?: number;
  /** Root element for the IntersectionObserver (defaults to viewport) */
  root?: Element | null;
}

/**
 * A hook to implement infinite scrolling using the Intersection Observer API.
 * 
 * @example
 * const loaderRef = useInfiniteScroll({ onLoadMore: fetchNextPage, hasMore, isLoading });
 * return <div ref={loaderRef}>{isLoading && <Spinner />}</div>;
 */
export function useInfiniteScroll({
  onLoadMore,
  isLoading,
  hasMore,
  threshold = 100,
  root = null,
}: UseInfiniteScrollOptions) {
  const observerRef = useRef<IntersectionObserver | null>(null);
  const triggerRef = useRef<HTMLDivElement>(null);

  const handleObserver = useCallback(
    (entries: IntersectionObserverEntry[]) => {
      const target = entries[0];
      if (target && target.isIntersecting && hasMore && !isLoading) {
        onLoadMore();
      }
    },
    [hasMore, isLoading, onLoadMore]
  );

  useEffect(() => {
    const element = triggerRef.current;
    if (!element) return;

    observerRef.current = new IntersectionObserver(handleObserver, {
      root,
      rootMargin: `0px 0px ${threshold}px 0px`,
      threshold: 0.1,
    });

    observerRef.current.observe(element);

    return () => {
      if (observerRef.current) {
        observerRef.current.disconnect();
      }
    };
  }, [handleObserver, root, threshold]);

  return triggerRef;
}



=== FILE: packages\ui\src\hooks\useIntersection.ts ===

import type { RefObject } from 'react';
import { useState, useEffect, useRef } from 'react';

interface UseIntersectionOptions extends IntersectionObserverInit {
  freezeOnceVisible?: boolean;
}

export function useIntersection(
  elementRef: RefObject<Element>,
  {
    threshold = 0,
    root = null,
    rootMargin = '0%',
    freezeOnceVisible = false,
  }: UseIntersectionOptions = {}
): IntersectionObserverEntry | undefined {
  const [entry, setEntry] = useState<IntersectionObserverEntry>();

  const frozen = entry?.isIntersecting && freezeOnceVisible;

  const updateEntry = ([entry]: IntersectionObserverEntry[]): void => {
    setEntry(entry);
  };

  useEffect(() => {
    const node = elementRef?.current;
    const hasIOSupport = !!window.IntersectionObserver;

    if (!hasIOSupport || frozen || !node) return;

    const observerParams = { threshold, root, rootMargin };
    const observer = new IntersectionObserver(updateEntry, observerParams);

    observer.observe(node);

    return () => observer.disconnect();
  }, [elementRef, threshold, root, rootMargin, frozen]);

  return entry;
}



=== FILE: packages\ui\src\hooks\useInView.ts ===

import { useEffect, useState, useRef } from 'react';

export interface UseInViewOptions {
  threshold?: number | number[];
  rootMargin?: string;
  root?: Element | null;
  enabled?: boolean;
}

export function useInView(options: UseInViewOptions = { threshold: 0.1, rootMargin: '0px', enabled: true }) {
  const ref = useRef<HTMLDivElement>(null);
  const [isInView, setIsInView] = useState(false);
  const [hasAnimated, setHasAnimated] = useState(false);
  const { enabled = true } = options;

  useEffect(() => {
    if (!enabled) return;
    
    const element = ref.current;
    if (!element) return;

    const observer = new IntersectionObserver(([entry]) => {
      if (entry && entry.isIntersecting) {
        setIsInView(true);
        setHasAnimated(true);
      } else {
        setIsInView(false);
      }
    }, options);

    observer.observe(element);

    return () => {
      observer.disconnect();
    };
  }, [options.threshold, options.rootMargin, options.root, enabled]);

  return { ref, isInView, hasAnimated };
}



=== FILE: packages\ui\src\hooks\useKanban.ts ===

import { useState, useCallback } from 'react';

export interface KanbanBoardTask {
  id: string;
  columnId: string;
  title: string;
  description?: string;
  priority?: 'low' | 'medium' | 'high';
  assignee?: {
    name: string;
    avatar?: string;
  };
  tags?: string[];
  [key: string]: any;
}

export interface KanbanBoardColumn {
  id: string;
  title: string;
  taskIds: string[];
}

export interface KanbanBoardState {
  columns: Record<string, KanbanBoardColumn>;
  columnOrder: string[];
  tasks: Record<string, KanbanBoardTask>;
}

/**
 * A specialized hook for managing Kanban board logic, including task movement and reordering.
 * 
 * @example
 * const { board, moveTask } = useKanban(initialData);
 */
export function useKanban(initialBoard: KanbanBoardState) {
  const [board, setBoard] = useState<KanbanBoardState>(initialBoard);

  /**
   * Moves a task within the same column or to a different column.
   */
  const moveTask = useCallback((
    taskId: string,
    sourceColumnId: string,
    destinationColumnId: string,
    destinationIndex: number
  ) => {
    setBoard((prev) => {
      const sourceColumn = prev.columns[sourceColumnId];
      const destColumn = prev.columns[destinationColumnId];
      const task = prev.tasks[taskId];
      
      if (!sourceColumn || !destColumn || !task) return prev;

      const newTaskIds = Array.from(sourceColumn.taskIds);
      newTaskIds.splice(newTaskIds.indexOf(taskId), 1);

      const newSourceColumn: KanbanBoardColumn = {
        ...sourceColumn,
        taskIds: newTaskIds,
      };

      const newDestTaskIds = sourceColumnId === destinationColumnId 
        ? newTaskIds 
        : Array.from(destColumn.taskIds);
      
      newDestTaskIds.splice(destinationIndex, 0, taskId);

      const newDestColumn: KanbanBoardColumn = {
        ...destColumn,
        taskIds: newDestTaskIds,
      };

      return {
        ...prev,
        columns: {
          ...prev.columns,
          [sourceColumnId]: newSourceColumn,
          [destinationColumnId]: newDestColumn,
        },
        tasks: {
          ...prev.tasks,
          [taskId]: {
            ...task,
            columnId: destinationColumnId,
          },
        },
      };
    });
  }, []);

  /**
   * Reorders columns in the board.
   */
  const moveColumn = useCallback((columnId: string, destinationIndex: number) => {
    setBoard((prev) => {
      const newColumnOrder = Array.from(prev.columnOrder);
      newColumnOrder.splice(newColumnOrder.indexOf(columnId), 1);
      newColumnOrder.splice(destinationIndex, 0, columnId);

      return {
        ...prev,
        columnOrder: newColumnOrder,
      };
    });
  }, []);

  /**
   * Adds a new task to a specific column.
   */
  const addTask = useCallback((columnId: string, task: KanbanBoardTask) => {
    setBoard((prev) => {
      const column = prev.columns[columnId];
      if (!column) return prev;

      const newColumn: KanbanBoardColumn = {
        ...column,
        taskIds: [...column.taskIds, task.id],
      };

      return {
        ...prev,
        tasks: {
          ...prev.tasks,
          [task.id]: task,
        },
        columns: {
          ...prev.columns,
          [columnId]: newColumn,
        },
      };
    });
  }, []);

  /**
   * Removes a task from the board.
   */
  const removeTask = useCallback((taskId: string) => {
    setBoard((prev) => {
      const task = prev.tasks[taskId];
      if (!task) return prev;

      const column = prev.columns[task.columnId];
      if (!column) return prev;

      const newTasks = { ...prev.tasks };
      delete newTasks[taskId];

      const newColumn: KanbanBoardColumn = {
        ...column,
        taskIds: column.taskIds.filter((id) => id !== taskId),
      };

      return {
        ...prev,
        tasks: newTasks,
        columns: {
          ...prev.columns,
          [task.columnId]: newColumn,
        },
      };
    });
  }, []);

  return {
    board,
    setBoard,
    moveTask,
    moveColumn,
    addTask,
    removeTask,
  };
}



=== FILE: packages\ui\src\hooks\useKeyboardShortcuts.ts ===

import { useEffect, useRef } from 'react';

export type ShortcutHandler = (event: KeyboardEvent) => void;

export interface ShortcutMap {
  /** 
   * Key combination string (e.g., 'mod+s', 'shift+enter', 'escape').
   * 'mod' maps to Command on Mac and Ctrl on Windows/Linux.
   */
  [shortcut: string]: ShortcutHandler;
}

/**
 * A hook to manage global keyboard shortcuts with automatic cleanup.
 * 
 * @example
 * useKeyboardShortcuts({
 *   'mod+s': (e) => { e.preventDefault(); save(); },
 *   'escape': () => close(),
 * });
 */
export function useKeyboardShortcuts(shortcuts: ShortcutMap) {
  const shortcutsRef = useRef(shortcuts);
  shortcutsRef.current = shortcuts;

  useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => {
      const keys = [];
      const isMac = typeof window !== 'undefined' && /Mac|iPod|iPhone|iPad/.test(navigator.platform);
      
      if (event.ctrlKey || event.metaKey) {
        // Handle 'mod' abstraction
        keys.push('mod');
      }
      
      if (event.shiftKey) keys.push('shift');
      if (event.altKey) keys.push('alt');
      
      const key = event.key.toLowerCase();
      if (!['control', 'meta', 'shift', 'alt'].includes(key)) {
        keys.push(key);
      }

      const shortcutStr = keys.join('+');
      
      // Try exact match first, then fallback to single key
      const handler = shortcutsRef.current[shortcutStr] || shortcutsRef.current[key];

      if (handler) {
        handler(event);
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, []);
}



=== FILE: packages\ui\src\hooks\useLifecycle.ts ===

import { useEffect, useRef } from 'react';

/**
 * A hook that runs an effect only once when the component mounts.
 */
export function useOnMount(effect: () => void) {
  const initialized = useRef(false);

  useEffect(() => {
    if (!initialized.current) {
      initialized.current = true;
      effect();
    }
  }, []);
}

/**
 * A hook that runs an effect only once when the component unmounts.
 */
export function useOnUnmount(effect: () => void) {
  useEffect(() => {
    return () => {
      effect();
    };
  }, []);
}



=== FILE: packages\ui\src\hooks\useLocalStorage.ts ===

import { useState, useCallback, useEffect } from 'react';

/**
 * A hook to manage state synchronized with localStorage.
 * 
 * @example
 * const [theme, setTheme] = useLocalStorage('theme', 'dark');
 */
export function useLocalStorage<T>(key: string, initialValue: T) {
  // State to store our value
  // Pass initial state function to useState so logic is only executed once
  const [storedValue, setStoredValue] = useState<T>(() => {
    if (typeof window === 'undefined') {
      return initialValue;
    }
    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      console.warn(`Error reading localStorage key "${key}":`, error);
      return initialValue;
    }
  });

  // Return a wrapped version of useState's setter function that
  // persists the new value to localStorage.
  const setValue = useCallback((value: T | ((val: T) => T)) => {
    try {
      // Allow value to be a function so we have same API as useState
      const valueToStore = value instanceof Function ? value(storedValue) : value;
      setStoredValue(valueToStore);
      if (typeof window !== 'undefined') {
        window.localStorage.setItem(key, JSON.stringify(valueToStore));
      }
    } catch (error) {
      console.warn(`Error setting localStorage key "${key}":`, error);
    }
  }, [key, storedValue]);

  return [storedValue, setValue] as const;
}



=== FILE: packages\ui\src\hooks\useMousePosition.ts ===

import { useState, useEffect, useRef } from 'react';

export interface MousePosition {
  x: number;
  y: number;
  elementX: number;
  elementY: number;
  percentageX: number;
  percentageY: number;
}

/**
 * Hook to track mouse position relative to the window or a specific element.
 * Uses requestAnimationFrame for 120fps performance.
 */
export function useMousePosition(ref?: React.RefObject<HTMLElement>): MousePosition {
  const [position, setPosition] = useState<MousePosition>({
    x: 0,
    y: 0,
    elementX: 0,
    elementY: 0,
    percentageX: 0,
    percentageY: 0,
  });

  const requestRef = useRef<number>();
  const latestMousePos = useRef<{ x: number; y: number }>({ x: 0, y: 0 });

  useEffect(() => {
    const handleMouseMove = (event: MouseEvent) => {
      latestMousePos.current = { x: event.clientX, y: event.clientY };
      
      if (!requestRef.current) {
        requestRef.current = requestAnimationFrame(updatePosition);
      }
    };

    const updatePosition = () => {
      const { x, y } = latestMousePos.current;
      let elementX = 0;
      let elementY = 0;
      let percentageX = 0;
      let percentageY = 0;

      if (ref?.current) {
        const rect = ref.current.getBoundingClientRect();
        elementX = x - rect.left;
        elementY = y - rect.top;
        percentageX = Math.max(0, Math.min(100, (elementX / rect.width) * 100));
        percentageY = Math.max(0, Math.min(100, (elementY / rect.height) * 100));
      }

      setPosition({
        x,
        y,
        elementX,
        elementY,
        percentageX,
        percentageY,
      });

      requestRef.current = undefined;
    };

    window.addEventListener('mousemove', handleMouseMove);

    return () => {
      window.removeEventListener('mousemove', handleMouseMove);
      if (requestRef.current) cancelAnimationFrame(requestRef.current);
    };
  }, [ref]);

  return position;
}



=== FILE: packages\ui\src\hooks\useOrientation.ts ===

import { useState, useEffect } from 'react';

export interface Orientation {
  alpha: number | null; // rotation around z-axis
  beta: number | null;  // rotation around x-axis
  gamma: number | null; // rotation around y-axis
  absolute: boolean;
}

/**
 * Hook to track device orientation.
 * Useful for mobile parallax and tilt effects.
 */
export function useOrientation(): Orientation {
  const [orientation, setOrientation] = useState<Orientation>({
    alpha: null,
    beta: null,
    gamma: null,
    absolute: false,
  });

  useEffect(() => {
    const handleOrientation = (event: DeviceOrientationEvent) => {
      setOrientation({
        alpha: event.alpha,
        beta: event.beta,
        gamma: event.gamma,
        absolute: event.absolute,
      });
    };

    // Check if DeviceOrientationEvent is supported and if permission is needed (iOS)
    if (typeof window !== 'undefined' && 'DeviceOrientationEvent' in window) {
      window.addEventListener('deviceorientation', handleOrientation);
    }

    return () => {
      window.removeEventListener('deviceorientation', handleOrientation);
    };
  }, []);

  return orientation;
}



=== FILE: packages\ui\src\hooks\usePrevious.ts ===

import { useRef, useEffect } from 'react';

/**
 * A hook that stores the previous value of a variable.
 */
export function usePrevious<T>(value: T): T | undefined {
  const ref = useRef<T>();

  useEffect(() => {
    ref.current = value;
  }, [value]);

  return ref.current;
}



=== FILE: packages\ui\src\hooks\useReadReceipts.ts ===

import { useEffect, useRef, useCallback } from 'react';

export function useReadReceipts(onRead: (messageId: string) => void) {
  const observer = useRef<IntersectionObserver | null>(null);

  const registerMessage = useCallback((el: HTMLElement | null, messageId: string, isMe: boolean) => {
    if (!el || isMe || !observer.current) return;
    
    el.dataset.messageId = messageId;
    observer.current.observe(el);
  }, []);

  useEffect(() => {
    observer.current = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          const messageId = (entry.target as HTMLElement).dataset.messageId;
          if (messageId) {
            onRead(messageId);
            observer.current?.unobserve(entry.target);
          }
        }
      });
    }, { threshold: 0.5 });

    return () => {
      observer.current?.disconnect();
    };
  }, [onRead]);

  return { registerMessage };
}



=== FILE: packages\ui\src\hooks\useReducedMotion.ts ===

import { useState, useEffect } from 'react';

/**
 * Hook to detect if the user has requested reduced motion via system settings.
 * Useful for disabling heavy animations for accessibility.
 */
export function useReducedMotion(): boolean {
  const [reducedMotion, setReducedMotion] = useState(false);

  useEffect(() => {
    const mediaQuery = window.matchMedia('(prefers-reduced-motion: reduce)');
    setReducedMotion(mediaQuery.matches);

    const handler = (event: MediaQueryListEvent) => {
      setReducedMotion(event.matches);
    };

    mediaQuery.addEventListener('change', handler);
    return () => mediaQuery.removeEventListener('change', handler);
  }, []);

  return reducedMotion;
}



=== FILE: packages\ui\src\hooks\useResponsive.ts ===

import type { RefObject } from 'react';
import { useState, useEffect, useLayoutEffect } from 'react';

export type Breakpoint = 'sm' | 'md' | 'lg' | 'xl' | '2xl';

const breakpoints: Record<Breakpoint, number> = {
  sm: 640,
  md: 768,
  lg: 1024,
  xl: 1280,
  '2xl': 1536,
};

export function useMediaQuery(query: string): boolean {
  const [matches, setMatches] = useState(false);

  useEffect(() => {
    const media = window.matchMedia(query);
    setMatches(media.matches);
    
    const listener = () => setMatches(media.matches);
    media.addEventListener('change', listener);
    return () => media.removeEventListener('change', listener);
  }, [query]);

  return matches;
}

export function useBreakpoint(breakpoint: Breakpoint): boolean {
  return useMediaQuery(`(min-width: ${breakpoints[breakpoint]}px)`);
}

interface ContainerSize {
  width: number;
  height: number;
}

export function useContainerQuery(ref: RefObject<HTMLElement>): ContainerSize {
  const [size, setSize] = useState<ContainerSize>({ width: 0, height: 0 });

  useLayoutEffect(() => {
    if (!ref.current) return;

    const observer = new ResizeObserver((entries) => {
      for (const entry of entries) {
        setSize({
          width: entry.contentRect.width,
          height: entry.contentRect.height,
        });
      }
    });

    observer.observe(ref.current);
    return () => observer.disconnect();
  }, [ref]);

  return size;
}



=== FILE: packages\ui\src\hooks\useScroll.ts ===

import { useState, useEffect, useCallback, useRef } from 'react';

export interface ScrollValues {
  scrollX: number;
  scrollY: number;
  scrollProgressX: number;
  scrollProgressY: number;
}

/**
 * Optimized scroll hook using requestAnimationFrame for 120fps performance.
 */
export function useScroll(): ScrollValues {
  const [values, setValues] = useState<ScrollValues>({
    scrollX: 0,
    scrollY: 0,
    scrollProgressX: 0,
    scrollProgressY: 0,
  });

  const ticking = useRef(false);

  const handleScroll = useCallback(() => {
    if (!ticking.current) {
      window.requestAnimationFrame(() => {
        const x = window.scrollX;
        const y = window.scrollY;
        
        const width = document.documentElement.scrollWidth - document.documentElement.clientWidth;
        const height = document.documentElement.scrollHeight - document.documentElement.clientHeight;
        
        setValues({
          scrollX: x,
          scrollY: y,
          scrollProgressX: width > 0 ? x / width : 0,
          scrollProgressY: height > 0 ? y / height : 0,
        });
        
        ticking.current = false;
      });
      
      ticking.current = true;
    }
  }, []);

  useEffect(() => {
    window.addEventListener('scroll', handleScroll, { passive: true });
    handleScroll(); // Initial call
    
    return () => window.removeEventListener('scroll', handleScroll);
  }, [handleScroll]);

  return values;
}



=== FILE: packages\ui\src\hooks\useScrollDirection.ts ===

import { useState, useEffect, useRef } from 'react';

export type ScrollDirection = 'up' | 'down' | null;

/**
 * Hook to detect scroll direction with a threshold to prevent jitter.
 */
export function useScrollDirection(threshold: number = 10): ScrollDirection {
  const [scrollDirection, setScrollDirection] = useState<ScrollDirection>(null);
  const lastScrollY = useRef(0);

  useEffect(() => {
    const updateScrollDirection = () => {
      const scrollY = window.scrollY;

      if (Math.abs(scrollY - lastScrollY.current) < threshold) {
        return;
      }

      const direction = scrollY > lastScrollY.current ? 'down' : 'up';
      
      if (direction !== scrollDirection && (scrollY > 0 || direction === 'down')) {
        setScrollDirection(direction);
      }
      
      lastScrollY.current = scrollY > 0 ? scrollY : 0;
    };

    const onScroll = () => {
      window.requestAnimationFrame(updateScrollDirection);
    };

    window.addEventListener('scroll', onScroll);

    return () => window.removeEventListener('scroll', onScroll);
  }, [scrollDirection, threshold]);

  return scrollDirection;
}



=== FILE: packages\ui\src\hooks\useScrollLock.ts ===

import { useLayoutEffect } from 'react';

/**
 * Hook to lock body scroll.
 * Useful for modals, drawers, and overlays.
 * Handles scrollbar width to prevent layout shift.
 */
export function useScrollLock(lock: boolean = true) {
  useLayoutEffect(() => {
    if (!lock) return;

    // Get original body overflow and padding
    const originalStyle = window.getComputedStyle(document.body).overflow;
    const originalPaddingRight = window.getComputedStyle(document.body).paddingRight;

    // Calculate scrollbar width
    const scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;

    // Apply lock
    document.body.style.overflow = 'hidden';
    if (scrollbarWidth > 0) {
      document.body.style.paddingRight = `${parseFloat(originalPaddingRight) + scrollbarWidth}px`;
    }

    return () => {
      document.body.style.overflow = originalStyle;
      document.body.style.paddingRight = originalPaddingRight;
    };
  }, [lock]);
}



=== FILE: packages\ui\src\hooks\useScrollTransform.ts ===

/**
 * Utility to map a value from one range to another.
 */
function interpolate(
  value: number,
  inputRange: [number, number],
  outputRange: [number, number]
): number {
  const [inputMin, inputMax] = inputRange;
  const [outputMin, outputMax] = outputRange;
  
  const progress = (value - inputMin) / (inputMax - inputMin);
  const clampedProgress = Math.max(0, Math.min(1, progress));
  
  return outputMin + clampedProgress * (outputMax - outputMin);
}

/**
 * Hook to map a value (usually scroll progress) to a specific output range.
 * Useful for parallax translations, rotations, and opacity changes.
 */
export function useScrollTransform(
  value: number,
  inputRange: [number, number],
  outputRange: [number, number]
): number {
  return interpolate(value, inputRange, outputRange);
}



=== FILE: packages\ui\src\hooks\useScrollVelocity.ts ===

import { useState, useEffect, useRef } from 'react';

/**
 * Hook to track scroll velocity.
 * Useful for intensity-based animations (e.g., faster scroll = more blur).
 */
export function useScrollVelocity(): number {
  const [velocity, setVelocity] = useState(0);
  const lastScrollY = useRef(0);
  const lastTime = useRef(Date.now());
  const requestRef = useRef<number>();

  useEffect(() => {
    const handleScroll = () => {
      const currentScrollY = window.scrollY;
      const currentTime = Date.now();
      const deltaTime = currentTime - lastTime.current;

      if (deltaTime > 0) {
        const distance = currentScrollY - lastScrollY.current;
        const currentVelocity = distance / deltaTime;
        setVelocity(currentVelocity);
      }

      lastScrollY.current = currentScrollY;
      lastTime.current = currentTime;

      // Decay velocity if no scroll event occurs
      if (requestRef.current) cancelAnimationFrame(requestRef.current);
      requestRef.current = requestAnimationFrame(decayVelocity);
    };

    const decayVelocity = () => {
      setVelocity(prev => {
        if (Math.abs(prev) < 0.01) return 0;
        return prev * 0.9; // Decay factor
      });
      requestRef.current = requestAnimationFrame(decayVelocity);
    };

    window.addEventListener('scroll', handleScroll, { passive: true });

    return () => {
      window.removeEventListener('scroll', handleScroll);
      if (requestRef.current) cancelAnimationFrame(requestRef.current);
    };
  }, []);

  return velocity;
}



=== FILE: packages\ui\src\hooks\useSearch.ts ===

import { useMemo } from 'react';

/**
 * A lightweight fuzzy search utility.
 */
function fuzzyMatch(query: string, text: string): boolean {
  const q = query.toLowerCase().replace(/\s/g, '');
  const t = text.toLowerCase();
  let queryIdx = 0;
  for (let textIdx = 0; textIdx < t.length && queryIdx < q.length; textIdx++) {
    if (t[textIdx] === q[queryIdx]) queryIdx++;
  }
  return queryIdx === q.length;
}

/**
 * A hook for filtering data using a lightweight fuzzy search algorithm.
 * 
 * @example
 * const filtered = useSearch(users, query, ['name', 'email']);
 */
export function useSearch<T>(
  data: T[], 
  query: string, 
  keys: (keyof T)[]
): T[] {
  return useMemo(() => {
    if (!query.trim()) return data;

    return data.filter((item) =>
      keys.some((key) => {
        const value = item[key];
        if (value === null || value === undefined) return false;
        return fuzzyMatch(query, String(value));
      })
    );
  }, [data, query, keys]);
}



=== FILE: packages\ui\src\hooks\useSessionStorage.ts ===

import { useState, useEffect, useCallback } from 'react';

/**
 * A hook for managing state in sessionStorage with automatic synchronization.
 */
export function useSessionStorage<T>(key: string, initialValue: T) {
  const readValue = useCallback((): T => {
    if (typeof window === 'undefined') return initialValue;

    try {
      const item = window.sessionStorage.getItem(key);
      return item ? (JSON.parse(item) as T) : initialValue;
    } catch (error) {
      console.warn(`Error reading sessionStorage key "${key}":`, error);
      return initialValue;
    }
  }, [initialValue, key]);

  const [storedValue, setStoredValue] = useState<T>(readValue);

  const setValue = useCallback((value: T | ((val: T) => T)) => {
    try {
      const valueToStore = value instanceof Function ? value(storedValue) : value;
      setStoredValue(valueToStore);
      if (typeof window !== 'undefined') {
        window.sessionStorage.setItem(key, JSON.stringify(valueToStore));
      }
    } catch (error) {
      console.warn(`Error setting sessionStorage key "${key}":`, error);
    }
  }, [key, storedValue]);

  useEffect(() => {
    setStoredValue(readValue());
  }, [readValue]);

  return [storedValue, setValue] as const;
}



=== FILE: packages\ui\src\hooks\useSocket.ts ===

import { useEffect, useRef, useCallback } from 'react';
import { io, Socket } from 'socket.io-client';

interface UseSocketOptions {
  url: string;
  token?: string;
  rooms?: string[];
  onConnect?: () => void;
  onDisconnect?: () => void;
  onError?: (error: any) => void;
}

/**
 * Advanced Socket.io hook with Redis-ready event handling and automatic room management.
 */
export function useSocket({ url, token, rooms = [], onConnect, onDisconnect, onError }: UseSocketOptions) {
  const socketRef = useRef<Socket | null>(null);

  useEffect(() => {
    const socket = io(url, {
      auth: { token },
      transports: ['websocket'],
      reconnectionAttempts: 5,
      reconnectionDelay: 1000,
    });

    socketRef.current = socket;

    socket.on('connect', () => {
      console.log('Socket connected:', socket.id);
      rooms.forEach(room => socket.emit('join', room));
      onConnect?.();
    });

    socket.on('disconnect', (reason) => {
      console.log('Socket disconnected:', reason);
      onDisconnect?.();
    });

    socket.on('connect_error', (error) => {
      console.error('Socket connection error:', error);
      onError?.(error);
    });

    return () => {
      socket.disconnect();
    };
  }, [url, token, rooms, onConnect, onDisconnect, onError]);

  const emit = useCallback((event: string, data: any) => {
    if (socketRef.current?.connected) {
      socketRef.current.emit(event, data);
    } else {
      console.warn('Socket not connected. Event buffered or dropped:', event);
    }
  }, []);

  const on = useCallback((event: string, callback: (...args: any[]) => void) => {
    socketRef.current?.on(event, callback);
    return () => {
      socketRef.current?.off(event, callback);
    };
  }, []);

  return {
    socket: socketRef.current,
    emit,
    on,
    isConnected: socketRef.current?.connected || false,
  };
}



=== FILE: packages\ui\src\hooks\useSpring.ts ===

import { useState, useEffect, useRef } from 'react';

interface SpringConfig {
  stiffness?: number;
  damping?: number;
  mass?: number;
  precision?: number;
}

/**
 * A lightweight spring physics hook for smooth value transitions.
 * Zero dependencies, high performance using requestAnimationFrame.
 */
export function useSpring(
  targetValue: number,
  config: SpringConfig = {}
): number {
  const {
    stiffness = 0.15,
    damping = 0.8,
    mass = 1,
    precision = 0.01
  } = config;

  const [currentValue, setCurrentValue] = useState(targetValue);
  const velocityRef = useRef(0);
  const currentRef = useRef(targetValue);
  const requestRef = useRef<number>();

  useEffect(() => {
    const animate = () => {
      const distance = targetValue - currentRef.current;
      const force = distance * stiffness;
      const acceleration = force / mass;
      
      velocityRef.current = (velocityRef.current + acceleration) * damping;
      currentRef.current += velocityRef.current;

      if (Math.abs(distance) < precision && Math.abs(velocityRef.current) < precision) {
        currentRef.current = targetValue;
        setCurrentValue(targetValue);
        requestRef.current = undefined;
        return;
      }

      setCurrentValue(currentRef.current);
      requestRef.current = requestAnimationFrame(animate);
    };

    if (requestRef.current) cancelAnimationFrame(requestRef.current);
    requestRef.current = requestAnimationFrame(animate);

    return () => {
      if (requestRef.current) cancelAnimationFrame(requestRef.current);
    };
  }, [targetValue, stiffness, damping, mass, precision]);

  return currentValue;
}



=== FILE: packages\ui\src\hooks\useStagger.ts ===

/**
 * Hook to calculate stagger delays for group animations.
 */
export function useStagger(index: number, staggerDelay: number = 100, baseDelay: number = 0) {
  return baseDelay + (index * staggerDelay);
}

/**
 * Hook to manage a sequence of animations.
 */
export function useSequence(count: number, interval: number = 100) {
  // This could be expanded to return an array of booleans or progress values
  // for each item in the sequence.
  return Array.from({ length: count }, (_, i) => i * interval);
}



=== FILE: packages\ui\src\hooks\useTextScramble.ts ===

import { useState, useEffect, useRef } from 'react';

const GLYPHS = '01XYZ#%&@$+-/<>!_';

/**
 * Hook to create a "hacker" style text scramble reveal effect.
 */
export function useTextScramble(text: string, duration = 800, enabled = true) {
  const [output, setOutput] = useState(text);
  const frameRef = useRef<number>();

  useEffect(() => {
    if (!enabled) {
      setOutput(text);
      return;
    }

    const start = Date.now();

    const tick = () => {
      const elapsed = Date.now() - start;
      const progress = Math.min(elapsed / duration, 1);
      
      const scrambled = text.split('').map((char, i) => {
        if (char === ' ') return ' ';
        // Reveal character based on progress and position
        if (progress > (i / text.length)) return char;
        // Otherwise show a random glyph
        return GLYPHS[Math.floor(Math.random() * GLYPHS.length)];
      }).join('');

      setOutput(scrambled);

      if (progress < 1) {
        frameRef.current = requestAnimationFrame(tick);
      }
    };

    frameRef.current = requestAnimationFrame(tick);

    return () => {
      if (frameRef.current) cancelAnimationFrame(frameRef.current);
    };
  }, [text, duration, enabled]);

  return output;
}



=== FILE: packages\ui\src\hooks\useThrottle.ts ===

import { useState, useEffect, useRef } from 'react';

/**
 * A hook that returns a throttled version of the provided value.
 * Useful for scroll or resize events.
 */
export function useThrottle<T>(value: T, limit: number): T {
  const [throttledValue, setThrottledValue] = useState<T>(value);
  const lastRan = useRef(Date.now());

  useEffect(() => {
    const handler = setTimeout(() => {
      if (Date.now() - lastRan.current >= limit) {
        setThrottledValue(value);
        lastRan.current = Date.now();
      }
    }, limit - (Date.now() - lastRan.current));

    return () => {
      clearTimeout(handler);
    };
  }, [value, limit]);

  return throttledValue;
}



=== FILE: packages\ui\src\hooks\useTimer.ts ===

import { useState, useEffect, useCallback, useRef } from 'react';

export function useTimer(initialSeconds: number = 0) {
  const [seconds, setSeconds] = useState(initialSeconds);
  const [isActive, setIsActive] = useState(false);
  const intervalRef = useRef<any>(null);

  const start = useCallback(() => {
    if (!isActive) {
      setIsActive(true);
      intervalRef.current = setInterval(() => {
        setSeconds((prev) => prev + 1);
      }, 1000);
    }
  }, [isActive]);

  const pause = useCallback(() => {
    if (isActive && intervalRef.current) {
      clearInterval(intervalRef.current);
      setIsActive(false);
    }
  }, [isActive]);

  const reset = useCallback(() => {
    if (intervalRef.current) {
      clearInterval(intervalRef.current);
    }
    setIsActive(false);
    setSeconds(0);
  }, []);

  useEffect(() => {
    return () => {
      if (intervalRef.current) {
        clearInterval(intervalRef.current);
      }
    };
  }, []);

  const formatTime = (totalSeconds: number) => {
    const hours = Math.floor(totalSeconds / 3600);
    const minutes = Math.floor((totalSeconds % 3600) / 60);
    const secs = totalSeconds % 60;
    return [hours, minutes, secs]
      .map((v) => (v < 10 ? '0' + v : v))
      .filter((v, i) => v !== '00' || i > 0)
      .join(':');
  };

  return {
    seconds,
    isActive,
    start,
    pause,
    reset,
    formattedTime: formatTime(seconds),
  };
}



=== FILE: packages\ui\src\hooks\useToast.ts ===

import { useContext } from 'react';
import { ToastContext } from '../components/feedback/ToastProvider';

export function useToast() {
  const context = useContext(ToastContext);
  if (!context) {
    throw new Error('useToast must be used within a ToastProvider');
  }
  return context;
}



=== FILE: packages\ui\src\hooks\useToggle.ts ===

import { useState, useCallback } from 'react';

/**
 * A hook for toggling a boolean value.
 */
export function useToggle(initialValue: boolean = false): [boolean, () => void, (value: boolean) => void] {
  const [value, setValue] = useState(initialValue);

  const toggle = useCallback(() => {
    setValue((v) => !v);
  }, []);

  return [value, toggle, setValue];
}



=== FILE: packages\ui\src\hooks\useTypingIndicator.ts ===

import { useState, useCallback, useRef, useEffect } from 'react';

export function useTypingIndicator(timeout = 3000) {
  const [isTyping, setIsTyping] = useState(false);
  const timerRef = useRef<number | null>(null);

  const setTyping = useCallback((typing: boolean) => {
    setIsTyping(typing);
    
    if (timerRef.current) {
      clearTimeout(timerRef.current);
    }

    if (typing) {
      timerRef.current = window.setTimeout(() => {
        setIsTyping(false);
      }, timeout);
    }
  }, [timeout]);

  useEffect(() => {
    return () => {
      if (timerRef.current) clearTimeout(timerRef.current);
    };
  }, []);

  return { isTyping, setTyping };
}



=== FILE: packages\ui\src\hooks\useViewTransition.ts ===

import { flushSync } from 'react-dom';

/**
 * Hook to wrap the native View Transitions API.
 * Allows for seamless transitions between DOM states.
 */
export function useViewTransition() {
  const startTransition = (updateCallback: () => void) => {
    // Fallback for browsers that don't support the View Transitions API
    if (!document.startViewTransition) {
      updateCallback();
      return;
    }

    document.startViewTransition(() => {
      // flushSync is required to ensure React updates the DOM synchronously
      // so the browser can capture the new state for the transition.
      flushSync(() => {
        updateCallback();
      });
    });
  };

  return { startTransition };
}



=== FILE: packages\ui\src\hooks\useVirtualList.ts ===

import { useState, useMemo, useRef, useCallback, useLayoutEffect } from 'react';

export interface UseVirtualListOptions {
  /** Total number of items in the list */
  itemCount: number;
  /** Fixed height of a single item or a function to get height by index */
  itemHeight: number | ((index: number) => number);
  /** Number of items to render outside the visible area */
  overscan?: number;
  /** Initial scroll offset */
  initialScrollTop?: number;
  /** Whether to start the list at the bottom (useful for chats) */
  startAtBottom?: boolean;
}

/**
 * A high-performance hook for virtualizing long lists with dynamic or fixed heights.
 * Supports 120fps scrolling by only rendering visible items.
 */
export function useVirtualList({ 
  itemCount, 
  itemHeight, 
  overscan = 5,
  initialScrollTop = 0,
  startAtBottom = false
}: UseVirtualListOptions) {
  const [scrollTop, setScrollTop] = useState(initialScrollTop);
  const [containerHeight, setContainerHeight] = useState(0);
  const containerRef = useRef<HTMLDivElement>(null);
  const hasInitialScrolled = useRef(false);
  
  const getItemHeight = useCallback((index: number) => {
    return typeof itemHeight === 'function' ? itemHeight(index) : itemHeight;
  }, [itemHeight]);

  useLayoutEffect(() => {
    if (containerRef.current) {
      const observer = new ResizeObserver((entries) => {
        for (const entry of entries) {
          setContainerHeight(entry.contentRect.height);
        }
      });
      observer.observe(containerRef.current);
      
      if (initialScrollTop > 0) {
        containerRef.current.scrollTop = initialScrollTop;
      }

      return () => observer.disconnect();
    }
  }, [initialScrollTop]);

  const onScroll = useCallback((e: React.UIEvent<HTMLDivElement>) => {
    setScrollTop(e.currentTarget.scrollTop);
  }, []);

  const { visibleItems, totalHeight, startIndex } = useMemo(() => {
    let totalHeight = 0;
    const offsets: number[] = [];
    
    for (let i = 0; i < itemCount; i++) {
      offsets.push(totalHeight);
      totalHeight += getItemHeight(i);
    }

    let start = 0;
    let end = itemCount;

    // Binary search for start index
    let low = 0;
    let high = itemCount - 1;
    while (low <= high) {
      const mid = Math.floor((low + high) / 2);
      const offset = offsets[mid];
      if (offset !== undefined && offset <= scrollTop) {
        start = mid;
        low = mid + 1;
      } else {
        high = mid - 1;
      }
    }

    start = Math.max(0, start - overscan);
    
    const visible = [];
    for (let i = start; i < itemCount; i++) {
      const offset = offsets[i];
      if (offset === undefined) break;
      if (offset > scrollTop + containerHeight + (overscan * getItemHeight(i))) break;
      
      visible.push({
        index: i,
        offsetTop: offset,
        height: getItemHeight(i),
      });
    }

    return {
      visibleItems: visible,
      totalHeight,
      startIndex: start,
    };
  }, [scrollTop, containerHeight, itemCount, getItemHeight, overscan]);

  // Handle initial scroll to bottom
  useLayoutEffect(() => {
    if (startAtBottom && !hasInitialScrolled.current && totalHeight > 0 && containerRef.current && containerHeight > 0) {
      const container = containerRef.current;
      const initialScroll = totalHeight - containerHeight;
      if (initialScroll > 0) {
        container.scrollTop = initialScroll;
        setScrollTop(initialScroll);
      }
      hasInitialScrolled.current = true;
    }
  }, [totalHeight, containerHeight, startAtBottom]);

  const scrollToIndex = useCallback((index: number, behavior: ScrollBehavior = 'auto') => {
    if (containerRef.current) {
      let offset = 0;
      for (let i = 0; i < index; i++) {
        offset += getItemHeight(i);
      }
      containerRef.current.scrollTo({ top: offset, behavior });
    }
  }, [getItemHeight]);

  return {
    containerRef,
    visibleItems,
    totalHeight,
    startIndex,
    onScroll,
    scrollToIndex,
    scrollToBottom: (behavior: ScrollBehavior = 'auto') => {
      if (containerRef.current) {
        containerRef.current.scrollTo({ top: containerRef.current.scrollHeight, behavior });
      }
    }
  };
}



=== FILE: packages\ui\src\hooks\useVoiceRecorder.ts ===

import { useState, useRef, useCallback } from 'react';

export interface VoiceRecorderHook {
  isRecording: boolean;
  duration: number;
  audioBlob: Blob | null;
  audioUrl: string | null;
  startRecording: () => Promise<void>;
  stopRecording: () => void;
  cancelRecording: () => void;
  clearAudio: () => void;
}

export function useVoiceRecorder(): VoiceRecorderHook {
  const [isRecording, setIsRecording] = useState(false);
  const [duration, setDuration] = useState(0);
  const [audioBlob, setAudioBlob] = useState<Blob | null>(null);
  const [audioUrl, setAudioUrl] = useState<string | null>(null);
  
  const mediaRecorder = useRef<MediaRecorder | null>(null);
  const timerInterval = useRef<number | null>(null);
  const chunks = useRef<Blob[]>([]);

  const startRecording = useCallback(async () => {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      
      // WhatsApp prefers audio/ogg; codecs=opus for PTT
      const mimeType = MediaRecorder.isTypeSupported('audio/ogg; codecs=opus') 
        ? 'audio/ogg; codecs=opus' 
        : 'audio/webm';
        
      mediaRecorder.current = new MediaRecorder(stream, { mimeType });
      chunks.current = [];

      mediaRecorder.current.ondataavailable = (e) => {
        if (e.data.size > 0) {
          chunks.current.push(e.data);
        }
      };

      mediaRecorder.current.onstop = () => {
        const blob = new Blob(chunks.current, { type: mimeType });
        const url = URL.createObjectURL(blob);
        setAudioBlob(blob);
        setAudioUrl(url);
        
        // Stop all tracks
        stream.getTracks().forEach(track => track.stop());
      };

      mediaRecorder.current.start();
      setIsRecording(true);
      setDuration(0);

      timerInterval.current = window.setInterval(() => {
        setDuration(prev => prev + 1);
      }, 1000);
    } catch (err) {
      console.error('Failed to start recording', err);
      throw err;
    }
  }, []);

  const stopRecording = useCallback(() => {
    if (mediaRecorder.current && isRecording) {
      mediaRecorder.current.stop();
      setIsRecording(false);
      if (timerInterval.current) {
        clearInterval(timerInterval.current);
      }
    }
  }, [isRecording]);

  const cancelRecording = useCallback(() => {
    if (mediaRecorder.current && isRecording) {
      mediaRecorder.current.stop();
      setIsRecording(false);
      if (timerInterval.current) {
        clearInterval(timerInterval.current);
      }
      setAudioBlob(null);
      setAudioUrl(null);
      setDuration(0);
    }
  }, [isRecording]);

  const clearAudio = useCallback(() => {
    setAudioBlob(null);
    setAudioUrl(null);
    setDuration(0);
  }, []);

  return {
    isRecording,
    duration,
    audioBlob,
    audioUrl,
    startRecording,
    stopRecording,
    cancelRecording,
    clearAudio
  };
}

